# -*- coding: utf-8 -*-
from dataclasses import dataclass
import bisect
import struct
from typing import List
import shapefile
import json
from TypeDef import Message, VehicleCodeTable, ProfileType, SegmentableMessage, checkInvalidLonLat, AnalyzePositionError, CommonHeader, getEtherIdDic, EtherID, isGrouppingMessage, Template_Default_Message, Template_Default_Message_WithDraw
import ADASISinfoManager
import random
from math import sqrt
try:
    from ExcelFileCtrl import getCellName, getColumnName, merge_rows, merge_cols, rowGroupingPrint, colGroupingPrint
except:
    pass
from ProfileType import analyzeProfile, UnknownProfile, profileIdDic
from ProfileType import PROFILE_MPU_MAP_DATA_TRANSFER_STS, LanesGeometryProfile, LanesGeometryProfile_US, PROFILETYPE_MPU_ZGM_SIGN_INFO, PROFILETYPE_MPU_US_SIGN, PROFILETYPE_MPU_ZGM_LANE_LINK_INFO, PROFILETYPE_MPU_US_LANE_LINK_INFO, PROFILETYPE_MPU_ZGM_LANE_DIVISION_LINE, PROFILETYPE_MPU_LINE_GEOMETRY, PROFILETYPE_MPU_US_LANE_LINE, PROFILETYPE_MPU_US_LANE_LINE_GEOMETRY, AbsoluteVehiclePositionProfile, PROFILETYPE_MPU_US_SLOPE, PROFILETYPE_MPU_US_LANE_WIDTH, PROFILETYPE_MPU_US_CURVATURE, PROFILE_MPU_MAP_DATA_BASE_POINT, PROFILETYPE_MPU_ZGM_CURVATURE, PROFILETYPE_MPU_ZGM_SLOPE
from GlobalVar import getLogger, setLogIndex, getEthernetSpecVer, getIgnoreSameMsgcnt, getResource, getRecommandLaneViewerClear, getVehicleType, getRecommendedLaneShowTarget, getADASISanalyze, getLocal
from datetime import datetime
import math
from enum import Enum
try:
    from qgis.core import *
    from qgis.gui import *
    from qgis.PyQt import QtGui
    from PyQt5.QtCore import QDateTime
    from PyQt5.QtGui import QColor
except:
    #QGIS以外の環境での実行時、エラーが起きないようにするためダミークラスとして定義
    from LayerManagerForViewer import *
#     from LayerManagerForViewer_AndroidScriptRun import *

class DrawMode(Enum):
    FullDraw = 0
    QGIS_RealTimeDraw = 1
    OpenGL_RealTimeDraw = 2

import collections
class CaseInsensitiveDict(dict):
    def __init__(self, d):
        self._d = d
        self._s = dict((k.lower(), k) for k in d)
    def __contains__(self, k):
        return k.lower() in self._s
    def __len__(self):
        return len(self._s)
    def __iter__(self):
        return iter(self._s)
    def __getitem__(self, k):
        return self._d[self._s[k.lower()]]
    def actual_key_case(self, k):
        return self._s.get(k.lower())
    
#-----------------------------------------------#
#----   Functions                           ----#
#-----------------------------------------------#
def initMessage():
    SegmentableMessage.Reset()
    AnalyzePositionError.Reset()
    ADASISinfoManager.reset()
    CommonHeader.preLogTime = {}
    CommonHeader.preTimeStamp = {}
    ProfileMessage.laneLinkGeometryDic = {}
    ProfileMessage.laneLinkInfoDic = {}
    ProfileMessage.laneLineGeometryDic = {}
    ProfileMessage.laneLineInfoDic = {}
    ProfileMessage.pathIDinfoDic = {}
    GlobalDataMessage.laneLinkGeometryDic = {}
    GlobalDataMessage.currentTransferClassify = 0
    SubscribeMessage.oldTimeDic = {}
    ErrorMessage.errorCodeSymbolDic = {}
    ErrorMessage.errorCodeSymbolUpdated = True
    SendADstatus.Summery_TotalRecordCount = 0
    SendADstatus.Summery_TotalRecordLength = 0
    SendADstatus.Summery_ADStatusGroup = {}
    SendADstatus.Summery_ND2Code = {}
    SendADstatus.Summery_CancelCode = {}
    SendADstatus.Summery_HandOffProhibit = {}
    PathControlMessage.MainPathIDlist = []
    PathControlMessage.SubPathIDlist = []
    ReconstructorLaneList.lastParseMergedDataMessage = None
    initNewLayer()
    
def initNewLayer():
    ProfileMessage.alreadyDrawedLaneID = {}
    ProfileMessage.alreadyDrawedLaneLineID = []
    ProfileMessage.alreadyDrawedLaneGeoID = []
    SendADstatus.firstDrawRDRinfo = [True for _ in range(len(SendADstatus.RDRinfo_symbolDic))]
    SendADstatus.lastDrawRDRinfo = None

def isSegmentableMessage(messageID):
    dicItem = getEtherIdDic(messageID)
    if dicItem == None:
        return False
    return issubclass(globals()[dicItem['class']], SegmentableMessage)

def isAnalyzePositionErrorMessage(messageID):
    dicItem = getEtherIdDic(messageID)
    if dicItem == None:
        return False
    return issubclass(globals()[dicItem['class']], AnalyzePositionError)

# someIPヘッダが除去されて状態であること。
def analyzeMessage(index, time, messageID, data, oldMessage = None, processRelativeParse = True):
    setLogIndex(index)
    dicItem = getEtherIdDic(messageID)
    if dicItem == None:
        return None
    message = globals()[dicItem['class']](index, time, messageID, data)
    if getIgnoreSameMsgcnt() == True and message.commonHeader.messageCount > 0 and message.commonHeader.msgCountDiff == 0:
        return None
    message.oldMessage = oldMessage
    if oldMessage != None:
        oldMessage.nextMessage = message
    if processRelativeParse == True or isGrouppingMessage(messageID) == False:
        message.parse(oldMessage)
    else:
        message.parse(oldMessage, processRelativeParse = False)
    return message

def createLayer(messageID, iface_obj, realTimeMode = DrawMode.FullDraw):
    dicItem = getEtherIdDic(messageID)
    if dicItem == None:
        return None
    cls = globals()[dicItem['class']]
    return cls.createLayer(cls, dicItem['name'], iface_obj, realTimeMode)

def setLayerStyle(fileFullName, layer):
    name = fileFullName[fileFullName.rfind('/')+1:fileFullName.rfind('.')]
    if name == 'GNSS Data Message':
        return EtherID.GNSSDataMessage.value, GNSSDataMessage.SetLayerStyle(GNSSDataMessage.LayerType.GNSS_Location, layer)
    elif name == 'GNSS Data Message(V)':
        return EtherID.GNSSDataMessage.value, GNSSDataMessage.SetLayerStyle(GNSSDataMessage.LayerType.GNSS_Vehicle_Speed, layer)
    elif name == 'GNSS Data Message(errProb)':
        return EtherID.GNSSDataMessage.value, GNSSDataMessage.SetLayerStyle(GNSSDataMessage.LayerType.GPS_ErrProb, layer)
    elif name == 'GNSS Data Message(accProb)':
        return EtherID.GNSSDataMessage.value, GNSSDataMessage.SetLayerStyle(GNSSDataMessage.LayerType.GNSS_AUGACC_ErrProb, layer)
    elif name == 'GNSS Data Message(GPS)':
        return EtherID.GNSSDataMessage.value, GNSSDataMessage.SetLayerStyle(GNSSDataMessage.LayerType.GPS_Location, layer)
    elif name == 'Profile Message':
        return EtherID.ProfileMessage.value, ProfileMessage.SetLayerStyle(ProfileMessage.LayerType.Profile_Map, layer)
    elif name == 'Profile Message(Sign)':
        return EtherID.ProfileMessage.value, ProfileMessage.SetLayerStyle(ProfileMessage.LayerType.Profile_TSR, layer)
    elif name == 'Profile Message(LaneLine)':
        return EtherID.ProfileMessage.value, ProfileMessage.SetLayerStyle(ProfileMessage.LayerType.Profile_LaneLine, layer)
    elif name == 'Vehicle Info':
        return EtherID.VehicleInfo.value, VehicleInfo.SetLayerStyle(VehicleInfo.LayerType.VehicleInfoLayer, layer)
    elif name == 'Global Data Message':
        return EtherID.GlobalDataMessage.value, GlobalDataMessage.SetLayerStyle(GlobalDataMessage.LayerType.GlobalData_AroundMap, layer)
    elif name == 'Recommend Lane Message':
        return EtherID.RecommendLaneMessage_JP.value, RecommendLaneMessage_JP.SetLayerStyle(RecommendLaneMessage_JP.LayerType.RecommendLaned, layer)
    elif name == 'Recommend Lane Message(US)':
        return EtherID.RecommendLaneMessage_US.value, RecommendLaneMessage_US.SetLayerStyle(RecommendLaneMessage_US.LayerType.RecommendLaned, layer)
    elif name == 'Recommend Lane Message(ActionFlag)':
        return EtherID.RecommendLaneMessage_JP.value, RecommendLaneMessage_JP.SetLayerStyle(RecommendLaneMessage_JP.LayerType.ActionFlag, layer)
    elif name == 'Recommend Lane Message(US)(ActionFlag)':
        return EtherID.RecommendLaneMessage_US.value, RecommendLaneMessage_US.SetLayerStyle(RecommendLaneMessage_US.LayerType.ActionFlag, layer)
    elif name == 'Recommend Lane Message(routeConversionStatus)':
        return EtherID.RecommendLaneMessage_JP.value, RecommendLaneMessage_US.SetLayerStyle(RecommendLaneMessage_US.LayerType.RouteConversionStatus, layer)
    elif name == 'Recommend Lane Message(US)(routeConversionStatus)':
        return EtherID.RecommendLaneMessage_US.value, RecommendLaneMessage_US.SetLayerStyle(RecommendLaneMessage_US.LayerType.RouteConversionStatus, layer)
    elif name == 'AD Position Message':
        return EtherID.ADPositionMessage.value, ADPositionMessage.SetLayerStyle(ADPositionMessage.LayerType.ADPosition, layer)
    elif name == 'IVI Position Message':
        return EtherID.IVIPositionMessage.value, IVIPositionMessage.SetLayerStyle(IVIPositionMessage.LayerType.IVIPosition, layer)
    elif name == 'LatLon Position of IVI':
        return EtherID.RouteInfo.value, ADASISv2RouteInfo_ETH.SetLayerStyle(ADASISv2RouteInfo_ETH.LayerType.RouteInfo_IVIPosition, layer)
    elif name == '(CAN) LatLon Position of IVI':
        return EtherID.CAN_LATLON_POS.value, ADASISv2RouteInfo_CAN.SetLayerStyle(ADASISv2RouteInfo_CAN.LayerType.RouteInfo_IVIPosition, layer)
    elif name == 'CarPosition Message(laneProj)':
        return EtherID.CarPositionMessage.value, CarPositionMessage.SetLayerStyle(CarPositionMessage.LayerType.CarPosition_LaneProj, layer)
    elif name == 'CarPosition Message(camera)':
        return EtherID.CarPositionMessage.value, CarPositionMessage.SetLayerStyle(CarPositionMessage.LayerType.CarPosition_CameraPos, layer)
    elif name == 'CarPosition Message(carPos)':
        return EtherID.CarPositionMessage.value, CarPositionMessage.SetLayerStyle(CarPositionMessage.LayerType.CarPosition_CarPos, layer)
    elif name == 'CarPosition Message(errProb)':
        return EtherID.CarPositionMessage.value, CarPositionMessage.SetLayerStyle(CarPositionMessage.LayerType.CarPosition_ErrProb, layer)
    elif name == 'send AD status(R-DR Info)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.RDR_info, layer)
    elif name == 'send AD status(GPS)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.GPS, layer)
    elif name == 'send AD status(MPU_Error)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.MPU_Error, layer)
    elif name == 'send AD status(HDMAP_freshness)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.HDMAP_freshness, layer)
    elif name == 'send AD status(Wide_control_state)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.Wide_control_state, layer)
    elif name == 'send AD status(Long_control_state)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.Long_control_state, layer)
    elif name == 'send AD status(AF_Camera_unstable)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.AF_Camera_unstable, layer)
    elif name == 'send AD status(AF_MAP_freshness)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.AF_MAP_freshness, layer)
    elif name == 'send AD status(AF_Dependancy_of_road)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.AF_Dependancy_of_road, layer)
    elif name == 'send AD status(AF_Dependancy_of_software)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.AF_Dependancy_of_software, layer)
    elif name == 'send AD status(AF_Type_of_construction)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.AF_Type_of_construction, layer)    
    elif name == 'send AD status(AD status)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.AD_status, layer)
    elif name == 'send AD status(Hands off prohibit)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.Hands_off_prohibit, layer)
    elif name == 'send AD status(ND2_code)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.ND2_code, layer)
    elif name == 'send AD status(Cancel_code)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.Cancel_code, layer)
    elif name == 'send AD status(WithWithoutHDMAP)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.WithWithoutHDMAP, layer)
    elif name == 'send AD status(LaneProjectionState)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.LaneProjectionState, layer)
    elif name == 'send AD status':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.RDR_pos, layer)
    elif name == 'send AD status(V)':
        return EtherID.SendADstatus.value, SendADstatus.SetLayerStyle(SendADstatus.LayerType.VehicleDirection, layer)
    elif name == 'ADASIS GlobalDataMessage(MPUPos)':
        return EtherID.ADASISGlobalDataMessage.value, ADASIS_GlobalDataMessage.SetLayerStyle(ADASIS_GlobalDataMessage.LayerType.ADASIS_GlobalData_MPUPos, layer)
    elif name == 'ADASIS GlobalDataMessage(ADPos)':
        return EtherID.ADASISGlobalDataMessage.value, ADASIS_GlobalDataMessage.SetLayerStyle(ADASIS_GlobalDataMessage.LayerType.ADASIS_GlobalData_ADPos, layer)
    elif name == 'Performance Message':
        return EtherID.PerformanceMessage.value, PerformanceMonitorMessage.SetLayerStyle(PerformanceMonitorMessage.LayerType.MCPU_load, layer)
    elif name == 'Reconstructor LaneList':
        return EtherID.ReconstructorLaneList.value, ReconstructorLaneList.SetLayerStyle(ReconstructorLaneList.LayerType.MainSubPath, layer)
    elif name == 'CAM LaneInfrastructureInfo':
        return EtherID.CAMLaneInfrastructureInfo.value, CAMLaneInfrastructureInfo.SetLayerStyle(CAMLaneInfrastructureInfo.LayerType.Cam_LeftRight_Lane, layer)
    elif name == '(FrCamera-ADAS) CAM InfrastructureList':
        return EtherID.CAMInfrastructureList.value, CAMInfrastructureList.SetLayerStyle(CAMInfrastructureList.LayerType.Cam_LeftRight_Lane_ADAS, layer)
    elif name == '(CAN) ADASISv2 SEGMENT':
        return EtherID.CAN_ADASISv2SEGMENT.value, ADASISv2SEGMENT_CAN.SetLayerStyle(ADASISv2SEGMENT_CAN.LayerType.ADASIS_Segment, layer)
    elif name == 'FormOfWay-(CAN) ADASISv2 SEGMENT':
        return EtherID.CAN_ADASISv2SEGMENT.value, ADASISv2SEGMENT_CAN.SetLayerStyle(ADASISv2SEGMENT_CAN.LayerType.ADASIS_Segment_FoW, layer)
    elif name == 'ADASISv2 SEGMENT':
        return EtherID.ADASISv2SEGMENT.value, ADASISv2SEGMENT_ETH.SetLayerStyle(ADASISv2SEGMENT_ETH.LayerType.ADASIS_Segment, layer)
    elif name == 'FormOfWay-ADASISv2 SEGMENT':
        return EtherID.ADASISv2SEGMENT.value, ADASISv2SEGMENT_ETH.SetLayerStyle(ADASISv2SEGMENT_ETH.LayerType.ADASIS_Segment_FoW, layer)
    elif name == 'ADASISv2 PROFILE LONG for AD2':
        return EtherID.ADASISv2PROFILELONGforAD2.value, ADASISv2PROFILELONG_ETH.SetLayerStyle(ADASISv2PROFILELONG_ETH.LayerType.ADASIS_ProfileLong, layer)
    elif name == '(CAN) ADASISv2 PROFILE LONG for AD2':
        return EtherID.CAN_ADASISv2PROFILELONGforAD2.value, ADASISv2PROFILELONG_CAN.SetLayerStyle(ADASISv2PROFILELONG_CAN.LayerType.ADASIS_ProfileLong, layer)
    elif name == 'ADASISv2 STUB':
        return EtherID.ADASISv2STUB.value, ADASISv2STUB_ETH.SetLayerStyle(ADASISv2STUB_ETH.LayerType.ADASIS_Stub, layer)
    elif name == '(CAN) ADASISv2 STUB':
        return EtherID.CAN_ADASISv2STUB.value, ADASISv2STUB_CAN.SetLayerStyle(ADASISv2STUB_CAN.LayerType.ADASIS_Stub, layer)
    elif name == 'ADASISv2 STUB(reroute)':
        return EtherID.ADASISv2STUB.value, ADASISv2STUB_ETH.SetLayerStyle(ADASISv2STUB_ETH.LayerType.ADASIS_StubInfo, layer)
    elif name == '(CAN) ADASISv2 STUB(reroute)':
        return EtherID.CAN_ADASISv2STUB.value, ADASISv2STUB_CAN.SetLayerStyle(ADASISv2STUB_CAN.LayerType.ADASIS_StubInfo, layer)
    elif name == 'ADASISv2 PROFILE SHORT':
        return EtherID.ADASISv2PROFILESHORT.value, ADASISv2PROFILESHORT_ETH.SetLayerStyle(ADASISv2PROFILESHORT_ETH.LayerType.ADASIS_ProfileShort, layer)
    elif name == '(CAN) ADASISv2 PROFILE SHORT':
        return EtherID.CAN_ADASISv2PROFILESHORT.value, ADASISv2PROFILESHORT_CAN.SetLayerStyle(ADASISv2PROFILESHORT_CAN.LayerType.ADASIS_ProfileShort, layer)
    elif name == 'ADASISv2 POSITION':
        return EtherID.ADASISv2POSITION.value, ADASISv2POSITION_ETH.SetLayerStyle(ADASISv2POSITION_ETH.LayerType.ADASIS_Position, layer)
    elif name == '(CAN) ADASISv2 POSITION':
        return EtherID.CAN_ADASISv2POSITION.value, ADASISv2POSITION_CAN.SetLayerStyle(ADASISv2POSITION_CAN.LayerType.ADASIS_Position, layer)
    elif name == 'Road_Data_4_ADAS':
        return EtherID.Road_Data_4_ADAS.value, Road_Data_4_ADAS_ETH.SetLayerStyle(Road_Data_4_ADAS_ETH.LayerType.Road_Link_Type, layer)
    elif name == '(CAN) Road_Data_4_ADAS':
        return EtherID.CAN_Road_Data_4_ADAS.value, Road_Data_4_ADAS_CAN.SetLayerStyle(Road_Data_4_ADAS_CAN.LayerType.Road_Link_Type, layer)
    elif name == 'Path Control Message(Only for process)':
        return EtherID.PathControlMessage.value, None
    elif 'External LonLat info(errDist)' in name:
        return EtherID.ExternalLonLatMessage.value, ExternalLonLatinfo.SetLayerStyle(ExternalLonLatinfo.LayerType.ExternalLonLatinfo_ErrDist, layer)
    elif 'External LonLat info(pos)' in name:
        return EtherID.ExternalLonLatMessage.value, ExternalLonLatinfo.SetLayerStyle(ExternalLonLatinfo.LayerType.ExternalLonLatinfo_Pos, layer)
    elif name == 'Error Message':
        shpReader = shapefile.Reader(fileFullName, encoding='UTF-8')
        errorCodeList = []
        errorCodeItemIndex = 3
        for shprec in shpReader.iterShapeRecords():
            record = shprec.record
            try:
                errorCode = record[errorCodeItemIndex]
            except:
                errorCodeItemIndex = 1
                errorCode = record[errorCodeItemIndex] # ErrorMessage描画に、Lat/Lonを追加する前。
            if type(errorCode) == str:
                errorCode = int(record[errorCodeItemIndex],16)
            else:
                errorCode = int(record[errorCodeItemIndex])
            if not errorCode in errorCodeList:
                errorCodeList.append(errorCode)
        ErrorMessage.addMPUErrorSymbol(errorCodeList)
        return EtherID.ErrorMessage.value, ErrorMessage.SetLayerStyle(ErrorMessage.LayerType.MPUError, layer)
    else:
        return None, layer

def myQgsGraduatedCategoryLayer(layer, symbolDic, categoryName='category', width = None, alpha = None):
    myRangeList = []
    for (myMin, myMax, myColour) in symbolDic:
        myLabel = '{} to {}'.format(myMin, myMax)
        mySymbol = QgsSymbol.defaultSymbol(layer.geometryType())
        mySymbol.setColor(myColour)
        if width != None:
            try:
                mySymbol.setWidth(width)
            except:
                mySymbol.setSize(width)
        if alpha != None:
            mySymbol.setAlpha(alpha)
        myRange = QgsRendererRange(myMin, myMax, mySymbol, myLabel)
        myRangeList.append(myRange)
        
    myRenderer = QgsGraduatedSymbolRenderer(categoryName, myRangeList)
    myRenderer.setMode(QgsGraduatedSymbolRenderer.EqualInterval)
    layer.setRenderer(myRenderer)
    layer.beginEditCommand( 'QGIS draw' )
    return layer

def myQgsRendererCategoryLayer(layer, symbolDic, categoryName='category', width = None, alpha = None):
    categories = []
    for order, params in symbolDic.items():
        if len(params) > 0: symbolColor = params[0]
        if len(params) > 1: symbolLabel = params[1]
        if len(params) > 2: symbolWidth = params[2]
        else: symbolWidth = width
        if len(params) > 3: symbolAlpha = params[3]
        else: symbolAlpha = alpha
        
        sym = QgsSymbol.defaultSymbol(layer.geometryType())
        sym.setColor(symbolColor)
        if symbolWidth != None:
            try:
                sym.setWidth(symbolWidth)
            except:
                sym.setSize(symbolWidth)
        #if symbolAlpha != None: sym.setAlpha(symbolAlpha)
        category = QgsRendererCategory(order, sym, symbolLabel)
        category.setRenderState(True)
        categories.append(category)

    layer.setRenderer(QgsCategorizedSymbolRenderer(categoryName, categories))
    layer.beginEditCommand( 'QGIS draw' )
    return layer

def myQgsRendererCategoryMarkerLayer(layer, symbolDic, categoryName='category', width = None):
    categories = []

    for order, params in symbolDic.items():
        if len(params) > 0: symbolColor = params[0]
        if len(params) > 1: symbolLabel = params[1]
        if len(params) > 2: symbolWidth = params[2]
        else: symbolWidth = width
        
        sym = QgsLineSymbol().createSimple({})
        sym.deleteSymbolLayer(0)
        
        # Line
        lineSymbol = QgsSimpleLineSymbolLayer()
        lineSymbol.setWidth(symbolWidth)
        lineSymbol.setColor(symbolColor)
        sym.appendSymbolLayer(lineSymbol)
                        
        # Marker
        marker = QgsMarkerSymbol.createSimple({})
        marker.deleteSymbolLayer(0)
        props = {}
        props['name'] = 'MyMaker'
        props['size'] = '5'
        #props['offset'] = '-0.5,-0.5'
        props['offset_unit'] = 'Pixel'
        markerSymbol = QgsSimpleMarkerSymbolLayer.create(props)
        marker.appendSymbolLayer(markerSymbol)
        
        # Final Marker
        finalMarker = QgsMarkerLineSymbolLayer()
        finalMarker.setSubSymbol(marker)
        finalMarker.setPlacement(QgsMarkerLineSymbolLayer.LastVertex)
        finalMarker.setColor(symbolColor)
        sym.appendSymbolLayer(finalMarker)
        
        category = QgsRendererCategory(order, sym, symbolLabel)
        category.setRenderState(True)
        categories.append(category)
    
    layer.setRenderer(QgsCategorizedSymbolRenderer(categoryName, categories))
    layer.beginEditCommand( 'QGIS draw' )
    return layer

def myQgsRendererRuleLayer(layer, symbolDic, width = None, alpha = None):
    # create a new rule-based renderer
    sym = QgsSymbol.defaultSymbol(layer.geometryType())
    renderer = QgsRuleBasedRenderer(sym)
    # get the "root" rule
    root_rule = renderer.rootRule()
    for expression, params in symbolDic.items():
        if len(params) > 0: symbolColor = params[0]
        if len(params) > 1: symbolLabel = params[1]
        if len(params) > 2: symbolWidth = params[2]
        else: symbolWidth = width
        if len(params) > 3: symbolAlpha = params[3]
        else: symbolAlpha = alpha
        
        # create a clone (i.e. a copy) of the default rule
        rule = root_rule.children()[0].clone()
        # set the label, expression and color
        rule.setLabel(symbolLabel)
        rule.setFilterExpression(expression)
        rule.symbol().setColor(symbolColor)
        if symbolWidth != None:
            try:
                rule.symbol().setWidth(symbolWidth)
            except:
                rule.symbol().setSize(symbolWidth)
        if symbolAlpha != None: rule.symbol().setOpacity(symbolAlpha)
        # set the scale limits if they have been specified
        # append the rule to the list of rules
        root_rule.appendChild(rule)
    # delete the default rule
    root_rule.removeChildAt(0)
    # apply the renderer to the layer
    layer.setRenderer(renderer)
    layer.beginEditCommand( 'QGIS draw' )
    return layer

#-----------------------------------------------#
#----   TimeStampMessage                    ----#
#-----------------------------------------------#
class TimeStampMessage(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)

    def parse(self, oldMessage = None):
        self.assertMessageSize()
    
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return  [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    
#-----------------------------------------------#
#----   HttpMessage                         ----#
#-----------------------------------------------#
class HttpMessage(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)

    def parse(self, oldMessage = None):
        try:
            buf = self.data.getDataBuf()[self.data.seek():].decode("utf-8")
        except:
            buf = str(self.data.getDataBuf()[self.data.seek():])
        if buf[:3] == 'GET' or buf[:4] == 'POST' or buf[:4] == 'HTTP':
            sI = 0
            eI = buf.find(' ', sI)
            self.cmd = buf[sI:eI]
            sI = eI+1
            eI = buf.find('\r\n', sI)
            self.addr = buf[sI:eI]
        else:
            self.cmd = 'Response'
            self.addr = buf
            
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write_row(row, col, [
            'Cmd', 
            'Addr'], sheet.cellFormats('header'))
        col += 2
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [
            self.cmd, 
            self.addr])
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        pass
    
    
#-----------------------------------------------#
#----   ExternalLonLatinfo                  ----#
#-----------------------------------------------#
class ExternalLonLatinfo(Message, AnalyzePositionError):
    def __init__(self, index, time, definitionID, layerName=''):
        super().__init__(index, time, definitionID, None, useCommonHeader = False)
        AnalyzePositionError.__init__(self)
        self.layerName = layerName

    def parse(self, lon, lat, oldMessage = None):
        self.lon = lon
        self.lat = lat
            
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write_row(row, col, [
            '緯度[deg]', 
            '経度[deg]',], sheet.cellFormats('header'))
        col += 2
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [
            self.lat, 
            self.lon])
        return [row+1, 0, []]
    
    def getAnalyzePositionErrorLonLat(self): #誤差評価対象となる経度緯度
        return [self.lon, self.lat]
    
    def getLonLat(self):
        return [self.lon, self.lat]
    
    class LayerType(Enum):
        ExternalLonLatinfo_Pos = 60
        ExternalLonLatinfo_ErrDist = 61
        
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.ExternalLonLatinfo_Pos:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(0,255,0))
            symbol.setWidth(0.4)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
            
        elif layerType == cls.LayerType.ExternalLonLatinfo_ErrDist:
            if layer.fields().indexFromName('errorDistance[m]') != -1:      
                fieldName = 'errorDistance[m]'
            else:
                fieldName = 'errorDista'
            symbolDic = {
                '"{}" > 0.4'.format(fieldName):(QtGui.QColor.fromRgb(230,20,20),'errorDistance[m] > 0.4', 2.0)}            
            layer = myQgsRendererRuleLayer(layer, symbolDic)
            return [layer, layerType.value]
        
        else:
            return None
        
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        newLayer_pos = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&index=yes',name+'(pos)[' + self.layerName + ']','memory')
        newLayer_pos = self.SetLayerStyle(self.LayerType.ExternalLonLatinfo_Pos, newLayer_pos)
        
        if self.positionError != None:
            newLayer_errDist = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=errorDistance[m]:double&index=yes',name+'(errDist)[' + self.layerName + ']','memory')
            newLayer_errDist = self.SetLayerStyle(self.LayerType.ExternalLonLatinfo_ErrDist, newLayer_errDist)
            
        if self.positionError != None:
            return [newLayer_pos, newLayer_errDist]
        else:
            return [newLayer_pos]
        
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        old = self.oldMessage
        layer_errDist = None
        for layerListItem in layerList:
            if layerListItem[1] == ExternalLonLatinfo.LayerType.ExternalLonLatinfo_Pos.value:
                layer_pos = layerListItem[0]
            elif layerListItem[1] == ExternalLonLatinfo.LayerType.ExternalLonLatinfo_ErrDist.value:
                layer_errDist  = layerListItem[0]
                
        [lon, lat] = self.getLonLat()
        if old != None:
            [oldLon, oldLat] = old.getLonLat()
            if checkInvalidLonLat(lon, lat, oldLon, oldLat, allowSamePoint = True) == True:
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPolyline(
                    [QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)] ))
                feature.setAttributes([QDateTime(self.commonHeader.logTime), lon, lat])
                layer_pos.dataProvider().addFeatures( [feature] )
                
        if layer_errDist != None and self.positionError != None and self.positionError.distance > 0:
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromMultiPolylineXY([[QgsPointXY(self.positionError.foot[0], self.positionError.foot[1]), QgsPointXY(lon, lat)]]))
                feature.setAttributes([QDateTime(self.commonHeader.logTime), self.positionError.distance])
                layer_errDist.dataProvider().addFeatures( [feature] )


#-----------------------------------------------#
#----   ErrorMessage                        ----#
#-----------------------------------------------#
class ErrorMessage(Message):
    errorCodeSymbolDic = {}
    errorCodeSymbolUpdated = True
    
    if getLocal() == 'ja_JP':
        RecoverError = [
            0x8000,'自車位置及びセンサー出力使用不可 : 地図更新上の制限、ロケータへの内部入力異常（キャリブレーション）、外部入力データ異常（車速）、等',
            0x4000,'MPU経路の地図出力使用不可 : 地図更新上の制限、自車位置データ異常',
            0x2000,'IVI経路の地図出力使用不可 : 地図更新上の制限、IVI経路関連入力データ異常（サイズエラー、CRCエラー、カウンター飛び）',
            0x1000,'ADECU経路の地図出力使用不可 : 地図更新上の制限、AD ECU推定自車位置やAD ECU独自経路情報の異常',
            0x0800,'HDMap/RB使用不可 : HDMap/RB管理の異常',
            0x0400,'USB 地図更新不可 : USB電源異常など、USBが使用出来ないとき。 ',
            0x0200,'OTA 地図更新不可 : 地図更新上の制限、サーバ通信起因により、地図のダウンロードに失敗するとき。',
            0x0100,'OTA RB更新不可 : 地図更新上の制限、サーバ通信起因により、RBのダウンロードに失敗するとき。',
            0x0080,'RB応答/アライメント応答不可 : 受信データ異常（サイズエラー、CRCエラー、カウンター飛び）など、RB要求、アライメント要求に応答できないとき。',
            0x0040,'地図更新WGの資料参照。 : 最新Ver状態が、1 : 未確認、0 : 確認済み。',
            0x0020,'サーバとの通信異常 : 一部Resetにより復旧中の通信異常（MapECU故障、MapECU/外部送受信機器間通信異常）',
            0x0010,'AD Statusをサ-バーにアップロードできない : AD Status入力データ異常（サイズエラー、CRCエラー、カウンター飛び）、アップロード失敗（サーバ通信起因）',
            0x0008,'個人情報保護要求 : プライバシー保護のため、R-DRの特定箇所をマスク',
            0x0004,'FOTAによるSW更新不可 : 過去のSW更新失敗や格納メモリの異常、FGWとのシーケンス矛盾などにより、FOTAによるSW更新ができる状態でない場合。',
            0x0002,'地図更新WGの資料参照。 : ライセンス状態が、1 : 無効（未取得含む）、0 : 有効。',
            0x0001,'地図更新WGの資料参照。 : AD2緊急停止が、1 : 有効、0 : 無効。']
    
    else:
        RecoverError = [
            0x8000,'CarPosition and Sensor data output terminated : Map old vversion, Locator input fail(Calibration), Outter input data fail(Vehicle speed), etc..',
            0x4000,'MPU Route output terminated : Map old vversion, CarPosition fail',
            0x2000,'IVI Route output terminated : Map old vversion, IVI route related data input fail(Checksum error, CRC error, cnt jump)',
            0x1000,'ADECU Route output terminated : Map old vversion, AD-Position fail, AD-Route Info fail',
            0x0800,'HDMap/RB terminated : HDMap/RB Management data fail',
            0x0400,'USB Map update fail : USB Power fail, USB not worked',
            0x0200,'OTA Map fail : Map old version, Server connection fail. Cannot download',
            0x0100,'OTA RB fail : Map old version, Server connection fail. Cannot download',
            0x0080,'RB response/Aligment response fail : Receive data fail(size error, CRC error, cnt jump) etc.., Cannot response to request',
            0x0040,'Cannot receive Map version info : Update info unknown',
            0x0020,'Server connection fail : fail during reset (MapECU defectm MapECU/Outter Com fail)',
            0x0010,'AD Status Upload fail : AD Status input data fail (size error, CRC error, cnt jump), Upload fail(Server connection fail)',
            0x0008,'Privacy required : R-DR personal data mask for protect privacy',
            0x0004,'FOTA SW update fail : SW update fail in past or Memory fail, sequence fail between FGW, FOTA condition not satified',
            0x0002,'Propilot license fail (include unchecked)',
            0x0001,'AD2 emergency terminated']

    if getLocal() == 'ja_JP':
        NonRecoverError = [
            0x80,'地図更新不可アラート : T-CPUのResetでは復旧できない故障（T-CPU故障、T-CPU/M-CPU間通信異常、T-CPU/外部送受信機器間通信異常）',
            0x40,'Hands Off禁止 : 地図データ異常(eMMC異常起因を含む）で復旧が見込めないとき',
            0x20,'REMローカリゼーション禁止 : RB格納データ異常(eMMC異常起因を含む）で復旧が見込めないとき',
            0x10,'Hands Off禁止 : 地図データ異常、GNSSアンテナ異常、関連HW(G/Gyroセンサ、GNSS）異常で復旧が見込めないとき']
        
    else:
        NonRecoverError = [
            0x80,'OTAM fail alert : Defect cannot recover although T-CPU reset (T-CPU defect, T-CPU/M-CPU Com fail, T-CPU/Outter Com fail)',
            0x40,'Hands Off prohibitted : Map data fail(include eMMC fail). Cannot recover.',
            0x20,'REM Localization prohibitted : RB data fail(include eMMC fail). Cannot recover.',
            0x10,'Hands Off prohibitted : Map data fail, GNSS antenna fail, related HW(G/Gyro sensor, GNSS）)fail. Cannot recover.']
    
    if getLocal() == 'ja_JP':
        DTC = [
            0x08, '[CPU間通信] UART通信異常',
            0x08, '[CPU間通信] Ether通信異常',
            0x08, '[CPU] MainCPU異常',
            0x08, '[CPU] T-CPU異常',
            0x0A, '[ROM] V-CPU ROM異常',
            0x0A, '[ROM] GNSS ROM異常',
            0x0A, '[Storage] eMMC異常',
            0x08, '[6軸センサ] 6軸センサ異常',
            0x08, '[6軸センサ] 6軸センサデータ異常',
            0x58, '[6軸センサ] ユニット設置角_車両生産ラインキャリブレーション未実施',
            0x58, '[6軸センサ] Gセンサキャリブレーション未実施',
            0x58, '[6軸センサ] Gyroセンサキャリブレーション未実施',
            0x80, '[GNSS] GNSS通信異常',
            0x81, '[GNSS] GNSSデータ異常',
            0x20, '[GNSSアンテナ] GNSSアンテナ異常(オープン)',
            0x21, '[GNSSアンテナ] GNSSアンテナ異常(ショート)',
            0xB0, '[GNSSアンテナ] Lバンドアンテナ異常(オープン)',
            0xB1, '[GNSSアンテナ] Lバンドンテナ異常(ショート)',
            0x08, '[EtherSwitch] Ether回路異常',
            0x08, '[EtherSwitch] EtherSwitch動作異常',
            0x70, '[Ether] Ether通信異常',
            0x71, '[Ether] Ether受信データ異常(システム共通)',
            0x71, '[Ether] Ether受信データ異常(地図情報)',
            0x71, '[Ether] Ether受信データ異常(カメラ情報)',
            0x71, '[Ether] Ether受信データ異常(車両情報)',
            0x71, '[Ether] Ether受信データ異常(AD情報)',
            0x71, '[Ether] Ether受信データ異常(アライメント)',
            0x71, '[Ether] Ether受信データ異常(IVI経路情報)',
            0x71, '[Ether] Ether受信データ異常(RoadRoute情報)',
            0x18, '[USB電源] USB電源異常',
            0x10, '[電源] バッテリー電源電圧異常(高圧)　電源電圧＞18.0V',
            0x11, '[電源] 1次電源電圧(5.0V系)異常(指定範囲外)',
            0x11, '[電源] 2次電源電圧(1.0V系, 1.5V系, 1.8V系, 0.75V系)異常(指定範囲外)',
            0x11, '[電源] 1次電源(3.3V系, 5.0V系)OFF制御異常',
            0x08, '[時間管理] タイムスタンプ異常',
            0x30, '[地図] RBデータ/アライメントデータ異常',
            0x28, '[地図] HDmapデータ異常',
            0x28, '[地図] SDmapデータ異常',
            0x0D, '[温度] ECU内部温度異常(高温)',
            0x98, '[その他] VINデータ不一致']
    
    else:
        DTC = [
            0x08, '[CPU Com] UART Com fail',
            0x08, '[CPU Com] Ether Com fail',
            0x08, '[CPU] MainCPU fail',
            0x08, '[CPU] T-CPU fail',
            0x0A, '[ROM] V-CPU ROM fail',
            0x0A, '[ROM] GNSS ROM fail',
            0x0A, '[Storage] eMMC fail',
            0x08, '[6-axis sensor] 6-axis sensor fail',
            0x08, '[6-axis sensor] 6-axis sensor data fail',
            0x58, '[6-axis sensor] unit equiment factory calibration not complete',
            0x58, '[6-axis sensor] G sensor calibration not complete',
            0x58, '[6-axis sensor] Gyro sensor calibration not complete',
            0x80, '[GNSS] GNSS receive fail',
            0x81, '[GNSS] GNSS data fail',
            0x20, '[GNSS antenna] GNSS antenna circuit open',
            0x21, '[GNSS antenna] GNSS antenna circuit short',
            0xB0, '[GNSS antenna] L-band antenna circuit open',
            0xB1, '[GNSS antenna] L-band antenna circuit short',
            0x08, '[EtherSwitch] Ether circuit fail',
            0x08, '[EtherSwitch] EtherSwitch operation fail',
            0x70, '[Ether] Ether Com fail',
            0x71, '[Ether] Ether data fail(system common)',
            0x71, '[Ether] Ether data fail(map data)',
            0x71, '[Ether] Ether data fail(camera data)',
            0x71, '[Ether] Ether data fail(vehicleInfo data)',
            0x71, '[Ether] Ether data fail(AD data)',
            0x71, '[Ether] Ether data fail(alignment)',
            0x71, '[Ether] Ether data fail(IVI route info)',
            0x71, '[Ether] Ether data fail(RoadRoute info)',
            0x18, '[USB] USB Power fail',
            0x10, '[Power] Battery voltage over 18.0V',
            0x11, '[Power] First power voltage(5.0V) fail (out of range)',
            0x11, '[Power] Secondary power voltage(1.0V, 1.5V, 1.8V, 0.75V) fail (out of range)',
            0x11, '[Power] First power(3.3V, 5.0V) OFF Control fail',
            0x08, '[Timestamp] Timestamp fail',
            0x30, '[Map] RB data/Aliment data fail',
            0x28, '[Map] HDmap data fail',
            0x28, '[Map] SDmap data fail',
            0x0D, '[Temperature] ECU inner temperature high',
            0x98, '[Other] VIN number mismatch']
                      
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
    
    @staticmethod
    def addMPUErrorSymbol(errorCode):
        if type(errorCode) != type([]):
            errorCode = [errorCode]
            
        for code in errorCode:
            if (code != 0) and (not code in ErrorMessage.errorCodeSymbolDic):
                ErrorMessage.errorCodeSymbolDic[code] = (QtGui.QColor.fromRgb(random.randint(0,255),random.randint(0,255),random.randint(0,255)),
                                                                            '0x' + format(code, '08X'))
                ErrorMessage.errorCodeSymbolUpdated = True
            
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.MPUErrorStatus = readFunc(int,32)
        self.recoverErrorCode = (self.MPUErrorStatus & 0xFFFF0000) >> 16
        self.nonRecoverErrorCode = (self.MPUErrorStatus & 0x0000FF00) >> 8
        self.dtcCode = (self.MPUErrorStatus & 0x000000FF)
        self.assertMessageSize()
        
        if (self.MPUErrorStatus != 0) and (not self.MPUErrorStatus in ErrorMessage.errorCodeSymbolDic):
            ErrorMessage.addMPUErrorSymbol(self.MPUErrorStatus)
            logger = getLogger()
            logger.logPrintWithConsol("[ Error Code (logIndex={0}) ] RecoverError : {1} , NonRecoverError : {2} , DTC = {3}".format(self.commonHeader.logIndex, hex(self.recoverErrorCode), hex(self.nonRecoverErrorCode), hex(self.dtcCode)))
            for i in range(0, len(ErrorMessage.RecoverError),2):
                if self.recoverErrorCode & ErrorMessage.RecoverError[i] != 0:
                    logger.logPrintWithConsol("\t" + ErrorMessage.RecoverError[i+1])
            for i in range(0, len(ErrorMessage.NonRecoverError),2):
                if self.nonRecoverErrorCode & ErrorMessage.NonRecoverError[i] != 0:
                    logger.logPrintWithConsol("\t" + ErrorMessage.NonRecoverError[i+1])
            for i in range(0, len(ErrorMessage.DTC),2):
                if self.dtcCode == ErrorMessage.DTC[i]:
                    logger.logPrintWithConsol("\t" + ErrorMessage.DTC[i+1])
            
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write_row(row, col, [
            'MapECU停止機能(復帰可)', 
            'MapECU停止機能(復帰不可)', 
            '故障コード'], sheet.cellFormats('header'))
        col += 3
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [
            '0x' + format(self.recoverErrorCode, '04X'), 
            '0x' + format(self.nonRecoverErrorCode, '02X'), 
            '0x' + format(self.dtcCode, '02X')])
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    
    class LayerType(Enum):
        MPUError = 50
            
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.MPUError:
            layer = myQgsRendererCategoryLayer(layer, ErrorMessage.errorCodeSymbolDic, 'ErrorCode', width = 0.6)
            return [layer, layerType.value]
        
        else:
            return None
    
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if realTimeMode == DrawMode.FullDraw:
            newLayer_MPUError = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&field=ErrorCode:string&index=yes',name,'memory')
            newLayer_MPUError = self.SetLayerStyle(self.LayerType.MPUError, newLayer_MPUError)
            return [newLayer_MPUError]
        else:
            return None
    
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        old = self.oldMessage
        if (realTimeMode == DrawMode.QGIS_RealTimeDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw):
            return
    
        for layerListItem in layerList:
            if layerListItem[1] == ErrorMessage.LayerType.MPUError.value:
                layer_error = layerListItem[0]
        
        if ErrorMessage.errorCodeSymbolUpdated == True:
            ErrorMessage.errorCodeSymbolUpdated = False
            layer_error = myQgsRendererCategoryLayer(layer_error, ErrorMessage.errorCodeSymbolDic, 'ErrorCode', width = 0.6)
        
        if old == None:
            return
        if self.relatedCarPositionMessage == None or old.relatedCarPositionMessage == None:
            return
        
        if self.MPUErrorStatus != 0:
            [lon, lat, z] = self.relatedCarPositionMessage.getLonLatZ()
            [oldLon, oldLat, oldZ] = old.relatedCarPositionMessage.getLonLatZ()
            if checkInvalidLonLat(lon, lat, oldLon, oldLat) == True:
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldLon, oldLat, oldZ), QgsPoint(lon, lat, z)]))
                feature.setAttributes([QDateTime(self.commonHeader.logTime), lon, lat, hex(self.MPUErrorStatus)])
                layer_error.dataProvider().addFeatures( [feature] )

#-----------------------------------------------#
#----   SubscribeMessage                    ----#
#-----------------------------------------------#
class SubscribeMessage(Message):
    TypeDic = {0x00:'[0:Find]', 0x01:'[1:Offer]', 0x06:'[6:Subscribe]', 0x07:'[7:SubscribeAck]', 0x08:'[7(0):SubscribeNack]'}
    oldTimeDic = {}
        
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        readFunc(int,8) #Reboot flag, Unicast flag
        isMessage = readFunc(int,24)
        if isMessage == 0: #subscribe is reserve area.
            entriesCount = int(readFunc(int,32) / 16)
            self.dataArray = []
            self.timeDiffFromPre = []
            
            for _ in range(entriesCount):
                subscribeType = readFunc(int,8)
                readFunc(int,24) #unused info
                serviceID = readFunc(int,16)
                readFunc(bytes,40) #unused info
                ttl = readFunc(int,8)
                readFunc(bytes,32) #unused info
                
                if ttl == 0 and subscribeType == 0x07:
                    subscribeType = 0x08
                serviceName = SubscribeMessage.TypeDic.get(subscribeType, '[Unknown]') + hex(serviceID)
                self.dataArray.append(serviceName)
                if serviceName in SubscribeMessage.oldTimeDic:
                    self.timeDiffFromPre.append(int((self.commonHeader.logTime - SubscribeMessage.oldTimeDic[serviceName]).total_seconds() * 1000))
                else:
                    self.timeDiffFromPre.append(0)
                SubscribeMessage.oldTimeDic[serviceName] = self.commonHeader.logTime
                
            lengthOfOptionArray = readFunc(int,32)
            readFunc(bytes,lengthOfOptionArray) #unused info
            
        else: #content message is fix 1 (write in PCAPLoader module)
            self.dataArray = []
            self.timeDiffFromPre = []
            
            serviceID = readFunc(int,32)
            serviceName = '[Message]' + hex(serviceID)
            self.dataArray.append(serviceName)
            if serviceName in SubscribeMessage.oldTimeDic:
                self.timeDiffFromPre.append(int((self.commonHeader.logTime - SubscribeMessage.oldTimeDic[serviceName]).total_seconds() * 1000))
            else:
                self.timeDiffFromPre.append(0)
            SubscribeMessage.oldTimeDic[serviceName] = self.commonHeader.logTime
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write_row(row, col, ['Subscribe', 'TimeSpan[ms]\n<SameService>'], sheet.cellFormats('header'))
        col += 2
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        if len(self.dataArray) == 0:
            [row, new_col, _] = self.commonHeader.printValue(sheet, row, col)
            sheet.write_row(row, new_col, ['None', '0'])
            #sheet.write(row, col+2, '=IFERROR(INT(({0}{1} - LOOKUP(2,1/SUBTOTAL(3,OFFSET({0}$1,ROW({0}$1:{0}{2})-ROW({0}$1),0)),{0}$1:{0}{2}))*86400000),0)'.format(getColumnName(col+1),row+1,row))
            return [row+1, 0, []]
        else:
            new_row = row
            for i in range(len(self.dataArray)):
                #複数行を出力するため、以前の列には、同じ
                if new_row != row:
                    for c in range(col):
                        sheet.write(new_row, c, '=' + getCellName(new_row-1,c))
                [new_row, new_col, _] = self.commonHeader.printValue(sheet, new_row, col)
                sheet.write_row(new_row, new_col, [self.dataArray[i], self.timeDiffFromPre[i]])
                new_row += 1
            return [new_row, 0, []]

    
#-----------------------------------------------#
#----   VinDataMessage                      ----#
#-----------------------------------------------#
class VinDataMessage(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.VIN = readFunc(str,8*17)
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write(row, col, 'VIN', sheet.cellFormats('header'))
        col += 1
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write(row, col, str(self.VIN))
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    

#-----------------------------------------------#
#----   USBUpdateInfoMessage                ----#
#-----------------------------------------------#
class USBUpdateInfoMessage(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.USBUpdateFlag = readFunc(int,8)
        self.USBUpdateProgress = readFunc(int,8)
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write_row(row, col, ['USB_update_flag', 'USB_update_progress'], sheet.cellFormats('header'))
        col += 2
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [(self.USBUpdateFlag), (self.USBUpdateProgress)])
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    

#-----------------------------------------------#
#----   SpecificADModeMessage               ----#
#-----------------------------------------------#
class SpecificADModeMessage(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.perTestAD2TestMode = readFunc(int,8)
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write(row, col, 'PerTest_AD2TestMode', sheet.cellFormats('header'))
        col += 1
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write(row, col, (self.perTestAD2TestMode))
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    
 
#-----------------------------------------------#
#----   PerformanceMonitorMessage           ----#
#-----------------------------------------------#
class PerformanceMonitorMessage(Message):
    Performance_symbolDic = {
             0:(QtGui.QColor.fromRgb(250,000,000),'= 100 %'),
             1:(QtGui.QColor.fromRgb(230,000,000),'>= 99 %'),
             2:(QtGui.QColor.fromRgb(210,000,000),'>= 97 %'),
             3:(QtGui.QColor.fromRgb(190,000,000),'>= 95 %'),
             4:(QtGui.QColor.fromRgb(170,000,000),'>= 93 %'),
             5:(QtGui.QColor.fromRgb(150,000,000),'>= 90 %'),
             6:(QtGui.QColor.fromRgb(130,000,000),'>= 85 %'),
             7:(QtGui.QColor.fromRgb(110,000,000),'>= 80 %')}
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)   
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.timeStampSystem = readFunc(int,32)
        self.cpuUsage_MCPU = readFunc(int,8)
        self.cpuUsage_TCPU = readFunc(int,8)
        self.cpuUsage_VCPU = readFunc(int,8)
        readFunc(int,8) #reserved 1
        readFunc(int,32) #reserved 2
        readFunc(int,32) #reserved 3
        readFunc(int,32) #reserved 4
        readFunc(int,32) #reserved 5
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write_row(row, col, ['システム時刻 (ms)', 'CPU使用率(MCPU)', 'CPU使用率(TCPU)', 'CPU使用率(VCPU)'], sheet.cellFormats('header'))
        col += 4
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [(self.timeStampSystem), (self.cpuUsage_MCPU), (self.cpuUsage_TCPU), (self.cpuUsage_VCPU)])
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
        chart = book.add_chart({'type': 'line'})
        chart.set_title({
            'name': 'CPU負荷率(%)'})
        chart.add_series({
            'name': 'M-CPU',
            'categories': "='{0}'!$B$1:$B${1}".format(sheet.name, totalRows),
            'values':     "='{0}'!$L$1:$L${1}".format(sheet.name, totalRows)})
        sheet.insert_chart('C18', chart)
    
    class LayerType(Enum):
        MCPU_load = 45
        
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.MCPU_load:
            layer = myQgsRendererCategoryLayer(layer, PerformanceMonitorMessage.Performance_symbolDic, width = 0.6)
            return [layer, layerType.value]
        else:
            return None
            
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if realTimeMode == DrawMode.FullDraw:
            newLayer_MCPUload = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&field=M-CPU[%]:double&field=T-CPU[%]:double&field=V-CPU[%]:double&index=yes',name,'memory')
            newLayer_MCPUload = self.SetLayerStyle(self.LayerType.MCPU_load, newLayer_MCPUload)
            return [newLayer_MCPUload]
        else:
            return None
    
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        old = self.oldMessage
        if (realTimeMode == DrawMode.QGIS_RealTimeDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw):
            return
        
        for layerListItem in layerList:
            if layerListItem[1] == PerformanceMonitorMessage.LayerType.MCPU_load.value:
                layer_MCPUload = layerListItem[0]
                
        if old == None:
            return
        if self.relatedCarPositionMessage == None or old.relatedCarPositionMessage == None:
            return
        
        if self.cpuUsage_MCPU == 100: category = 0
        elif self.cpuUsage_MCPU >= 99: category = 1
        elif self.cpuUsage_MCPU >= 97: category = 2
        elif self.cpuUsage_MCPU >= 95: category = 3
        elif self.cpuUsage_MCPU >= 93: category = 4
        elif self.cpuUsage_MCPU >= 90: category = 5
        elif self.cpuUsage_MCPU >= 85: category = 6
        elif self.cpuUsage_MCPU >= 80: category = 7
        else: return
        
        [lon, lat, z] = self.relatedCarPositionMessage.getLonLatZ()
        [oldLon, oldLat, oldZ] = old.relatedCarPositionMessage.getLonLatZ()
        if checkInvalidLonLat(lon, lat, oldLon, oldLat) == True:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldLon, oldLat, oldZ), QgsPoint(lon, lat, z)]))
            
            feature.setAttributes([QDateTime(self.commonHeader.logTime), category, (self.cpuUsage_MCPU), (self.cpuUsage_TCPU), (self.cpuUsage_VCPU)])
            layer_MCPUload.dataProvider().addFeatures( [feature] )

#-----------------------------------------------#
#----   SensorRedundancyStatusMessage       ----#
#-----------------------------------------------#
class SensorRedundancyStatusMessage(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.sensorRedundancyStatus = readFunc(int,8)
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write(row, col, 'SensorRedundancyStatus', sheet.cellFormats('header'))
        col += 1
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write(row, col, (self.sensorRedundancyStatus))
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    

#-----------------------------------------------#
#----   VehicleParameterMessage             ----#
#-----------------------------------------------#
class VehicleParameterMessage(Message):
    @dataclass
    class Posture:
        roll: int
        pitch: int
        yaw: int
        
    @dataclass
    class Position:
        x: int
        y: int
        z: int
        
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.standardTireRadius = readFunc(int,16)
        self.unitMount = self.Posture(
            roll = readFunc(int,16),
            pitch = readFunc(int,16), 
            yaw = readFunc(int,16))
        self.cameraPosition = self.Position(
            x = readFunc(int,16),
            y = readFunc(int,16),
            z = readFunc(int,16))
        self.GNSSPosition = self.Position(
            x = readFunc(int,16),
            y = readFunc(int,16),
            z = readFunc(int,16))
        self.frBumperPosition = self.Position(
            x = readFunc(int,16),
            y = readFunc(int,16),
            z = readFunc(int,16))
        
        ethernetSpecVersion = getEthernetSpecVer()
        if ethernetSpecVersion >= datetime(2020, 12, 25):
            self.unitMountOffset = self.Position(
                x = readFunc(int,16),
                y = readFunc(int,16),
                z = readFunc(int,16))
            self.centerOffset = self.Position(
                x = readFunc(int,16),
                y = readFunc(int,16),
                z = readFunc(int,16))
            self.vehicleCode = readFunc(int,16)
        else:
            self.unitMountOffset = self.Position(x = 0x7FFF, y = 0x7FFF, z = 0x7FFF)
            self.centerOffset = self.Position(x = 0x7FFF, y = 0x7FFF, z = 0x7FFF)
            self.vehicleCode = 0xFFFF
            
        self.vehicleCodeStr = VehicleCodeTable.get(self.vehicleCode, 'Unknown')
            
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        newCol = col
        sheet.write(row, newCol, 'Common Header', sheet.cellFormats('header'))
        merge_cols(sheet, row, newCol, self.commonHeader.columnCount(), True)
        newCol += self.commonHeader.columnCount()
        newCol += 1
        sheet.write(row, newCol, 'ユニット取付角', sheet.cellFormats('header'))
        merge_cols(sheet, row, newCol, 3, True)
        newCol += 3
        sheet.write(row, newCol, 'カメラ位置の車両基準位置オフセット', sheet.cellFormats('header'))
        merge_cols(sheet, row, newCol, 3, True)
        newCol += 3
        sheet.write(row, newCol, 'GNSSアンテナ位置の車両基準位置オフセット', sheet.cellFormats('header'))
        merge_cols(sheet, row, newCol, 3, True)
        newCol += 3
        sheet.write(row, newCol, 'Frバンパー位置の車両基準位置オフセット', sheet.cellFormats('header'))
        merge_cols(sheet, row, newCol, 3, True)
        newCol += 3
        sheet.write(row, newCol, 'ユニット設置位置の車両基準位置オフセット', sheet.cellFormats('header'))
        merge_cols(sheet, row, newCol, 3, True)
        newCol += 3
        sheet.write(row, newCol, '後軸車軸中央位置の車両基準位置オフセット', sheet.cellFormats('header'))
        merge_cols(sheet, row, newCol, 3, True)
        
        newCol = col
        [_, newCol, _] = self.commonHeader.printHeader(sheet, row+1, newCol)
        
        sheet.write(row+1, newCol, '標準タイヤ半径[mm]', sheet.cellFormats('header'))
        newCol += 1

        sheet.write_row(row+1, newCol, ['X軸(ロール軸)[deg]', 'Y軸(ピッチ軸)[deg]', 'Z軸(ヨー軸)[deg]'], sheet.cellFormats('header'))
        newCol += 3
        
        sheet.write_row(row+1, newCol, ['X方向[m]', 'Y方向[m]', 'Z方向[m]'], sheet.cellFormats('header'))
        newCol += 3
        
        sheet.write_row(row+1, newCol, ['X方向[m]', 'Y方向[m]', 'Z方向[m]'], sheet.cellFormats('header'))
        newCol += 3
        
        sheet.write_row(row+1, newCol, ['X方向[m]', 'Y方向[m]', 'Z方向[m]'], sheet.cellFormats('header'))
        newCol += 3
        
        sheet.write_row(row+1, newCol, ['X方向[m]', 'Y方向[m]', 'Z方向[m]'], sheet.cellFormats('header'))
        newCol += 3
        
        sheet.write_row(row+1, newCol, ['X方向[m]', 'Y方向[m]', 'Z方向[m]'], sheet.cellFormats('header'))
        newCol += 3
        
        sheet.write(row+1, newCol, '車種情報', sheet.cellFormats('header'))
        newCol += 1
        
        sheet.freeze_panes(2, 0)
        sheet.set_row(0, 20)
        sheet.set_row(1, 20)
        sheet.autofilter(1, 0, 1, newCol-1)
        
        return [row+2, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [
            (self.standardTireRadius*0.1),
            (self.unitMount.roll*0.1 - 180.0),
            (self.unitMount.pitch*0.1 - 180.0),
            (self.unitMount.yaw*0.1 - 180.0),
            (self.cameraPosition.x*0.001 - 12.000),
            (self.cameraPosition.y*0.001 - 2.500),
            (self.cameraPosition.z*0.001 - 3.800),
            (self.GNSSPosition.x*0.001 - 12.000),
            (self.GNSSPosition.y*0.001 - 2.500),
            (self.GNSSPosition.z*0.001 - 3.800),
            (self.frBumperPosition.x*0.001 - 12.000),
            (self.frBumperPosition.y*0.001 - 2.500),
            (self.frBumperPosition.z*0.001 - 3.800),
            (self.unitMountOffset.x*0.001 - 12.000),
            (self.unitMountOffset.y*0.001 - 2.500),
            (self.unitMountOffset.z*0.001 - 3.800),
            (self.centerOffset.x*0.001 - 12.000),
            (self.centerOffset.y*0.001 - 2.500),
            (self.centerOffset.z*0.001 - 3.800),
            hex(self.vehicleCode)
            ])
        
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    

#-----------------------------------------------#
#----   ProfileControlMessage               ----#
#-----------------------------------------------#
maximumProfileControlMessagePathCount:int = 20
class ProfileControlMessage(Message, SegmentableMessage):

    @dataclass
    class Path:
        pathID: int
        offset: int
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.segmentCount = readFunc(int,16)
        self.segmentIndex = readFunc(int,16)
        readFunc(int,16) #reserve
        self.dataArrayCount = readFunc(int,16)
        self.dataArray = []
        self.mergeSegmentData(None, self.segmentIndex, self.segmentCount, self.data.getDataBuf()[self.data.seek():])
    
    def parseMergedData(self, data):
        readFunc = data.readValue
        for _ in range(self.dataArrayCount):
            self.dataArray.append(self.Path(
                pathID = readFunc(int,32),
                offset = readFunc(int,32)))
        
    def printHeader(self, sheet, row, col, _level = 1):
        [_, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write_row(row, col, ['分割数', '分割番号', 'Number of Array'], sheet.cellFormats('header'))
        col += 3
        
        global maximumProfileControlMessagePathCount
        for i in range(maximumProfileControlMessagePathCount):
            sheet.write_row(row, col, ['Path Id(' + str(i+1) + ')', 'Offset[cm](' + str(i+1) + ')'])
            col += 2
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
      
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [
            (self.segmentCount),
            (self.segmentIndex),
            (self.dataArrayCount)])
        col += 3

        for path in self.dataArray:
            sheet.write_row(row, col, [hex(path.pathID), (path.offset)])
            col += 2
            
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    

#-----------------------------------------------#
#----   PathControlMessage                  ----#
#-----------------------------------------------#
maximumPathControlMessagePathCount:int = 20
class PathControlMessage(Message, SegmentableMessage):
    MainPathIDlist = []
    SubPathIDlist = []

    @dataclass
    class Path:
        pathID: int
        parentPathID: int
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.segmentCount = readFunc(int,16)
        self.segmentIndex = readFunc(int,16)
        readFunc(int,16) #reserve
        self.dataArrayCount = readFunc(int,16)
        self.dataArray = []
        self.mergeSegmentData(None, self.segmentIndex, self.segmentCount, self.data.getDataBuf()[self.data.seek():])
    
    def parseMergedData(self, data):
        readFunc = data.readValue
        for _ in range(self.dataArrayCount):
            self.dataArray.append(self.Path(
                pathID = readFunc(int,32),
                parentPathID = readFunc(int,32)))            
        
    def printHeader(self, sheet, row, col, _level = 1):
        [_, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write_row(row, col, ['分割数', '分割番号', 'Number of Array'], sheet.cellFormats('header'))
        col += 3
        
        global maximumPathControlMessagePathCount
        for i in range(maximumPathControlMessagePathCount):
            sheet.write_row(row, col, ['Path Id(' + str(i+1) + ')', 'Parent Path ID(' + str(i+1) + ')'])
            col += 2
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [
            (self.segmentCount),
            (self.segmentIndex),
            (self.dataArrayCount)])
        col += 3

        for path in self.dataArray:
            sheet.write_row(row, col, [hex(path.pathID), hex(path.parentPathID)])
            col += 2
            
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    
    class LayerType(Enum):
        PathControl = 78
        
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.PathControl:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(0,0,0))
            symbol.setWidth(1)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
        
        else:
            return None
    
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if realTimeMode == DrawMode.FullDraw:
            newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612',name+'(Only for process)','memory')
            newLayer = self.SetLayerStyle(self.LayerType.PathControl, newLayer)
            return [newLayer]
        else:
            return None
    
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        if realTimeMode == DrawMode.FullDraw:
            for i in range(self.dataArrayCount):
                pathID = self.dataArray[i].pathID
                if i == 0: #Main Path
                    if not pathID in PathControlMessage.MainPathIDlist:
                        PathControlMessage.MainPathIDlist.append(pathID)
                    if pathID in PathControlMessage.SubPathIDlist:
                        PathControlMessage.SubPathIDlist.remove(pathID)
                else: #Sub Path
                    if pathID in PathControlMessage.MainPathIDlist:
                        PathControlMessage.MainPathIDlist.remove(pathID)
                    if not pathID in PathControlMessage.SubPathIDlist:
                        PathControlMessage.SubPathIDlist.append(pathID)
    
    
#-----------------------------------------------#
#----   PositionMessage                     ----#
#-----------------------------------------------#
maximumPositionMessagePathCount:int = 10
class PositionMessage(Message, SegmentableMessage):
    @dataclass
    class Path:
        pathID: int
        reserved: int
        offset: int
        accuracy: int
        lateralOffset: int
        status: int
        speed: int
        relativeHeading: int
        probability: int
        currentLane: int
        
        def printHeader(self, sheet, row, col, _level = 1):
            sheet.write_row(row, col, [
                'Path Id', 
                'Offset[cm]', 
                'Accuracy[cm]', 
                'Lateral Offset[cm]', 
                'Status', 
                'Speed[m/s]', 
                'Relative Heading[deg]', 
                'Probability[%]', 
                'Current Lane'])    
            return [row, col+9, []]
        
        def printValue(self, sheet, row, col, _level = 1):
            sheet.write_row(row, col, [
                (hex(self.pathID)),
                (self.offset),
                (self.accuracy),
                (self.lateralOffset),
                (self.status),
                (self.speed),
                (self.relativeHeading * 0.001),
                (self.probability),
                (self.currentLane)])
            return [row, col+9, []]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.segmentCount = readFunc(int,16)
        self.segmentIndex = readFunc(int,16)
        readFunc(int,16) #reserve
        self.dataArrayCount = readFunc(int,16)
        self.globalTimeStamp = 0
        if oldMessage != None:
            self.globalTimeStamp_old = oldMessage.globalTimeStamp
        else:
            self.globalTimeStamp_old = 0
        self.relativeTimeStamp = 0
        self.invalidFlag = 0
        self.dataArray = []
        self.mergeSegmentData(None, self.segmentIndex, self.segmentCount, self.data.getDataBuf()[self.data.seek():])
    
    def parseMergedData(self, data):
        readFunc = data.readValue
        self.globalTimeStamp = readFunc(int,64)
        self.relativeTimeStamp = readFunc(int,64)
        self.invalidFlag = readFunc(int,16)
        readFunc(int,16) #reserve
        for _ in range(self.dataArrayCount):
            self.dataArray.append(self.Path(
                pathID = readFunc(int,32),
                reserved = readFunc(int,32),
                offset = readFunc(int,32),
                accuracy = readFunc(int,32),
                lateralOffset = readFunc(int,32),
                status = readFunc(int,32),
                speed = readFunc(int,32),
                relativeHeading = readFunc(int,32,True),
                probability = readFunc(int,32),
                currentLane = readFunc(int,32)))
        
    def printHeader(self, sheet, row, col, level = 1):
        [_, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write_row(row, col, ['分割数', '分割番号', 'Number of Array', 'GlobalVar time stamp[μs]', '差分[ms]', 'Relative time stamp[μs]', '無効フラグ'], sheet.cellFormats('header'))
        col += 7
        
        global maximumPositionMessagePathCount
        for i in range(maximumPositionMessagePathCount):
            [_, col, _] = colGroupingPrint('PathInfo(' + str(i+1) + ')', self.Path, self.Path.printHeader, sheet, row, col, level)
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [_, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [
            (self.segmentCount),
            (self.segmentIndex),
            (self.dataArrayCount),
            (self.globalTimeStamp),
            (self.globalTimeStamp - self.globalTimeStamp_old) / 1000,
            (self.relativeTimeStamp),
            hex(self.invalidFlag)])
        col += 7

        for path in self.dataArray:
            [_, col, _] = path.printValue(sheet, row, col)
            col += 1 #for gruop header col
            
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
        chart = book.add_chart({'type': 'line'})
        chart.set_title({
            'name': 'GlobalVar time stamp[μs]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'values':     "='{0}'!$N$1:$N${1}".format(sheet.name, totalRows)})
        sheet.insert_chart('C18', chart)
        
        chart = book.add_chart({'type': 'scatter'})
        chart.set_title({
            'name': 'GlobalVar time stamp 差分[ms]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'name': '間隔[ms]',
            'categories': "='{0}'!$A$1:$A${1}".format(sheet.name, totalRows),
            'values':     "='{0}'!$O$1:$O${1}".format(sheet.name, totalRows)})
        chart.set_y_axis({'min': 80, 'max': 120})
        sheet.insert_chart('J18', chart)
    

#-----------------------------------------------#
#----   IntersectionMessage                 ----#
#-----------------------------------------------#
maximumIntersectionMessageStubCount: int = 10
class IntersectionMessage(Message, SegmentableMessage):

    @dataclass
    class Stub:
        subpathInstanceID: int
        subpathID: int
        subpathType: int
        turnAngle: int
        isComplexIntersection: bool
        rightOfWay: int
        
        def printHeader(self, sheet, row, col, _level = 1):
            sheet.write_row(row, col, [
                'Subpath Instance ID', 
                'Subpath ID', 
                'Subpath Type', 
                'Turn Angle[deg]', 
                'Is Complex Intersection', 
                'Right of Way'])    
            return [row, col+6, []]
        
        def printValue(self, sheet, row, col, _level = 1):
            sheet.write_row(row, col, [
                (hex(self.subpathInstanceID)),
                (hex(self.subpathID)),
                (self.subpathType),
                (self.turnAngle),
                (self.isComplexIntersection),
                (self.rightOfWay)])
            return [row, col+6, []]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.id = readFunc(int,64)
        self.segmentCount = readFunc(int,16)
        self.segmentIndex = readFunc(int,16)
        readFunc(int,16) #reserved
        self.dataArrayCount = readFunc(int,16)
        self.instanceID = 0
        self.isRetransmission = 0
        self.isUpdate = 0
        self.pathID = 0
        self.offset = 0
        self.previousInstanceID = 0
        self.dataArray = []
        self.mergeSegmentData(self.id, self.segmentIndex, self.segmentCount, self.data.getDataBuf()[self.data.seek():])
    
    def parseMergedData(self, data):
        readFunc = data.readValue
        self.instanceID = readFunc(int,32)
        self.isRetransmission = readFunc(bool,32)
        self.isUpdate = readFunc(bool,32)
        self.pathID = readFunc(int,32)
        self.offset = readFunc(int,32)
        self.previousInstanceID = readFunc(int,32)
        self.dataArray = []
        for _ in range(self.dataArrayCount):
            self.dataArray.append(self.Stub(
                subpathInstanceID = readFunc(int,32),
                subpathID = readFunc(int,32),
                subpathType = readFunc(int,32),
                turnAngle = readFunc(int,32,True),
                isComplexIntersection = readFunc(bool,32),
                rightOfWay = readFunc(int,32)))
        
    def printHeader(self, sheet, row, col, level = 1):
        [_, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write_row(row, col, ['ID', '分割数', '分割番号', 'Number of Array', 'Instance ID', 'Is Retransmission', 'Is Update', 'Path Id', 'Offset[cm]', 'Previous Instance ID'], sheet.cellFormats('header'))
        col += 10
        
        global maximumIntersectionMessageStubCount
        for i in range(maximumIntersectionMessageStubCount):
            [_, col, _] = colGroupingPrint('StubInfo(' + str(i+1) + ')', self.Stub, self.Stub.printHeader, sheet, row, col, level)
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [_, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [
            (str(self.id)),
            (self.segmentCount),
            (self.segmentIndex),
            (self.dataArrayCount),
            (self.instanceID),
            (self.isRetransmission),
            (self.isUpdate),
            (self.pathID),
            (self.offset),
            (self.previousInstanceID)])
        col += 10

        for stub in self.dataArray:
            [_, col, _] = stub.printValue(sheet, row, col)
            col += 1 #for gruop header col
            
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    

#-----------------------------------------------#
#----   ProfileMessage                      ----#
#-----------------------------------------------#
class ProfileMessage(Message, SegmentableMessage):
    laneLinkGeometryDic = {}
    laneLinkInfoDic = {}
    laneLineGeometryDic = {}
    laneLineInfoDic = {}
    hdmapGeometryDic = {}
    pathIDinfoDic = {}
    oldHdmapGeometryDic = {}
    alreadyDrawedLaneID = {}
    alreadyDrawedLaneLineID = []
    alreadyDrawedLaneGeoID = []
    
    class ProfileData:
        instanceID: int    
        isRetransmission: bool    
        isUpdate: bool    
        pathID: int    
        offset: int    
        endOffset: int    
        endOffsetFinal: bool    
        confidence: int    
        standardDeviation: int    
        laneNumber:int    
        profileType:int    
        available:int
        profileValue:ProfileType
        
        def printValue(self, sheet, row, col, level = 1):
            newRow = row
            newCol = col
            
            sheet.write_row(row, col, [
                (hex(self.instanceID)),
                (self.isRetransmission),
                (self.isUpdate),
                (self.pathID),
                (self.offset),
                (self.endOffset),
                (self.endOffsetFinal),
                (self.confidence),
                (self.standardDeviation),
                (self.laneNumber),
                (hex(self.profileType)),
                (self.available)], sheet.cellFormats('default'))
            newCol += 12
            
            if self.profileType in profileIdDic:
                if not(type(self.profileValue) == UnknownProfile):
                    profileName = profileIdDic[self.profileType]['name']
                else:
                    profileName = 'Unknown Profile (Data Broken)'
            else:
                profileName = 'Unknown Profile'
                
            groupResult = []
            if sheet.useMultiLine == True:
                [newRow, _, result] = rowGroupingPrint(
                    profileName, 
                    None, 
                    self.profileValue.printValue, 
                    sheet,
                    newRow, 
                    newCol, 
                    level)
                groupResult += result
    
                for c in range(12):
                    merge_rows(sheet, row, col + c, newRow-row)
                    
            else:
                sheet.write(newRow, newCol, profileName, sheet.cellFormats('merge'))
                newCol = newCol + 1
                
            return [newRow, col, groupResult]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    @staticmethod
    def initHDMAPdic():
        ProfileMessage.hdmapGeometryDic = {}
        ProfileMessage.oldHdmapGeometryDic = {}
    
    @staticmethod
    def readHDMAPdic(isOldHdmap, filepath, laneIDconvert):
        logger = getLogger()
        if isOldHdmap == False:
            dic = ProfileMessage.hdmapGeometryDic
        else:
            dic = ProfileMessage.oldHdmapGeometryDic
        
        expName = filepath[filepath.rfind('.')+1:]
        if expName.lower() == "geojson":
            try:
                jsonData = json.load(open(filepath))
            except:
                logger.errLog('Fail to HDMAP file open')
                return
            laneLinkIDkeyList = ['llid', 'll_id', 'ln_id']
            laneLinkIDkey = 'llid'
            for feature in jsonData['features']:
                try:
                    laneLinkID = int(feature['properties'][laneLinkIDkey])
                except:
                    for key in laneLinkIDkeyList:
                        try:
                            laneLinkIDkey = key
                            laneLinkID = int(feature['properties'][laneLinkIDkey])
                            break
                        except:
                            pass
                geometryList = feature['geometry']['coordinates']
                if not(laneLinkID in dic):
                    dic[laneLinkID] = {}
                dic[laneLinkID]['geometry'] = []
                targetGeometry = dic[laneLinkID]['geometry']
                for point in geometryList[0]:
                    if (len(point) >= 3):
                        targetGeometry.append([point[0], point[1], point[2]])
                    else:
                        targetGeometry.append([point[0], point[1], 0.0])
            logger.logPrintWithConsol('Read complete : {0} lanes'.format(len(jsonData['features'])))
        
        elif expName.lower() == "shp":
            shpReader = shapefile.Reader(filepath, encoding='UTF-8')
            for tryIndex in range(2):  # 最大2回実行
                try:
                    for shprec in shpReader.iterShapeRecords():
                        shape = shprec.shape
                        record = shprec.record
                        
                        if laneIDconvert == True:
                            laneLinkID = (record[2] << 32) + record[1]
                        else:
                            if type(record[0]) == int:
                                laneLinkID = record[0]
                            else:
                                laneLinkID = int(record[0].strip('\0'))
                        
                        if not(laneLinkID in dic):
                            dic[laneLinkID] = {}
                        dic[laneLinkID]['geometry'] = []
                        parts = list(shape.parts)
                        for p0, p1 in zip(parts, parts[1:]+[len(shape.points)]):
                            dic[laneLinkID]['geometry'] += [[point[0], point[1], 0.0] for point in shape.points[p0:p1]]
                    logger.logPrintWithConsol('Read complete : {0} lanes'.format(len(dic.keys())))
                    break
                except:
                    shpReader.shapeStructSizeMultiflier = 1 #v4400 HDMAP以降で、なぜかshpファイルのフォーマットが異なっていた。ヘッダで区別ができないため、retryをさせてみる
                    if tryIndex == 1:
                        logger.errLog('HDMAP read fail')
        else:
            logger.errLog('HDMAP read unknown file')
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.id = readFunc(int,64)
        self.classify = GlobalDataMessage.currentTransferClassify
        self.segmentCount = readFunc(int,16)
        self.segmentIndex = readFunc(int,16)
        readFunc(int,16) #reserved
        self.dataArrayCount = readFunc(int,16)
        self.dataArray = []
        self.mergeSegmentData(None, self.segmentIndex, self.segmentCount, self.data.getDataBuf()[self.data.seek():]) # 各経路別に、情報が送られるため、単に、self.idで同じものとみなしてはならない。（経路別にPathIDなどが異なる。）
        
    def parseMergedData(self, data):
        readFunc = data.readValue
        for _ in range(self.dataArrayCount):
            profileData = self.ProfileData()
            profileData.instanceID = readFunc(int,32)
            profileData.isRetransmission = readFunc(bool,32)
            profileData.isUpdate = readFunc(bool,32)
            profileData.pathID = readFunc(int,32)
            profileData.offset = readFunc(int,32)
            profileData.endOffset = readFunc(int,32)
            profileData.endOffsetFinal = readFunc(bool,32)
            profileData.confidence = readFunc(int,32)
            profileData.standardDeviation = readFunc(int,32)
            profileData.laneNumber = readFunc(int,32)
            profileData.profileType = readFunc(int,32)
            profileData.available = readFunc(int,32)
            profileData.profileValue = analyzeProfile(profileData.profileType, data, self)
            self.dataArray.append(profileData)
                
            if type(profileData.profileValue) == UnknownProfile:
                break #Cannot recognize profile data. so, read size not defined. no more read.
            elif (type(profileData.profileValue) == PROFILE_MPU_MAP_DATA_BASE_POINT): # US , JP 共通するProfile。
                #他のProfile type時にもこのpathID関連情報は格納されているが、常に送るこのtype時に、格納作業を行う。
                if profileData.offset == 0 or (not profileData.pathID in ProfileMessage.pathIDinfoDic):
                    ProfileMessage.pathIDinfoDic[profileData.pathID] = set()
                pathIDinfo = (profileData.offset, profileData.endOffset, self.id)
                if not pathIDinfo in ProfileMessage.pathIDinfoDic[profileData.pathID]:
                    ProfileMessage.pathIDinfoDic[profileData.pathID].add(pathIDinfo)
            elif (type(profileData.profileValue) == LanesGeometryProfile) or (type(profileData.profileValue) == LanesGeometryProfile_US):
                dic = ProfileMessage.laneLinkGeometryDic
                oldZ = 0
                for geometryItem in profileData.profileValue.geometyObjectArray:
                    geometryLaneID = geometryItem.laneID
                    if not(geometryLaneID in dic):
                        dic[geometryLaneID] = {}
                    dic[geometryLaneID]['geometry'] = []
                    geometryList = dic[geometryLaneID]['geometry']
                    valueArray = geometryItem.geometryPointArray
                    for value in valueArray:
                        lon = value.longitude * 360.0 / (1<<32)
                        lat = value.latitude * 360.0 / (1<<32)
                        if value.height >= 0x007FFFFF: #高さ無効値
                            z = oldZ
                        else:
                            if (type(profileData.profileValue) == LanesGeometryProfile):
                                z = value.height / 100.0 # JP cm -> m
                            else:
                                z = value.height / 1000.0 # US mm -> m
                            oldZ = z
                        geometryList.append([lon, lat, z])
            elif (type(profileData.profileValue) == PROFILETYPE_MPU_US_CURVATURE) or (type(profileData.profileValue) == PROFILETYPE_MPU_ZGM_CURVATURE):
                dic = ProfileMessage.laneLinkGeometryDic
                for geometryItem in profileData.profileValue.infoArray:
                    geometryLaneID = geometryItem.laneID
                    if not(geometryLaneID in dic):
                        dic[geometryLaneID] = {}
                    dic[geometryLaneID]['curvature'] = []
                    curvatureList = dic[geometryLaneID]['curvature']
                    valueArray = geometryItem.dataArray
                    if (type(profileData.profileValue) == PROFILETYPE_MPU_ZGM_CURVATURE):
                        for value in valueArray:
                            curvature = value.curvature / 100000000.0
                            curvatureList.append(curvature)
                    else:
                        for value in valueArray:
                            curvature = value.curvature / 10000
                            curvatureList.append(curvature)
            elif (type(profileData.profileValue) == PROFILETYPE_MPU_US_LANE_WIDTH):
                dic = ProfileMessage.laneLinkGeometryDic
                for geometryItem in profileData.profileValue.infoArray:
                    geometryLaneID = geometryItem.laneID
                    if not(geometryLaneID in dic):
                        dic[geometryLaneID] = {}
                    dic[geometryLaneID]['width'] = []
                    widthList = dic[geometryLaneID]['width']
                    valueArray = geometryItem.dataArray
                    for value in valueArray:
                        width = value.width * 0.01
                        widthList.append(width)
            elif (type(profileData.profileValue) == PROFILETYPE_MPU_US_SLOPE) or (type(profileData.profileValue) == PROFILETYPE_MPU_ZGM_SLOPE):
                dic = ProfileMessage.laneLinkGeometryDic
                for geometryItem in profileData.profileValue.infoArray:
                    geometryLaneID = geometryItem.laneID
                    if not(geometryLaneID in dic):
                        dic[geometryLaneID] = {}
                    dic[geometryLaneID]['alongSlope'] = []
                    dic[geometryLaneID]['crossSlope'] = []
                    alongSlopeList = dic[geometryLaneID]['alongSlope']
                    crossSlopeList = dic[geometryLaneID]['crossSlope']
                    valueArray = geometryItem.dataArray
                    for value in valueArray:
                        alongSlope = value.alongSlope * 0.01
                        crossSlope = value.crossSlope * 0.01
                        alongSlopeList.append(alongSlope)
                        crossSlopeList.append(crossSlope)
            elif (type(profileData.profileValue) == PROFILETYPE_MPU_ZGM_LANE_LINK_INFO) or (type(profileData.profileValue) == PROFILETYPE_MPU_US_LANE_LINK_INFO):
                dic = ProfileMessage.laneLinkInfoDic
                for infoItem in profileData.profileValue.laneInfoArray:
                    infoLaneID = infoItem.laneID
                    if (type(profileData.profileValue) == PROFILETYPE_MPU_ZGM_LANE_LINK_INFO):
                        geoDic = ProfileMessage.laneLinkGeometryDic
                        if not(infoLaneID in dic):
                            dic[infoLaneID] = {}
                        if not(infoLaneID in geoDic):
                            geoDic[infoLaneID] = {}
                        dic[infoLaneID]['maxSpeed'] = infoItem.maxSpeed
                        dic[infoLaneID]['divisionType'] = infoItem.middleGuideClass
                        dic[infoLaneID]['versionInfo'] = infoItem.versionInfo
                        dic[infoLaneID]['leftLaneID'] = infoItem.leftLaneID
                        dic[infoLaneID]['rightLaneID'] = infoItem.rightLaneID
                        geoDic[infoLaneID]['width'] = [infoItem.width * 0.01] #国内は、単一値
                    elif (type(profileData.profileValue) == PROFILETYPE_MPU_US_LANE_LINK_INFO):
                        if not(infoLaneID in dic):
                            dic[infoLaneID] = {}
                        dic[infoLaneID]['maxSpeed'] = infoItem.maxSpeed
                        dic[infoLaneID]['roadTypeStr'] = infoItem.roadTypeStr
                        dic[infoLaneID]['laneTypeStr'] = infoItem.laneTypeStr
                        dic[infoLaneID]['laneAddRemoveType'] = infoItem.laneAddRemoveType
                        dic[infoLaneID]['versionInfo'] = infoItem.versionInfo
                        dic[infoLaneID]['leftLaneID'] = infoItem.leftLaneID
                        dic[infoLaneID]['rightLaneID'] = infoItem.rightLaneID

            elif (type(profileData.profileValue) == PROFILETYPE_MPU_LINE_GEOMETRY) or (type(profileData.profileValue) == PROFILETYPE_MPU_US_LANE_LINE_GEOMETRY):
                dic = ProfileMessage.laneLineGeometryDic
                oldZ = 0
                for geometryItem in profileData.profileValue.geometyObjectArray:
                    geometrylaneLineID = geometryItem.laneLineID
                    if not(geometrylaneLineID in dic):
                        dic[geometrylaneLineID] = {}
                    dic[geometrylaneLineID]['geometry'] = []
                    geometryList = dic[geometrylaneLineID]['geometry']
                    valueArray = geometryItem.geometryPointArray
                    for value in valueArray:
                        lon = value.longitude * 360.0 / (1<<32)
                        lat = value.latitude * 360.0 / (1<<32)
                        if value.height >= 0x007FFFFF: #高さ無効値
                            z = oldZ
                        else:
                            if (type(profileData.profileValue) == PROFILETYPE_MPU_LINE_GEOMETRY):
                                z = value.height / 100.0 # JP cm -> m
                            else:
                                z = value.height / 1000.0 # US mm -> m
                            oldZ = z
                        geometryList.append([lon, lat, z])
            elif (type(profileData.profileValue) == PROFILETYPE_MPU_ZGM_LANE_DIVISION_LINE):
                dic = ProfileMessage.laneLineInfoDic
                for infoItem in profileData.profileValue.splitDataArray:
                    infoLaneLineID = infoItem.ID
                    if not(infoLaneLineID in dic):
                        dic[infoLaneLineID] = {}
                    dic[infoLaneLineID]['laneLineType'] = infoItem.classify
                    dic[infoLaneLineID]['laneLineColor'] = infoItem.classify
            elif (type(profileData.profileValue) == PROFILETYPE_MPU_US_LANE_LINE):
                dic = ProfileMessage.laneLineInfoDic
                for infoItem in profileData.profileValue.laneLineInfoArray:
                    infoLaneLineID = infoItem.targetLaneLineID
                    if not(infoLaneLineID in dic):
                        dic[infoLaneLineID] = {}
                    dic[infoLaneLineID]['laneLineType'] = infoItem.laneLineType
                    dic[infoLaneLineID]['laneLineColor'] = infoItem.laneLineColor
        
    def printHeader(self, sheet, row, col, _level = 1):
        sheet.set_row(0, 22.5)
                
        sheet.insert_button(row, 0, {'macro':   "'Collapse 3'",
                                   'caption': '<- All [+]',
                                    'width':   80,
                                    'height':  30})
        
        sheet.insert_button(row, 3, {'macro':   "'SmallFit \"A:" + getColumnName(self.commonHeader.columnCount() + 16) + "\"'",
                                    'caption': '-> 狭く表示 <-',
                                    'width':   100,
                                    'height':  30})
        
        sheet.insert_button(row, 6, {'macro':   "'AutoFit \"A:" + getColumnName(self.commonHeader.columnCount() + 16) + "\"'",
                                    'caption': '<- 広く表示 ->',
                                    'width':   100,
                                    'height':  30})
        
        [_, col, _] = self.commonHeader.printHeader(sheet, row+1, col)
        sheet.write_row(row+1, col, [
            'LaneID', 
            '分割数', 
            '分割番号', 
            'Number of Array',
            'Instance ID', 
            'Is Retransmission', 
            'Is Update', 
            'Path Id', 
            'Offset[cm]', 
            'End Offset[cm]',
            'End Offset Final',
            'Confidence[%]',
            'Standard Deviation',
            'Lane Number',
            'Profile Type',
            'Available',
            'Profile Value'], sheet.cellFormats('header'))
        col += 17
        
        sheet.freeze_panes(2, 0)
        sheet.set_row(1, 20)
        sheet.autofilter(1, 0, 1, col+5) #include profile Value
        return [row+2, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):            
        newRow = row
        newCol = col
        [_, newCol, _] = self.commonHeader.printValue(sheet, newRow, newCol)
        sheet.write_row(newRow, newCol, [
            (str(self.id)),
            (self.segmentCount),
            (self.segmentIndex),
            (self.dataArrayCount)], sheet.cellFormats('default'))
        newCol += 4
        valueLastCol = newCol
        
        if len(self.dataArray) > 0:
            if sheet.useMultiLine == True:
                for profileData in self.dataArray:
                    [newRow, _, _] = profileData.printValue(sheet, newRow, newCol)
                for c in range(col,valueLastCol):
                    merge_rows(sheet, row, c, newRow-row)
                    
            else:
                for profileData in self.dataArray:
                    [_, newCol, _] = profileData.printValue(sheet, newRow, newCol)
                newRow += 1
        else:
            newRow += 1
        
        return [newRow, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    
    class LayerType(Enum):
        Profile_Map = 80
        Profile_TSR = 81
        Profile_Sign = 82
        Profile_LaneLine = 83
        ProfileData_GeoInfo = 84
    
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.Profile_Map:
            
            if layer.fields().indexFromName('versionInf') != -1: # shp ファイルロード時に、属性名が10文字になってしまう。
                versionInfoAttrName = 'versionInf'
            else:
                versionInfoAttrName = 'versionInfo'
            
            symbolDic = {
                f'"{versionInfoAttrName}" = 0':(QtGui.QColor.fromRgb(0, 0, 0),'Old', 0.2), #最新ではない
                f'"{versionInfoAttrName}" = 1':(QtGui.QColor.fromRgb(77,107,204),'New', 0.2), #最新
                '"IVIpath" = 1 and "isIVISub" = 0':(QtGui.QColor.fromRgb(77,107,204),'Main-Path (IVI)', 0.4),
                '"IVIpath" = 1 and "isIVISub" = 1':(QtGui.QColor.fromRgb(204,107,77),'Sub-Path (IVI)', 0.4),
                '"MPUpath" = 1 and "isMPUSub" = 0':(QtGui.QColor.fromRgb(77,107,204),'Main-Path (MPU)', 0.4),
                '"MPUpath" = 1 and "isMPUSub" = 1':(QtGui.QColor.fromRgb(204,107,77),'Sub-Path (MPU)', 0.4),
                '"ADpath" = 1 and "isADSub" = 0':(QtGui.QColor.fromRgb(77,107,204),'Main-Path (AD)', 0.4),
                '"ADpath" = 1 and "isADSub" = 1':(QtGui.QColor.fromRgb(204,107,77),'Sub-Path (AD)', 0.4)}  
            
            layer = myQgsRendererRuleLayer(layer, symbolDic)
            return [layer, layerType.value]
            
        elif layerType == cls.LayerType.Profile_TSR:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(77,107,204))
            symbol.setWidth(2)
            layer.beginEditCommand( 'QGIS draw' )
            
            label_settings = QgsPalLayerSettings()
            label_settings.drawLabels = True
            label_settings.fieldName = 'SpeedLimit'
            #label_settings.placement = QgsPalLayerSettings.Horizontal
            label_settings.placement = QgsPalLayerSettings.Line
            label_settings.overrunDistance = 1000
            layer.setLabeling(QgsVectorLayerSimpleLabeling(label_settings))
            layer.setLabelsEnabled(True)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.Profile_Sign:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(217,175,48))
            symbol.setWidth(2)
            layer.beginEditCommand( 'QGIS draw' )
            
            label_settings = QgsPalLayerSettings()
            label_settings.drawLabels = True
            label_settings.fieldName = 'Sign'
            #label_settings.placement = QgsPalLayerSettings.Horizontal
            label_settings.placement = QgsPalLayerSettings.Line
            label_settings.overrunDistance = 1000
            layer.setLabeling(QgsVectorLayerSimpleLabeling(label_settings))
            layer.setLabelsEnabled(True)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.ProfileData_GeoInfo:
            symbolDic = {
                '"width[m]" < 3':(QtGui.QColor.fromRgb(230,20,20),'Width under 3m', 4.0),
                '"width[m]" >= 3':(QtGui.QColor.fromRgb(30, 250, 30),'Width over 3m', 2.0)}            
            layer = myQgsRendererRuleLayer(layer, symbolDic)
#             symbollist = layer.renderer().symbols(QgsRenderContext())
#             symbol = symbollist[0]
#             symbol.setColor(QtGui.QColor.fromRgb(253, 111, 229))
#             layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.Profile_LaneLine:
            symbolDic = {
                0:(QtGui.QColor.fromRgb(0,0,0),'0: No Color', 0.2),
                1:(QtGui.QColor.fromRgb(255,255,255),'1: White', 0.2),
                2:(QtGui.QColor.fromRgb(255,255,255),'2: White (thin)', 0.1),
                3:(QtGui.QColor.fromRgb(255,255,255),'3: White (thick)', 0.4),
                4:(QtGui.QColor.fromRgb(255,255,0),'4: Yellow', 0.2),
                11:(QtGui.QColor.fromRgb(255,255,255),'11: White/White', 0.2),
                22:(QtGui.QColor.fromRgb(255,255,255),'22: White/White (thin)', 0.1),
                44:(QtGui.QColor.fromRgb(255,255,0),'22: Yellow/Yellow', 0.2),
                12:(QtGui.QColor.fromRgb(255,255,255),'12: White/White(thin)', 0.2),
                21:(QtGui.QColor.fromRgb(255,255,255),'21: White(thin)/White', 0.2),
                14:(QtGui.QColor.fromRgb(255,255,0),'14: White/Yellow', 0.2),
                41:(QtGui.QColor.fromRgb(255,255,0),'41: Yellow/White', 0.2),
                24:(QtGui.QColor.fromRgb(255,255,0),'14: White(thin)/Yellow', 0.2),
                42:(QtGui.QColor.fromRgb(255,255,0),'41: Yellow/White(thin)', 0.2),
                414:(QtGui.QColor.fromRgb(255,255,0),'414: Yellow/White/Yellow', 0.2),
                424:(QtGui.QColor.fromRgb(255,255,0),'424: Yellow/White(thin)/Yellow', 0.2),
                144:(QtGui.QColor.fromRgb(255,255,0),'144: White/Yellow/Yellow', 0.2),
                441:(QtGui.QColor.fromRgb(255,255,0),'441: Yellow/Yellow/White', 0.2),
                4114:(QtGui.QColor.fromRgb(255,255,0),'4114: Yellow/White/White/Yellow', 0.2),
                5:(QtGui.QColor.fromRgb(0,200,200),'5: Other', 0.2)}
            layer = myQgsRendererCategoryLayer(layer, symbolDic, 'lineColor')
            return [layer, layerType.value]
        
        else:
            return None
                    
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if realTimeMode == DrawMode.FullDraw:
            newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=ln_id:string&field=speed(km/h):int&field=versionInfo:int&field=roadType:string&field=laneType:string&field=laneAddRemoveType:string&field=divisionType:int&field=IVIpath:int&field=isIVISub&field=IVIPathID:string&field=IVIPathOffset:int&field=MPUpath:int&field=isMPUSub&field=MPUPathID:string&field=MPUPathOffset:int&field=ADpath:int&field=isADSub&field=ADPathID:string&field=ADPathOffset:int&index=yes',name,'memory')
            newLayer = self.SetLayerStyle(self.LayerType.Profile_Map, newLayer)
        elif realTimeMode == DrawMode.QGIS_RealTimeDraw:
            newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612',name,'memory')
            newLayer = self.SetLayerStyle(self.LayerType.Profile_Map, newLayer)
        
        # リアルタイム描画でない場合のみ、標識を描画する。
        if realTimeMode == DrawMode.FullDraw:
            newLayer_TSR = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Sign:string&field=SpeedLimit:string&field=Longitude:double&field=Latitude:double&index=yes',name + '(TSR)','memory')
            newLayer_TSR = self.SetLayerStyle(self.LayerType.Profile_TSR, newLayer_TSR)
            
            newLayer_Sign = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Sign:string&field=SpeedLimit:string&field=Longitude:double&field=Latitude:double&index=yes',name + '(Sign)','memory')
            newLayer_Sign = self.SetLayerStyle(self.LayerType.Profile_Sign, newLayer_Sign)
            
            newLayer_GeoInfo = iface_obj.addVectorLayer('Point?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&field=height[m]:double&field=curvature[1/m]:double&field=width[m]:double&field=alongSlope[deg]:double&field=crossSlope[deg]:double&index=yes',name + '(GeoInfo)','memory')
            newLayer_GeoInfo = self.SetLayerStyle(self.LayerType.ProfileData_GeoInfo, newLayer_GeoInfo)
            
        if realTimeMode == DrawMode.FullDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw:
            newLayer_LaneLine = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=lineId:string&field=lineType:string&field=lineColor:int&index=yes',name + '(LaneLine)','memory')
            newLayer_LaneLine = self.SetLayerStyle(self.LayerType.Profile_LaneLine, newLayer_LaneLine)
        
        if realTimeMode == DrawMode.FullDraw:
            return [newLayer, newLayer_TSR, newLayer_Sign, newLayer_LaneLine, newLayer_GeoInfo]
        elif realTimeMode == DrawMode.QGIS_RealTimeDraw:
            return [newLayer]
        elif realTimeMode == DrawMode.OpenGL_RealTimeDraw:
            return [newLayer_LaneLine]
        
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        for layerListItem in layerList:
            if layerListItem[1] == ProfileMessage.LayerType.Profile_Map.value:
                layer = layerListItem[0]
            elif layerListItem[1] == ProfileMessage.LayerType.Profile_TSR.value:
                layer_TSR = layerListItem[0]
            elif layerListItem[1] == ProfileMessage.LayerType.Profile_Sign.value:
                layer_Sign = layerListItem[0]
            elif layerListItem[1] == ProfileMessage.LayerType.Profile_LaneLine.value:
                layer_LaneLine = layerListItem[0]
            elif layerListItem[1] == ProfileMessage.LayerType.ProfileData_GeoInfo.value:
                layer_GeoInfo = layerListItem[0]
        
        if len(self.dataArray) > 0:
            for profileData in self.dataArray:
                if (type(profileData.profileValue) == LanesGeometryProfile) or (type(profileData.profileValue) == LanesGeometryProfile_US):
                    if realTimeMode == DrawMode.FullDraw or realTimeMode == DrawMode.QGIS_RealTimeDraw:
                        featureList = []
                        geometryList = profileData.profileValue.geometyObjectArray
                        dic = ProfileMessage.laneLinkGeometryDic
                        infoDic = ProfileMessage.laneLinkInfoDic
                        for laneGeometry in geometryList:
                            geometryLaneID = laneGeometry.laneID
                            if ((realTimeMode == DrawMode.QGIS_RealTimeDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw)) and (geometryLaneID in ProfileMessage.alreadyDrawedLaneID):
                                #realTime描画時は、既に描画した経路地図は描画しないようにし描画速度を上げる
                                continue
                            if geometryLaneID in dic:
                                pathID = profileData.pathID
                                pathOffset = profileData.offset
                                if pathID in PathControlMessage.MainPathIDlist: isSub = 0
                                elif pathID in PathControlMessage.SubPathIDlist: isSub = 1
                                else: isSub = -1
                                if self.classify == 3: # IVI
                                    classifyAttributeIndex = 8
                                elif self.classify == 4: # MPU
                                    classifyAttributeIndex = 12
                                elif self.classify == 5: # AD  
                                    classifyAttributeIndex = 16
                                else:
                                    classifyAttributeIndex = None
                                
#                                 if geometryLaneID in ProfileMessage.alreadyDrawedLaneID:
#                                     # 既に描画したProfile。classifyによる、属性のみを変更する
#                                     if realTimeMode == DrawMode.FullDraw and classifyAttributeIndex != None:
#                                         feature = ProfileMessage.alreadyDrawedLaneID[geometryLaneID]
#                                         layer.changeAttributeValues({
#                                             feature.id(): {
#                                                 classifyAttributeIndex: 1,
#                                                 classifyAttributeIndex+1: isSub,
#                                                 classifyAttributeIndex+2: hex(pathID),
#                                                 classifyAttributeIndex+3: pathOffset,
#                                             }
#                                         })
#                                 else:
                                feature = QgsFeature()
                                geometryPointList = dic[geometryLaneID]['geometry']
                                feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(point[0], point[1], point[2]) for point in geometryPointList]))
                                if realTimeMode == DrawMode.FullDraw:
                                    if geometryLaneID in infoDic:
                                        info = infoDic[geometryLaneID]
                                    else:
                                        info = {}
                                    attr = [QDateTime(self.commonHeader.logTime), str(geometryLaneID),
                                           info.get('maxSpeed', 0), info.get('versionInfo', 1), 
                                           info.get('roadTypeStr', '-'), info.get('laneTypeStr', '-'),  
                                           PROFILETYPE_MPU_US_LANE_LINK_INFO.laneAddRemoveTypeString.get(info.get('laneAddRemoveType', -1), '-'),
                                           info.get('divisionType', 0),
                                           0, 0, "-", 0, # IVI
                                           0, 0, "-", 0, # MPU
                                           0, 0, "-", 0, # AD
                                           ]
                                    if classifyAttributeIndex != None:
                                        attr[classifyAttributeIndex] = 1
                                        attr[classifyAttributeIndex+1] = isSub
                                        attr[classifyAttributeIndex+2] = hex(pathID)
                                        attr[classifyAttributeIndex+3] = pathOffset
                                    feature.setAttributes(attr)
                                featureList.append(feature)
                                ProfileMessage.alreadyDrawedLaneID[geometryLaneID] = feature
                                
                        layer.dataProvider().addFeatures( featureList )
                    
                    if realTimeMode == DrawMode.FullDraw and (type(profileData.profileValue) == LanesGeometryProfile_US or type(profileData.profileValue) == LanesGeometryProfile):
                        featureList = []
                        geometryList = profileData.profileValue.geometyObjectArray
                        dic = ProfileMessage.laneLinkGeometryDic
                        for laneGeometry in geometryList:
                            geometryLaneID = laneGeometry.laneID
                            if ((realTimeMode == DrawMode.QGIS_RealTimeDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw)) and (geometryLaneID in ProfileMessage.alreadyDrawedLaneGeoID):
                                #realTime描画時は、既に描画した経路地図は描画しないようにし描画速度を上げる
                                continue
                            if geometryLaneID in dic:
                                geometryPointList = dic[geometryLaneID]['geometry']
                                geometryCurvatureList = dic[geometryLaneID].get('curvature', [-1])
                                if len(geometryCurvatureList) == 0: geometryCurvatureList = [-1]
                                geometryWidthList = dic[geometryLaneID].get('width', [-1])
                                if len(geometryWidthList) == 0: geometryWidthList = [-1]
                                geometryAlongSlopeList = dic[geometryLaneID].get('alongSlope', [-1])
                                if len(geometryAlongSlopeList) == 0: geometryAlongSlopeList = [-1]
                                geometryCrossSlopeList = dic[geometryLaneID].get('crossSlope', [-1])
                                if len(geometryCrossSlopeList) == 0: geometryCrossSlopeList = [-1]
                                for i in range(len(geometryPointList)):
                                    feature = QgsFeature()
                                    point = geometryPointList[i]
                                    feature.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(point[0], point[1])))
                                    feature.setAttributes([QDateTime(self.commonHeader.logTime), point[0], point[1], point[2],
                                                           geometryCurvatureList[i] if i < len(geometryCurvatureList) else geometryCurvatureList[-1],
                                                           geometryWidthList[i] if i < len(geometryWidthList) else geometryWidthList[-1],
                                                           geometryAlongSlopeList[i] if i < len(geometryAlongSlopeList) else geometryAlongSlopeList[-1],
                                                           geometryCrossSlopeList[i] if i < len(geometryCrossSlopeList) else geometryCrossSlopeList[-1]])
                                    featureList.append(feature)
                                    ProfileMessage.alreadyDrawedLaneGeoID.append(geometryLaneID)
                        layer_GeoInfo.dataProvider().addFeatures( featureList )
                
                if (type(profileData.profileValue) == PROFILETYPE_MPU_LINE_GEOMETRY) or (type(profileData.profileValue) == PROFILETYPE_MPU_US_LANE_LINE_GEOMETRY):
                    if realTimeMode == DrawMode.FullDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw:
                        featureList = []
                        geometryList = profileData.profileValue.geometyObjectArray
                        dic = ProfileMessage.laneLineGeometryDic
                        infoDic = ProfileMessage.laneLineInfoDic
                        for lineGeometry in geometryList:
                            geometryLineID = lineGeometry.laneLineID
                            if ((realTimeMode == DrawMode.QGIS_RealTimeDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw)) and (geometryLineID in ProfileMessage.alreadyDrawedLaneLineID):
                                #realTime描画時は、既に描画した経路地図は描画しないようにし描画速度を上げる
                                continue
                            if geometryLineID in dic:
                                geometryPointList = dic[geometryLineID]['geometry']
                                feature = QgsFeature()
                                feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(point[0], point[1], point[2]) for point in geometryPointList]))
                                if geometryLineID in infoDic:
                                    info = infoDic[geometryLineID]
                                    if (type(profileData.profileValue) == PROFILETYPE_MPU_US_LANE_LINE_GEOMETRY): #US
                                        colorIndex = info.get('laneLineColor', 0)
                                        if colorIndex == 0: colorIndex = 0
                                        elif colorIndex == 1: colorIndex = 1
                                        elif colorIndex == 2: colorIndex = 4
                                        elif colorIndex == 3: colorIndex = 144
                                        elif colorIndex == 4: colorIndex = 441
                                        elif colorIndex == 5: colorIndex = 5
                                        feature.setAttributes([QDateTime(self.commonHeader.logTime), str(geometryLineID), 
                                                               PROFILETYPE_MPU_US_LANE_LINE.LaneLineTypeDic.get(info.get('laneLineType', -1), '-'), colorIndex])
                                    else: #JP
                                        feature.setAttributes([QDateTime(self.commonHeader.logTime), str(geometryLineID), 
                                                               PROFILETYPE_MPU_ZGM_LANE_DIVISION_LINE.LaneLineTypeDic.get(info.get('laneLineType', -1), '-'), info.get('laneLineColor', 0)])
                                else:
                                    feature.setAttributes([QDateTime(self.commonHeader.logTime), str(geometryLineID), 
                                                           '-', 0])
                                featureList.append(feature)
                                ProfileMessage.alreadyDrawedLaneLineID.append(geometryLineID)
                        layer_LaneLine.dataProvider().addFeatures( featureList )
                    
                if (type(profileData.profileValue) == PROFILETYPE_MPU_ZGM_SIGN_INFO): #国内標識
                    if realTimeMode == DrawMode.FullDraw:    
                        for signItem in profileData.profileValue.signDataArray:
                            # 電光標識は、maximumVelocityが０で来るため、描画必要。
                            #if signItem.maximumVelocity == 0: # or signItem.ID in ProfileMessage.alreadyDrawedSignInfoID:
                            #    continue
                            
                            lat1 = signItem.point1Latitude * 360.0 / (1<<32)
                            lon1 = signItem.point1Longitude * 360.0 / (1<<32)                           
                            lat2 = signItem.point2Latitude * 360.0 / (1<<32)
                            lon2 = signItem.point2Longitude * 360.0 / (1<<32)
                            if checkInvalidLonLat(lon1, lat1, lon2, lat2, allowSamePoint = True) == False:
                                continue
    
                            #ProfileMessage.alreadyDrawedSignInfoID.append(signItem.ID)
                            feature = QgsFeature()
                            feature.setGeometry(QgsGeometry.fromPolyline(
                                [QgsPoint(lon1, lat1), QgsPoint(lon2, lat2)] ))
                            if signItem.classifyInfo == 0xC5031700:
                                speedStr = f'{signItem.maximumVelocity}km/h' if signItem.maximumVelocity > 0 else "Variable"
                            elif signItem.classifyInfo == 0xC5031800:
                                speedStr = f'minimum {signItem.maximumVelocity}km/h' if signItem.maximumVelocity > 0 else "Variable"
                            else:
                                speedStr = '-'
                            feature.setAttributes([QDateTime(self.commonHeader.logTime), 
                                                   PROFILETYPE_MPU_ZGM_SIGN_INFO.ClassifyInfoDic.get(signItem.classifyInfo, 'Unknown'), 
                                                   speedStr,
                                                   lon1, lat1])
                            
                            if signItem.classifyInfo == 0xC5031700 or signItem.classifyInfo == 0xC5031800:
                                layer_TSR.dataProvider().addFeatures( [feature] )
                            else:
                                layer_Sign.dataProvider().addFeatures( [feature] )
                        
                if (type(profileData.profileValue) == PROFILETYPE_MPU_US_SIGN): #北米標識
                    pass
            
#-----------------------------------------------#
#----   GlobalDataMessage                   ----#
#-----------------------------------------------#
class GlobalDataMessage(Message, SegmentableMessage):
    laneLinkGeometryDic = {}
    currentTransferClassify = 0
    
    class ProfileData:
        instanceID: int    
        behaviorType: int    
        dataType: int    
        profileType:int    
        profileValue:ProfileType
        
        def printValue(self, sheet, row, col, level = 1):
            newRow = row
            newCol = col
            
            sheet.write_row(row, col, [
                (hex(self.instanceID)),
                (hex(self.behaviorType)),
                (hex(self.dataType)),
                (hex(self.profileType))], sheet.cellFormats('default'))
            newCol += 4
            
            if self.profileType in profileIdDic:
                profileName = profileIdDic[self.profileType]['name']
            else:
                profileName = 'Unknown Profile'
                
            groupResult = []
            if sheet.useMultiLine == True:
                [newRow, _, result] = rowGroupingPrint(
                    profileName, 
                    None, 
                    self.profileValue.printValue, 
                    sheet,
                    newRow, 
                    newCol, 
                    level)
                groupResult += result
    
                for c in range(4):
                    merge_rows(sheet, row, col + c, newRow-row)
                    
            elif type(self.profileValue) == PROFILE_MPU_MAP_DATA_TRANSFER_STS:
                sheet.write(newRow, newCol, profileName, sheet.cellFormats('merge'))
                [_, newCol, groupResult] = self.profileValue.printValue(sheet, newRow, newCol + 1, level + 1)
                newCol = newCol + 2
                
            else:
                sheet.write(newRow, newCol, profileName, sheet.cellFormats('merge'))
                newCol = newCol + 1
                
            return [newRow, newCol, groupResult]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.id = readFunc(int,64)
        self.segmentCount = readFunc(int,16)
        self.segmentIndex = readFunc(int,16)
        readFunc(int,16) #reserved
        self.dataArrayCount = readFunc(int,16)
        self.dataArray = []
        self.mergeSegmentData(self.id, self.segmentIndex, self.segmentCount, self.data.getDataBuf()[self.data.seek():])
    
    def parseMergedData(self, data):
        readFunc = data.readValue
        for _ in range(self.dataArrayCount):
            profileData = self.ProfileData()
            profileData.instanceID = readFunc(int,32)
            profileData.behaviorType = readFunc(int,32)
            profileData.dataType = readFunc(int,32)
            profileData.profileType = readFunc(int,32)
            profileData.profileValue = analyzeProfile(profileData.profileType, data, self)
            self.dataArray.append(profileData)
            if type(profileData.profileValue) == UnknownProfile:
                break #Cannot recognize profile data. so, read size not defined. no more read.
            elif type(profileData.profileValue) == PROFILE_MPU_MAP_DATA_TRANSFER_STS: # JP/US共通
                logger = getLogger()
                if profileData.profileValue.startEndflag == 1:
                    logger.debugLog(f'<GlobalDataMessage PROFILE_MPU_MAP_DATA_TRANSFER_STS> line = {self.commonHeader.logIndex} , type = {profileData.profileValue.classify} start')
                    GlobalDataMessage.currentTransferClassify = profileData.profileValue.classify
                else:
                    GlobalDataMessage.currentTransferClassify = 0
                    logger.debugLog(f'<GlobalDataMessage PROFILE_MPU_MAP_DATA_TRANSFER_STS> line = {self.commonHeader.logIndex} , type = {profileData.profileValue.classify} start')
            elif (type(profileData.profileValue) == LanesGeometryProfile) or (type(profileData.profileValue) == LanesGeometryProfile_US): #周辺地図は、GlobalMessageとして、Geometry形状が送られる。
                dic = GlobalDataMessage.laneLinkGeometryDic
                oldZ = 0
                for geometryItem in profileData.profileValue.geometyObjectArray:
                    geometryLaneID = geometryItem.laneID
                    if not(geometryLaneID in dic):
                        dic[geometryLaneID] = {}
                        dic[geometryLaneID]['geometry'] = []
                        geometryList = dic[geometryLaneID]['geometry']
                        valueArray = geometryItem.geometryPointArray
                        for i in range(len(valueArray)):
                            value = valueArray[i]
                            lon = value.longitude * 360.0 / (1<<32)
                            lat = value.latitude * 360.0 / (1<<32)
                            if value.height >= 0x007FFFFF: #高さ無効値
                                z = oldZ
                            else:
                                if (type(profileData.profileValue) == LanesGeometryProfile):
                                    z = value.height / 100.0 # JP cm -> m
                                else:
                                    z = value.height / 1000.0 # US mm -> m
                                oldZ = z
                            if i == 0:
                                oldLon = None
                                oldLat = None
                            if checkInvalidLonLat(lon, lat, oldLon, oldLat) == False:
                                continue
                            geometryList.append([lon, lat, z])
                            oldLon = lon
                            oldLat = lat
                            
    def printHeader(self, sheet, row, col, _level = 1):
        sheet.set_row(0, 22.5)
                
        sheet.insert_button(row, 0, {'macro':   "'Collapse 3'",
                                   'caption': '<- All [+]',
                                    'width':   80,
                                    'height':  30})
        
        sheet.insert_button(row, 3, {'macro':   "'SmallFit \"A:" + getColumnName(self.commonHeader.columnCount() + 8) + "\"'",
                                    'caption': '-> 狭く表示 <-',
                                    'width':   100,
                                    'height':  30})
        
        sheet.insert_button(row, 6, {'macro':   "'AutoFit \"A:" + getColumnName(self.commonHeader.columnCount() + 8) + "\"'",
                                    'caption': '<- 広く表示 ->',
                                    'width':   100,
                                    'height':  30})
        
        [_, col, _] = self.commonHeader.printHeader(sheet, row+1, col)
        sheet.write_row(row+1, col, [
            'LaneID', 
            '分割数', 
            '分割番号', 
            'Number of Array',
            'Instance ID', 
            'Behavior Type', 
            'Data Type', 
            'Profile Type',
            'Profile Value'], sheet.cellFormats('header'))
        col += 9
        
        sheet.freeze_panes(2, 0)
        sheet.set_row(1, 20)
        sheet.autofilter(1, 0, 1, col+5) #include profile Value
        return [row+2, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        newRow = row
        newCol = col
        [_, newCol, _] = self.commonHeader.printValue(sheet, newRow, newCol)
        sheet.write_row(newRow, newCol, [
            (str(self.id)),
            (self.segmentCount),
            (self.segmentIndex),
            (self.dataArrayCount)], sheet.cellFormats('default'))
        newCol += 4
        valueLastCol = newCol
        
        if len(self.dataArray) > 0:
            if sheet.useMultiLine == True:
                for profileData in self.dataArray:
                    [newRow, _, _] = profileData.printValue(sheet, newRow, newCol)
                for c in range(col,valueLastCol):
                    merge_rows(sheet, row, c, newRow-row)
            
            else:
                for profileData in self.dataArray:
                    [_, newCol, _] = profileData.printValue(sheet, newRow, newCol)
                newRow += 1
                
        else:
            newRow += 1
        
        return [newRow, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    
    class LayerType(Enum):
        GlobalData_AroundMap = 89
    
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.GlobalData_AroundMap:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(243,166,178))
            symbol.setWidth(1.0)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
        
        else:
            return None
                
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if realTimeMode == DrawMode.FullDraw:
            newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=ln_id:string&index=yes',name,'memory')
        else:
            newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612',name,'memory')
        newLayer = self.SetLayerStyle(self.LayerType.GlobalData_AroundMap, newLayer)
        
        return [newLayer]
        
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        for layerListItem in layerList:
            if layerListItem[1] == GlobalDataMessage.LayerType.GlobalData_AroundMap.value:
                layer = layerListItem[0]

        if len(self.dataArray) > 0:
            for profileData in self.dataArray:
                if (type(profileData.profileValue) == LanesGeometryProfile) or (type(profileData.profileValue) == LanesGeometryProfile_US):
                    featureList = []
                    geometryList = profileData.profileValue.geometyObjectArray
                    dic = GlobalDataMessage.laneLinkGeometryDic
                    for laneGeometry in geometryList:
                        geometryLaneID = laneGeometry.laneID
                        if geometryLaneID in dic:
                            geometryPointList = dic[geometryLaneID]['geometry']
                            feature = QgsFeature()
                            feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(point[0], point[1]) for point in geometryPointList]))
                            if realTimeMode == DrawMode.FullDraw:
                                feature.setAttributes([QDateTime(self.commonHeader.logTime), str(geometryLaneID)])
                            featureList.append(feature)
                    layer.dataProvider().addFeatures( featureList )
                    break
    

#-----------------------------------------------#
#----   RecommendLaneMessage              ----#
#-----------------------------------------------#
class RecommendLaneMessage(Message, SegmentableMessage):
    SDLinkageStatusDic = {0x0000:'有効', 0x8000:'無効'}
    RouteTypeDic = {0:'0:初期値', 1:'1:IVI変換経路', 2:'2:MPU独自経路', 3:'3:ADECU経路'}
    RouteConversion_matchResultDic = {0:'0:不明', 1:'1:整合', 2:'2:不整合（IVI多い）', 3:'3:不整合（HDMAP多い）'}
    RouteConversion_iviResultDic = {0:'0:不明', 1:'1:IVI分岐', 2:'2:IVI合流', 3:'3:IVI直進（HD地図のみ分岐、または、合流）'}
    RouteConversion_dummyLinkDic = {0:'0:不明', 1:'1:通常（ダミーリンク以外）', 2:'2:ダミーリンク'}
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        ethernetSpecVersion = getEthernetSpecVer()
        self.dataArray = []
        if ethernetSpecVersion >= datetime(2020, 9, 4):
            self.segmentCount = readFunc(int,16)
            self.segmentIndex = readFunc(int,16)                
            self.routeType = readFunc(int,16, True) # 推奨レーンメッセージの場合は、レーンリンク情報の配列の途中では分割せず、複数要素固まり毎に送信。
            self.dataArrayCount = readFunc(int,16) # 推奨レーンメッセージの場合は、レーンリンク情報の配列の途中では分割せず、複数要素固まり毎に送信。
            self.laneLinkCount = self.segmentCount
            self.laneLinkIndex = self.segmentIndex
            for _ in range(self.dataArrayCount):
                laneLinkInfo = self.readLaneLinkInfo()
                laneLinkInfo.logTime = self.commonHeader.logTime
                self.dataArray.append(laneLinkInfo)
            self.mergeSegmentData(None, self.segmentIndex, self.segmentCount, b'') #データフォーマット確認のため、無効なデータで、segmentマージチェックのみ行ってみる。
        else:
            self.laneLinkCount = readFunc(int,16)
            self.laneLinkIndex = readFunc(int,16)
            self.segmentCount = self.laneLinkCount 
            self.segmentIndex = self.laneLinkIndex 
            self.routeType = readFunc(int,16, True)
            self.dataArrayCount = readFunc(int,16)
            #前の仕様は一個ずつ送っていた。
            laneLinkInfo = self.readLaneLinkInfo()
            laneLinkInfo.logTime = self.commonHeader.logTime
            self.dataArray.append(laneLinkInfo)
        self.assertMessageSize()
            
    def parseMergedData(self, data):
        # 最新仕様では、各Segmentメッセージ毎に一部の推奨レーンデータが入っているので、各データの中で処理する。
        pass
    
    class LayerType(Enum):
        RouteConversionStatus = 85
        RecommendLaned = 90
        ActionFlag = 200
    
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.RecommendLaned:
            symbolDic = {
                11:(QtGui.QColor.fromRgb(210,210,210),'IVI_sub(oldMap)'),
                12:(QtGui.QColor.fromRgb(200,200,200),'IVI_low(oldMap)'),
                13:(QtGui.QColor.fromRgb(50,50,50),'IVI_high(oldMap)'),
                16:(QtGui.QColor.fromRgb(177,228,188),'IVI_sub'),
                17:(QtGui.QColor.fromRgb(167,218,178),'IVI_low'),
                18:(QtGui.QColor.fromRgb(11,234,0),'IVI_high'),
                21:(QtGui.QColor.fromRgb(210,210,210),'MPU_sub(oldMap)'),
                22:(QtGui.QColor.fromRgb(200,200,200),'MPU_low(oldMap)'),
                23:(QtGui.QColor.fromRgb(50,50,50),'MPU_high(oldMap)'),
                26:(QtGui.QColor.fromRgb(228,177,188),'MPU_sub'),
                27:(QtGui.QColor.fromRgb(218,167,178),'MPU_low'),
                28:(QtGui.QColor.fromRgb(241,78,78),'MPU_high'),
                31:(QtGui.QColor.fromRgb(210,210,210),'AD_sub(oldMap)'),
                32:(QtGui.QColor.fromRgb(200,200,200),'AD_low(oldMap)'),
                33:(QtGui.QColor.fromRgb(50,50,50),'AD_high(oldMap)'),
                36:(QtGui.QColor.fromRgb(194,194,162),'AD_sub'),
                37:(QtGui.QColor.fromRgb(184,184,152),'AD_low'),
                38:(QtGui.QColor.fromRgb(234,234,0),'AD_high')
            }
            # = {0:'0:初期値', 1:'1:IVI変換経路', 2:'2:MPU独自経路', 3:'3:ADECU経路'}
            categories = []
            for order, (color, label) in symbolDic.items():
                sym = QgsSymbol.defaultSymbol(layer.geometryType())
                sym.setColor(color)
                sym.setWidth(1.2)
                category = QgsRendererCategory(order, sym, label)
                category.setRenderState(True)
                categories.append(category)
            layer.setRenderer(QgsCategorizedSymbolRenderer('group*10+order+(VerCheck*VerStat)*5', categories))
            layer.beginEditCommand( 'QGIS draw' )
            RecommendLaneMessage.RendererCategories = [
                [], #for type 0
                [categories[0], categories[1], categories[2], categories[3], categories[4], categories[5]],
                [categories[6], categories[7], categories[8], categories[9], categories[10], categories[11]],
                [categories[12], categories[13], categories[14], categories[15], categories[16], categories[17]]
            ]
            
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.ActionFlag:
            symbolDic = {
                1:(QtGui.QColor.fromRgb(150,150,150),'Camera Unstable'),
                
                11:(QtGui.QColor.fromRgb(203,37,215),'(AF) L/C prohibit'),
                12:(QtGui.QColor.fromRgb(0,128,0),'(AF) AD2 prohibit'),
                13:(QtGui.QColor.fromRgb(0,0,0),'(AF) Reserve'),
                
                21:(QtGui.QColor.fromRgb(0,0,200),'(shp) Exit prohibit'),
                22:(QtGui.QColor.fromRgb(103,37,115),'(shp) L/C prohibit'),
                23:(QtGui.QColor.fromRgb(100,228,27),'(shp) Hands Off (high) prohibit'),
                24:(QtGui.QColor.fromRgb(72,228,27),'(shp) Hands Off prohibit'),
                25:(QtGui.QColor.fromRgb(183,176,41),'(shp) LK (HDMAP) prohibit'),
                26:(QtGui.QColor.fromRgb(183,176,41),'(shp) LK prohibit'),
                27:(QtGui.QColor.fromRgb(0,0,0),'(shp) Reserve'),
                
                31:(QtGui.QColor.fromRgb(0,0,200),'(SW) Exit prohibit'),
                32:(QtGui.QColor.fromRgb(203,37,215),'(SW) L/C prohibit'),
                33:(QtGui.QColor.fromRgb(100,248,52),'(SW) Hands Off prohibit'),
                34:(QtGui.QColor.fromRgb(183,176,41),'(SW) LK (HDMAP) prohibit'),
                35:(QtGui.QColor.fromRgb(183,176,41),'(SW) LK prohibit'),
                36:(QtGui.QColor.fromRgb(0,0,0),'(SW) Reserve'),
                37:(QtGui.QColor.fromRgb(0,0,0),'(SW) Reserve'),
                
                255:(QtGui.QColor.fromRgb(255,20,20),'(MAP) Maintenance when measuring')}
            layer = myQgsRendererCategoryLayer(layer, symbolDic, 'category', width = 12.0, alpha = 0.5)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.RouteConversionStatus:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(105,2,157))
            symbol.setWidth(1.2)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
        
        else:
            return None
            
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if realTimeMode == DrawMode.FullDraw:
            newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=ln_id:string&field=group:int&field=order:int&field=VerCheck:int&field=VerStat:int&field=isDummylink:int&field=PoCRflag:int&field=frontLaneCount:int&field=speedLimit[kmh]:int&index=yes',name,'memory')
        else:
            newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=group:int&field=order:int&field=VerCheck:int&field=VerStat:int',name,'memory')
        newLayer = self.SetLayerStyle(self.LayerType.RecommendLaned, newLayer)
        
        if realTimeMode == DrawMode.FullDraw:
            newLayer_routeConversionStatus = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=ln_id:string&field=value:int&field=matchResult:string&field=iviResult:string&field=duringPathCreate:int&field=dummyLink:string&field=hdmapLane:int&field=iviLane:int&index=yes',name+'(routeConversionStatus)','memory')
            newLayer_routeConversionStatus = self.SetLayerStyle(self.LayerType.RouteConversionStatus, newLayer_routeConversionStatus)
        
        if realTimeMode == DrawMode.FullDraw:
            newLayer_actionFlag = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&field=value(dec):int&field=startDate:string&field=startTime:string&index=yes',name+'(ActionFlag)','memory')
        else:
            newLayer_actionFlag = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=category:int',name+'(ActionFlag)','memory')
        newLayer_actionFlag = self.SetLayerStyle(self.LayerType.ActionFlag, newLayer_actionFlag)
        
        RecommendLaneMessage.showedDataArray = [[],[],[],[]]
        RecommendLaneMessage.lastShowTime = datetime.now()
        RecommendLaneMessage.currentShowedRouteType = 1
        RecommendLaneMessage.showedActionFlagLaneID = []
        
        if realTimeMode == DrawMode.FullDraw:
            return [newLayer, newLayer_actionFlag, newLayer_routeConversionStatus]
        else:
            return [newLayer, newLayer_actionFlag]
         
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        layer = None
        layer_actionFlag = None
        layer_routeConversionStatus = None
        for layerListItem in layerList:
            if layerListItem[1] == RecommendLaneMessage.LayerType.RecommendLaned.value:
                layer = layerListItem[0]
            if layerListItem[1] == RecommendLaneMessage.LayerType.ActionFlag.value:
                layer_actionFlag = layerListItem[0]
            if layerListItem[1] == RecommendLaneMessage.LayerType.RouteConversionStatus.value:
                layer_routeConversionStatus = layerListItem[0]
                
        viewerClear = getRecommandLaneViewerClear()
        showedType = RecommendLaneMessage.currentShowedRouteType
        showedTime = RecommendLaneMessage.lastShowTime
        recommendedLaneShowTarget = getRecommendedLaneShowTarget()
        if (datetime.now()-showedTime).total_seconds() > 3.0:
            if recommendedLaneShowTarget == 'IVI':
                showedType = 1
            elif recommendedLaneShowTarget == 'MPU':
                showedType = 2
            elif recommendedLaneShowTarget == 'AD':
                showedType = 3
            else:
                showedType += 1
                if showedType >= len(RecommendLaneMessage.RouteTypeDic):
                    showedType = 1
            RecommendLaneMessage.currentShowedRouteType = showedType
            RecommendLaneMessage.lastShowTime = datetime.now()
                
            if viewerClear == True:
                # layer clear before draw。　毎回、出力分だけ、再描画。どうせ全部消すので、表示切替は不要
                listOfIds = [feat.id() for feat in layer.getFeatures()]
                layer.dataProvider().deleteFeatures( listOfIds )
                RecommendLaneMessage.drawTargetDataArray(self, layer, layer_routeConversionStatus, showedType, RecommendLaneMessage.showedDataArray[showedType], realTimeMode)
            else:
                #全描画を残す設定。表示切替必要。
                categories = []
                for typeIndex in range(len(RecommendLaneMessage.RouteTypeDic)): #routeType loop
                    target_Render = RecommendLaneMessage.RendererCategories[typeIndex]
                    for render in target_Render:
                        if typeIndex == showedType: render.setRenderState(True)
                        else: render.setRenderState(False)
                        categories.append(render)
                layer.setRenderer(QgsCategorizedSymbolRenderer('group*10+order+(VerCheck*VerStat)*5', categories))
            
        if self.segmentIndex == 0 or self.segmentIndex == 1:
            if viewerClear == True:
                RecommendLaneMessage.showedDataArray[self.routeType].clear()
        
        if len(self.dataArray) > 0:
            if viewerClear == True:
                #バッファにためておく、さらに、現在表示中の推奨レーンのみ、Canvasに描画
                RecommendLaneMessage.showedDataArray[self.routeType].append([self.commonHeader.logTime, self.dataArray])
                if self.routeType == showedType:
                    RecommendLaneMessage.drawTargetDataArray(self, layer, layer_routeConversionStatus, self.routeType, [[self.commonHeader.logTime, self.dataArray]], realTimeMode)
            else:
                #そのままCanvasに描画
                if realTimeMode == DrawMode.FullDraw: #full描画の場合は、全てきたものを描画
                    RecommendLaneMessage.drawTargetDataArray(self, layer, layer_routeConversionStatus, self.routeType, [[self.commonHeader.logTime, self.dataArray]], realTimeMode)
                else: # realTimeModeの場合は、recommendedLaneShowTargetとして指定したものだけ描画
                    if (recommendedLaneShowTarget == 'ALL' or self.routeType == showedType):
                        RecommendLaneMessage.drawTargetDataArray(self, layer, layer_routeConversionStatus, self.routeType, [[self.commonHeader.logTime, self.dataArray]], realTimeMode)
            
            #Actionフラグ情報は、常に描画するが、すでに描画したものは描画しない。
            dic = ProfileMessage.laneLinkGeometryDic
            hdmapDic = ProfileMessage.hdmapGeometryDic
            oldHdmapDic = ProfileMessage.oldHdmapGeometryDic
            orderFeatures = []
            vehicleCode = getVehicleType()

            for linkeData in self.dataArray:
                geometryLaneID = linkeData.ID                        
                if geometryLaneID in hdmapDic:
                    pointList = hdmapDic[geometryLaneID]['geometry']
                elif geometryLaneID in oldHdmapDic:
                    pointList = oldHdmapDic[geometryLaneID]['geometry']
                elif geometryLaneID in dic:
                    pointList = dic[geometryLaneID]['geometry']
                else:
                    continue #描画できなかったため、追加しない
                
                if (realTimeMode == DrawMode.QGIS_RealTimeDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw):
                    if geometryLaneID in RecommendLaneMessage.showedActionFlagLaneID:
                        continue #realTimeModeでは、一度描画したActionFlagは再度描画しない
                    else:
                        RecommendLaneMessage.showedActionFlagLaneID.append(geometryLaneID)
                
                if linkeData.maintainClass == 0xFFFFFFFF:
                    MaintenanceWhenMeasuring = 0
                else:
                    MaintenanceWhenMeasuring = (linkeData.maintainClass & 0x00003000) >> 12 #2bit分計測時工事中フラグ、下の12bitは、Gen1用のActionFlag
                
                vehicleAFTypeCode = 0
                if self.isRegionJP:
                    if vehicleCode == 0: vehicleAFTypeCode = 0 # PZ1A : 国内車種１
                    elif vehicleCode == 1: vehicleAFTypeCode = 1 # J32V : 国内車種２、　J42U : ?
                    elif vehicleCode == 3: vehicleAFTypeCode = 2 # P33A : 国内車種３
                    elif vehicleCode == 5: vehicleAFTypeCode = 0 # PZ1D : 国内車種１
                else:
                    if vehicleCode == 0: vehicleAFTypeCode = 4 # LZ1FE : 北米車種５
                    if vehicleCode == 2: vehicleAFTypeCode = 1 # P61QR : 北米車種２
                    elif vehicleCode == 3: vehicleAFTypeCode = 2 # P33A : 北米車種３、　P42SV : 北米車種４？　この仕組みでは区別できない。
                    elif vehicleCode == 4: vehicleAFTypeCode = 3 # P42QR : 北米車種４
                    elif vehicleCode == 5: vehicleAFTypeCode = 0 # PZ1D : 北米車種１
                    
                if vehicleAFTypeCode == 0:
                    if linkeData.functionalAuthority3 == 0xFFFFFFFF: nissanFlagForCar = 0
                    else: nissanFlagForCar = (linkeData.functionalAuthority3 & 0xFFFF0000) >> 16
                elif vehicleAFTypeCode == 1:
                    if linkeData.functionalAuthority3 == 0xFFFFFFFF: nissanFlagForCar = 0
                    else: nissanFlagForCar = (linkeData.functionalAuthority3 & 0x0000FFFF)
                elif vehicleAFTypeCode == 2:
                    if linkeData.functionalAuthority2 == 0xFFFFFFFF: nissanFlagForCar = 0
                    else: nissanFlagForCar = (linkeData.functionalAuthority2 & 0xFFFF0000) >> 16
                elif vehicleAFTypeCode == 3:
                    if linkeData.functionalAuthority2 == 0xFFFFFFFF: nissanFlagForCar = 0
                    else: nissanFlagForCar = (linkeData.functionalAuthority2 & 0x0000FFFF)
                elif vehicleAFTypeCode == 4:
                    if linkeData.functionalAuthority1 == 0xFFFFFFFF: nissanFlagForCar = 0
                    else: nissanFlagForCar = (linkeData.functionalAuthority1 & 0xFFFF0000) >> 16
                elif vehicleAFTypeCode == 5:
                    if linkeData.functionalAuthority1 == 0xFFFFFFFF: nissanFlagForCar = 0
                    else: nissanFlagForCar = (linkeData.functionalAuthority1 & 0x0000FFFF)
                else: #そのほか、不明な車種の場合、とりあえずPZ1AのAFを出力
                    if linkeData.functionalAuthority3 == 0xFFFFFFFF: nissanFlagForCar = 0
                    else: nissanFlagForCar = (linkeData.functionalAuthority3 & 0xFFFF0000) >> 16
                        
                cameraUnstable = (nissanFlagForCar & 0x8000) >> 15
                actionFlag = (nissanFlagForCar & 0x6000) >> 13
                shpFlag = (nissanFlagForCar & 0x1C00) >> 10
                swFlag = (nissanFlagForCar & 0x0380) >> 7
                if MaintenanceWhenMeasuring == 1:
                    categoryValue = 255
                elif actionFlag > 0:
                    categoryValue = 10+actionFlag
                elif cameraUnstable == 1:
                    categoryValue = 1
                elif shpFlag > 0:
                    categoryValue = 20+shpFlag
                elif swFlag > 0:
                    categoryValue = 30+swFlag
                else:
                    categoryValue = 0
                
                if categoryValue != 0:
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(point[0], point[1], point[2]) for point in pointList]))
                    if realTimeMode == DrawMode.FullDraw:
                        if hasattr(linkeData, "maintenanceStart"):
                            feature.setAttributes([QDateTime(self.commonHeader.logTime), categoryValue, nissanFlagForCar, 
                                                   str(hex(linkeData.maintenanceStart) if linkeData.maintenanceStart == 0xFFFFFFFF else linkeData.maintenanceStart), 
                                                   str(hex(linkeData.maintenanceStartTime) if linkeData.maintenanceStartTime == 0xFFFF else linkeData.maintenanceStartTime)])
                        else:
                            feature.setAttributes([QDateTime(self.commonHeader.logTime), categoryValue, nissanFlagForCar, '-', '-'])
                    else:
                        feature.setAttributes([categoryValue])
                    orderFeatures.append(feature)
            layer_actionFlag.dataProvider().addFeatures(orderFeatures)
            
    def drawTargetDataArray(self, layer, layer_routeConversionStatus, routeType, showedDataArray, realTimeMode):
        if len(showedDataArray) > 0:
            dic = ProfileMessage.laneLinkGeometryDic
            hdmapDic = ProfileMessage.hdmapGeometryDic
            oldHdmapDic = ProfileMessage.oldHdmapGeometryDic
            orderFeatures = []
            routeConversionStatusFeatures = []
            for showedData in showedDataArray:
                time = showedData[0]
                dataArray = showedData[1]
                for linkeData in dataArray:
                    geometryLaneID = linkeData.ID
                    if geometryLaneID in hdmapDic:
                        pointList = hdmapDic[geometryLaneID]['geometry']
                    elif geometryLaneID in oldHdmapDic:
                        pointList = oldHdmapDic[geometryLaneID]['geometry']
                    elif geometryLaneID in dic:
                        pointList = dic[geometryLaneID]['geometry']
                    else:
                        continue
                    
#                     if (self.commonHeader.logTime.strftime('%Y-%m-%d %H:%M:%S.%f') == "2024-09-19 11:33:52.528675"):
#                         print("id = {}, geometryLaneID in hdmapDic = {}, geometryLaneID in dic = {}, points = {}".format(geometryLaneID, geometryLaneID in hdmapDic, geometryLaneID in dic, pointList))
                    
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(point[0], point[1], point[2]) for point in pointList]))
                    if realTimeMode == DrawMode.FullDraw:
                        isDummyLink = (linkeData.routeConversionStatus == 0x02000000)
                        feature.setAttributes([QDateTime(time), str(geometryLaneID), 
                                               routeType, linkeData.lanePriority, linkeData.versionCheckStatus, linkeData.versionInfo,
                                               isDummyLink, linkeData.PoCRflag, linkeData.frontLaneCount, linkeData.maximumVelocityInfo])
                    else:
                        feature.setAttributes([routeType, linkeData.lanePriority, linkeData.versionCheckStatus, linkeData.versionInfo])
                    orderFeatures.append(feature)
                    
                    if layer_routeConversionStatus != None and linkeData.routeConversionStatusCount > 0:
                        for arrayIndex in range(linkeData.routeConversionStatusCount):
                            routeConversionStatusValue = linkeData.routeConversionStatusArray[arrayIndex]
                            feature = QgsFeature()
                            feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(point[0], point[1], point[2]) for point in pointList]))
                            matchResult = (routeConversionStatusValue & 0xC000) >> 14
                            iviResult =   (routeConversionStatusValue & 0x3000) >> 12
                            duringPathCreate = (routeConversionStatusValue & 0x0800) >> 11
                            dummyLink =   (routeConversionStatusValue & 0x0700) >> 8
                            hdmapLane =   (routeConversionStatusValue & 0x00F0) >> 4
                            iviLane =     (routeConversionStatusValue & 0x000F)
                            feature.setAttributes([QDateTime(time), str(geometryLaneID), 
                                                   routeConversionStatusValue,
                                                   RecommendLaneMessage.RouteConversion_matchResultDic.get(matchResult, '[error]'),
                                                   RecommendLaneMessage.RouteConversion_iviResultDic.get(iviResult, '[error]'),
                                                   duringPathCreate,
                                                   RecommendLaneMessage.RouteConversion_dummyLinkDic.get(dummyLink, '[error]'),
                                                   hdmapLane,
                                                   iviLane])
                            routeConversionStatusFeatures.append(feature)
                            
            layer.dataProvider().addFeatures(orderFeatures)
            if layer_routeConversionStatus != None:
                layer_routeConversionStatus.dataProvider().addFeatures(routeConversionStatusFeatures)

#-----------------------------------------------#
#----   RecommendLaneMessage              ----#
#-----------------------------------------------#
class RecommendLaneMessage_JP(RecommendLaneMessage):        
    @dataclass
    class LinkTargetInfo:
        linkDirectionFlag: int #16
        reserve: int
        linkTargetLaneID: int #64
        
    @dataclass
    class SplitInfo:
        posClassify: int #16
        objectID: int #32
        lineClassify: int #16
        linePropertyFlag: int #16
        
    @dataclass
    class ADAS2property:
        headLinkFlag: int #8
        loadClassfyCode: int #16
        lineClassify: int #16
        linePropertyOptionFlag: int #32
        lineAddtionalPropertyFlag: int #32

    class LaneLinkInfo:
        ID: int #64
        routeConversionStatus: int #32
        lanePriority: int #16
        laneIndex: int #8
        frontLaneCount: int #8
        maximumVelocityInfo: int #16
        linePropertyClassify: int #16
        lanePropertyOptionFlag: int #32
        lanePropertyFlag: int #32
        distance: int #32
        direction: int #16
        curvature: int #32
        leftLaneID: int #64
        rightLaneID: int #64
        laneNWclassify: int #16
        maintenanceStart: int #32
        maintenanceStartTime: int #16
        maintainClass: int #32
        functionalAuthority1: int #32
        functionalAuthority2: int #32
        functionalAuthority3: int #32
        versionCheckStatus: int #8
        versionInfo: int #8
        PoCRflag: int #8
        targetLaneCount: int #16
        linkTargetArray: List[int]
        splitInfoCount: int #16
        splitInfoArray: List[int]
        SDLinkageStatus: int #16
        ADAS2propertyCount: int #16
        ADAS2propertyArray: List[int]
        routeConversionStatusCount: int #16
        routeConversionStatusArray: List[int]

        def printValue(self, sheet, row, col, _level = 1):
            sheet.write_row(row, col, [
                str(self.ID),
                hex(self.routeConversionStatus),
                (self.lanePriority),
                (self.laneIndex),
                (self.frontLaneCount),
                (self.maximumVelocityInfo),
                (self.linePropertyClassify),
                hex(self.lanePropertyOptionFlag),
                hex(self.lanePropertyFlag),
                (self.distance),
                (self.direction * 0.1),
                (self.curvature / 100000000.0),
                str(self.leftLaneID),
                str(self.rightLaneID),
                (self.laneNWclassify),
                self.maintenanceStart,
                self.maintenanceStartTime,
                hex(self.maintainClass),
                hex(self.functionalAuthority3),
                hex(self.functionalAuthority2),
                hex(self.functionalAuthority1),
                (self.versionCheckStatus),
                (self.versionInfo),
                (self.PoCRflag),
                (self.targetLaneCount),
                (self.splitInfoCount),
                RecommendLaneMessage.SDLinkageStatusDic.get(self.SDLinkageStatus, '[error]'),
                (self.ADAS2propertyCount),
                (self.routeConversionStatusCount)
                ])
            col += 29

            for i in range(self.targetLaneCount):
                printList = []
                printList += [sheet.cellFormats('blue'), '   *<接続先情報の配列>\n']
                printList += [
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') 接続方向フラグ: ',
                    str(self.linkTargetArray[i].linkDirectionFlag) + "\n",
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') 接続先レーンリンクID: ',
                    str(self.linkTargetArray[i].linkTargetLaneID) + "\n"]
                printList += [sheet.cellFormats('wrap')]
                sheet.write_rich_string(row, col, *printList)
                col = col + 1
            for i in range(self.splitInfoCount):
                printList = []
                printList += [sheet.cellFormats('blue'), '   *<区画線先情報の配列>\n']
                printList += [
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') 位置種別: ',
                    str(self.splitInfoArray[i].posClassify) + "\n",
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') 道路構成地物ID: ',
                    str(hex(self.splitInfoArray[i].objectID)) + "\n",
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') 区画線種別: ',
                    str(self.splitInfoArray[i].lineClassify) + "\n",
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') 区画線付加属性フラグ: ',
                    str(self.splitInfoArray[i].linePropertyFlag) + "\n"]
                printList += [sheet.cellFormats('wrap')]
                sheet.write_rich_string(row, col, *printList)
                col = col + 1
            for i in range(self.ADAS2propertyCount):
                printList = []
                printList += [sheet.cellFormats('blue'), '   *<ADAS2.0属性数の配列>\n']
                printList += [
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') 先頭リンクフラグ: ',
                    str(self.ADAS2propertyArray[i].headLinkFlag) + "\n",
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') 道路種別コード: ',
                    str(hex(self.ADAS2propertyArray[i].loadClassfyCode)) + "\n",
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') リンク種別: ',
                    str(self.ADAS2propertyArray[i].lineClassify) + "\n",
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') リンク属性オプションフラグ: ',
                    str(self.ADAS2propertyArray[i].linePropertyOptionFlag) + "\n",
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') リンク付加属性フラグ: ',
                    str(self.ADAS2propertyArray[i].lineAddtionalPropertyFlag) + "\n"]
                printList += [sheet.cellFormats('wrap')]
                sheet.write_rich_string(row, col, *printList)
                col = col + 1
            for i in range(self.routeConversionStatusCount):
                printList = []
                printList += [sheet.cellFormats('blue'), '   *<経路変換状態の配列>\n']
                printList += [
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') 経路変換状態: ',
                    str(self.routeConversionStatusArray[i]) + "\n"]
                printList += [sheet.cellFormats('wrap')]
                sheet.write_rich_string(row, col, *printList)
                col = col + 1
            sheet.write(row, col, "...")
            col = col + 1
            return [row+1, col, []]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        self.isRegionJP = True
    
    def readLaneLinkInfo(self):
        readFunc = self.data.readValue
        ethernetSpecVersion = getEthernetSpecVer()
        laneLinkInfo = self.LaneLinkInfo()
        laneLinkInfo.ID = readFunc(int,64)
        laneLinkInfo.routeConversionStatus = readFunc(int,32)
        laneLinkInfo.lanePriority = readFunc(int,16, True)
        laneLinkInfo.laneIndex = readFunc(int,8, True)
        laneLinkInfo.frontLaneCount = readFunc(int,8, True)
        laneLinkInfo.maximumVelocityInfo = readFunc(int,16)
        laneLinkInfo.linePropertyClassify = readFunc(int,16, True)
        laneLinkInfo.lanePropertyOptionFlag = readFunc(int,32)
        laneLinkInfo.lanePropertyFlag = readFunc(int,32)
        laneLinkInfo.distance = readFunc(int,32)
        laneLinkInfo.direction = readFunc(int,16)
        laneLinkInfo.curvature = readFunc(int,32, True)
        laneLinkInfo.leftLaneID = readFunc(int,64)
        laneLinkInfo.rightLaneID = readFunc(int,64)
        laneLinkInfo.laneNWclassify = readFunc(int,16, True)
        laneLinkInfo.maintenanceStart = readFunc(int,32)
        laneLinkInfo.maintenanceStartTime = readFunc(int,16)
        readFunc(int,16) #reserved
        if ethernetSpecVersion >= datetime(2020, 3, 31):
            laneLinkInfo.maintainClass = readFunc(int,32)
            laneLinkInfo.functionalAuthority3 = readFunc(int,32)
            laneLinkInfo.functionalAuthority2 = readFunc(int,32)
            laneLinkInfo.functionalAuthority1 = readFunc(int,32)
            if laneLinkInfo.functionalAuthority1 != 0 or laneLinkInfo.functionalAuthority2 != 0 or laneLinkInfo.functionalAuthority3 != 0:
                if laneLinkInfo.maintenanceStart == 0xFFFFFFFF or laneLinkInfo.maintenanceStartTime == 0xFFFF: #信頼度情報がない場合のみ無効値
                    logger = getLogger()
                    logger.errLog('(LogIndex:{}) LaneID:{}, functionalAuthorit exist but maintenanceStart info invalid'.format(self.commonHeader.logIndex, laneLinkInfo.ID), showConsole = False)
        else:
            laneLinkInfo.maintainClass = readFunc(int,32)
            laneLinkInfo.functionalAuthority3 = 0xFFFFFFFF
            laneLinkInfo.functionalAuthority2 = 0xFFFFFFFF
            laneLinkInfo.functionalAuthority1 = 0xFFFFFFFF
        laneLinkInfo.versionCheckStatus = readFunc(int,8)
        laneLinkInfo.versionInfo = readFunc(int,8)
        laneLinkInfo.PoCRflag = readFunc(int,8)
        readFunc(int,24) #reserved
        readFunc(int,32) #reserved
        laneLinkInfo.targetLaneCount = readFunc(int,16, True)
        laneLinkInfo.linkTargetArray = []
        for _ in range(laneLinkInfo.targetLaneCount):
            laneLinkInfo.linkTargetArray.append(self.LinkTargetInfo(
                linkDirectionFlag = readFunc(int,16, True),
                reserve = readFunc(int,16),
                linkTargetLaneID = readFunc(int,64)))
        laneLinkInfo.splitInfoCount = readFunc(int,16, True)
        laneLinkInfo.splitInfoArray = []
        for _ in range(laneLinkInfo.splitInfoCount):
            laneLinkInfo.splitInfoArray.append(self.SplitInfo(
                posClassify = readFunc(int,16),
                objectID = readFunc(int,32),
                lineClassify = readFunc(int,16, True),
                linePropertyFlag = readFunc(int,16)))
        laneLinkInfo.SDLinkageStatus = readFunc(int,16)
        laneLinkInfo.ADAS2propertyCount = readFunc(int,16)
        laneLinkInfo.ADAS2propertyArray = []
        for _ in range(laneLinkInfo.ADAS2propertyCount):
            laneLinkInfo.ADAS2propertyArray.append(self.ADAS2property(
                headLinkFlag = readFunc(int,8),
                loadClassfyCode = readFunc(int,16),
                lineClassify = readFunc(int,16),
                linePropertyOptionFlag = readFunc(int,32),
                lineAddtionalPropertyFlag = readFunc(int,32)))
        if ethernetSpecVersion >= datetime(2020, 6, 16):
            laneLinkInfo.routeConversionStatusCount = readFunc(int,16)
            laneLinkInfo.routeConversionStatusArray = []
            for _ in range(laneLinkInfo.routeConversionStatusCount):
                laneLinkInfo.routeConversionStatusArray.append(readFunc(int,16))
        else:
            laneLinkInfo.routeConversionStatusCount = 0
            laneLinkInfo.routeConversionStatusArray = []
        return laneLinkInfo
            
    def printHeader(self, sheet, row, col, _level = 1):
        ethernetSpecVersion = getEthernetSpecVer()
        sheet.set_row(0, 22.5)
        
        sheet.insert_button(row, 3, {'macro':   "'SmallFit \"A:" + getColumnName(self.commonHeader.columnCount() + 33-1) + "\"'", #詳細情報は除外
                                    'caption': '-> 狭く表示 <-',
                                    'width':   100,
                                    'height':  30})
        
        sheet.insert_button(row, 6, {'macro':   "'AutoFit \"A:" + getColumnName(self.commonHeader.columnCount() + 33-1) + "\"'", #詳細情報は除外
                                    'caption': '<- 広く表示 ->',
                                    'width':   100,
                                    'height':  30})
        
        sheet.insert_button(row, self.commonHeader.columnCount()+4, {'macro':   "'makeLaneSelectScript \"" + 
                                      getCellName(row+2, 1) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+4) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+6) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+1) + "\"'",
                                    'caption': '↓ QGIS描画',
                                    'width':   100,
                                    'height':  30})

        [_, col, _] = self.commonHeader.printHeader(sheet, row+1, col)
        
        strList = []
        if ethernetSpecVersion >= datetime(2020, 9, 4):
            strList += [
            '送信データの分割数', 
            '送信データの分割番号']
        else:
            strList += [
            '推奨レーン総数', 
            '推奨レーン番号']
            
        strList += [ 
            '経路Type', 
            'レーンリンク情報数',
            'レーンリンクID', 
            '経路変換状態', 
            'レーン優先度', 
            'レーン番号',
            '進行方向レーン数',
            '最高速度情報[Km/h]',
            '車線属性種別',
            'レーン属性オプションフラグ',
            'レーン付加属性フラグ',
            '距離(リンク長)[cm]',
            '方位角[deg]',
            '曲率[rad/m]',
            '左側車線レーンリンクID',
            '右側車線レーンリンクID',
            'レーンNW種別',
            '工事開始日',
            '工事開始時間',   
            '工事種別',
            '機能制限フラグ3',
            '機能制限フラグ2',
            '機能制限フラグ1',
            '鮮度情報チェック状態',
            '鮮度情報',
            'PoCRフラグ',
            '接続先レーンリンク数',
            '区画線情報数',
            'SDLinkage有無',
            'ADAS2.0属性数',
            '経路変換状態数',
            '詳細情報']
                    
        sheet.write_row(row+1, col, strList, sheet.cellFormats('header'))
        col += len(strList)

        sheet.set_row(1, 20)
        sheet.autofilter(1, 0, 1, col-1)
        sheet.freeze_panes(2, 0)
        return [row+2, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        ethernetSpecVersion = getEthernetSpecVer()
        newRow = row
        newCol = col
        [_, newCol, _] = self.commonHeader.printValue(sheet, newRow, newCol)
        
        valueList = []
        if ethernetSpecVersion >= datetime(2020, 9, 4):
            valueList += [
                (self.segmentCount),
                (self.segmentIndex)]
        else:
            valueList += [
                (self.laneLinkCount),
                (self.laneLinkIndex)]
        
        valueList += [
            RecommendLaneMessage.RouteTypeDic[self.routeType],
            (self.dataArrayCount)]
        
        sheet.write_row(newRow, newCol, valueList)
        newCol += len(valueList)
        valueLastCol = newCol
        
        if len(self.dataArray) > 0:
            if sheet.useMultiLine == True:                        
                for linkeData in self.dataArray:
                    [newRow, _, _] = linkeData.printValue(sheet, newRow, newCol)
                
                for c in range(col,valueLastCol):
                    merge_rows(sheet, row, c, newRow-row)
            else:
                newRow += 1
        else:
            newRow += 1
        
        return [newRow, 0, []]

#-----------------------------------------------#
#----   RecommendLaneMessage(US)          ----#
#-----------------------------------------------#
class RecommendLaneMessage_US(RecommendLaneMessage):    
    @dataclass
    class ADAS2property:
        OSMID: int #64
        laneClassCode: int #8
        subLinkClassCode: int #8
        infoFlag: int #8
        
    @dataclass
    class LinkTargetInfo:
        linkDirectionFlag: int #16
        linkTargetLaneID: int #64
        
    @dataclass
    class SplitInfo:
        laneLineID: int #64
        posClassify: int #16
        laneLineType: int #16
        laneLineColor: int #16
        laneLineWidth: int #16
        reflectiveMarkings: int #16
        pavementStripingPresent: int #16

    class LaneLinkInfo:        
        ID: int #64
        routeConversionStatus: int #32
        lanePriority: int #16
        laneIndex: int #16
        frontLaneCount: int #16
        maximumVelocityInfo: int #16
        Road_Type: int #16
        Lane_Add_Remove_Type: int #16
        Accelerating_Lane: int #8
        Decelerating_Lane: int #8
        Lane_Type: int #16
        Crossing_Type_tunnel: int #8
        Left_Change_Allowed: int #8
        Right_Change_Allowed: int #8
        distance: int #16
        direction: int #16
        curvature: int #16
        leftLaneID: int #64
        rightLaneID: int #64
        maintainClass: int #32
        functionalAuthority1: int #32
        functionalAuthority2: int #32
        functionalAuthority3: int #32
        versionCheckStatus: int #8
        versionInfo: int #8
        PoCRflag: int #8
        targetLaneCount: int #16
        linkTargetArray: List[int]
        splitInfoCount: int #16
        splitInfoArray: List[int]
        SDLinkageStatus: int #16
        adas2propertyCount: int
        adas2propertyArray: List[int]
        routeConversionStatusCount: int #16
        routeConversionStatusArray: List[int]

        def printValue(self, sheet, row, col, _level = 1):
            valueArray = [
                str(self.ID),
                hex(self.routeConversionStatus),
                (self.lanePriority),
                (self.laneIndex),
                (self.frontLaneCount),
                (self.maximumVelocityInfo),
                (self.Road_Type),
                (self.Lane_Add_Remove_Type),
                (self.Accelerating_Lane),
                (self.Decelerating_Lane),
                (self.Lane_Type),
                (self.Crossing_Type_tunnel),
                (self.Left_Change_Allowed),
                (self.Right_Change_Allowed),
                (self.distance),
                (self.direction * 0.01),
                (self.curvature * 0.0001),
                str(self.leftLaneID),
                str(self.rightLaneID),
                hex(self.maintainClass),
                hex(self.functionalAuthority3),
                hex(self.functionalAuthority2),
                hex(self.functionalAuthority1),
                (self.versionCheckStatus),
                (self.versionInfo),
                (self.PoCRflag),
                RecommendLaneMessage.SDLinkageStatusDic.get(self.SDLinkageStatus, '[error]'),
                (self.targetLaneCount),
                (self.splitInfoCount),
                (self.adas2propertyCount),
                (self.routeConversionStatusCount)
                ]
            sheet.write_row(row, col, valueArray)
            col += len(valueArray)

            for i in range(self.targetLaneCount):
                printList = []
                printList += [sheet.cellFormats('blue'), '   *<接続先情報の配列>\n']
                printList += [
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') 接続方向フラグ: ',
                    str(self.linkTargetArray[i].linkDirectionFlag) + "\n",
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') 接続先レーンリンクID: ',
                    str(self.linkTargetArray[i].linkTargetLaneID) + "\n"]
                printList += [sheet.cellFormats('wrap')]
                sheet.write_rich_string(row, col, *printList)
                col = col + 1
            for i in range(self.splitInfoCount):
                printList = []
                printList += [sheet.cellFormats('blue'), '   *<Lane Line情報の配列>\n']
                printList += [
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') Lane Line ID: ',
                    str(self.splitInfoArray[i].laneLineID) + "\n",
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') 位置種別: ',
                    str(self.splitInfoArray[i].posClassify) + "\n",
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') Lane Line Type: ',
                    str(self.splitInfoArray[i].laneLineType) + "\n",
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') Lane Line Color: ',
                    str(self.splitInfoArray[i].laneLineColor) + "\n",
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') Lane Line Width: ',
                    str(self.splitInfoArray[i].laneLineWidth) + "\n",
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') Reflective Markings: ',
                    str(self.splitInfoArray[i].reflectiveMarkings) + "\n",
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') Pavement Striping Present: ',
                    str(self.splitInfoArray[i].pavementStripingPresent) + "\n"]
                printList += [sheet.cellFormats('wrap')]
                sheet.write_rich_string(row, col, *printList)
                col = col + 1
            for i in range(self.adas2propertyCount):
                printList = []
                printList += [sheet.cellFormats('blue'), '   *<ADAS2.0属性配列>\n']
                printList += [sheet.cellFormats('blue'), '   *(' + str(i+1) + ') OSMID: ', str(self.adas2propertyArray[i].OSMID) + "\n"]
                printList += [sheet.cellFormats('blue'), '   *(' + str(i+1) + ') 道路種別: ', str(self.adas2propertyArray[i].laneClassCode) + "\n"]
                printList += [sheet.cellFormats('blue'), '   *(' + str(i+1) + ') サブリンク種別: ', str(self.adas2propertyArray[i].subLinkClassCode) + "\n"]
                printList += [sheet.cellFormats('blue'), '   *(' + str(i+1) + ') 橋・トンネル属性: ', bin(self.adas2propertyArray[i].infoFlag) + "\n"]
                printList += [sheet.cellFormats('wrap')]
                sheet.write_rich_string(row, col, *printList)
                col = col + 1
            for i in range(self.routeConversionStatusCount):
                printList = []
                printList += [sheet.cellFormats('blue'), '   *<経路変換状態の配列>\n']
                printList += [
                    sheet.cellFormats('blue'), '   *(' + str(i+1) + ') 経路変換状態: ',
                    str(self.routeConversionStatusArray[i]) + "\n"]
                printList += [sheet.cellFormats('wrap')]
                sheet.write_rich_string(row, col, *printList)
                col = col + 1
            sheet.write(row, col, "...")
            col = col + 1
            return [row+1, col, []]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        self.isRegionJP = False
    
    def readLaneLinkInfo(self):
        readFunc = self.data.readValue
        ethernetSpecVersion = getEthernetSpecVer()
        laneLinkInfo = self.LaneLinkInfo()
        laneLinkInfo.ID = readFunc(int,64)
        laneLinkInfo.routeConversionStatus = readFunc(int,32)
        laneLinkInfo.lanePriority = readFunc(int,16) # US different
        laneLinkInfo.laneIndex = readFunc(int,16) # US different
        laneLinkInfo.frontLaneCount = readFunc(int,16) # US different
        laneLinkInfo.maximumVelocityInfo = readFunc(int,16)
        laneLinkInfo.Road_Type = readFunc(int,16) # US different
        laneLinkInfo.Lane_Add_Remove_Type = readFunc(int,16) # US different
        laneLinkInfo.Accelerating_Lane = readFunc(int,8) # US different
        laneLinkInfo.Decelerating_Lane = readFunc(int,8) # US different
        laneLinkInfo.Lane_Type = readFunc(int,16) # US different
        laneLinkInfo.Crossing_Type_tunnel = readFunc(int,8) # US different
        laneLinkInfo.Left_Change_Allowed = readFunc(int,8) # US different
        laneLinkInfo.Right_Change_Allowed = readFunc(int,8) # US different
        laneLinkInfo.distance = readFunc(int,16) # US different
        laneLinkInfo.direction = readFunc(int,16)
        laneLinkInfo.curvature = readFunc(int,16, True) # US different
        laneLinkInfo.leftLaneID = readFunc(int,64)
        laneLinkInfo.rightLaneID = readFunc(int,64)
        laneLinkInfo.maintainClass = readFunc(int,32) # US different
        laneLinkInfo.functionalAuthority3 = readFunc(int,32) # US different
        laneLinkInfo.functionalAuthority2 = readFunc(int,32) # US different
        laneLinkInfo.functionalAuthority1 = readFunc(int,32) # US different
        laneLinkInfo.versionCheckStatus = readFunc(int,8)
        laneLinkInfo.versionInfo = readFunc(int,8)
        laneLinkInfo.PoCRflag = readFunc(int,8)
        laneLinkInfo.targetLaneCount = readFunc(int,16) # US different
        laneLinkInfo.linkTargetArray = []
        for _ in range(laneLinkInfo.targetLaneCount):
            laneLinkInfo.linkTargetArray.append(self.LinkTargetInfo(
                linkDirectionFlag = readFunc(int,16), # US different
                linkTargetLaneID = readFunc(int,64)))
        laneLinkInfo.splitInfoCount = readFunc(int,16) # US different
        laneLinkInfo.splitInfoArray = []
        for _ in range(laneLinkInfo.splitInfoCount):
            laneLinkInfo.splitInfoArray.append(self.SplitInfo(
                laneLineID = readFunc(int,64), # US different
                posClassify = readFunc(int,16),
                laneLineType = readFunc(int,16),
                laneLineColor = readFunc(int,16),
                laneLineWidth = readFunc(int,16),
                reflectiveMarkings = readFunc(int,16),
                pavementStripingPresent = readFunc(int,16)))
            
        if ethernetSpecVersion >= datetime(2021, 4, 21):
            laneLinkInfo.SDLinkageStatus = readFunc(int,16)
            laneLinkInfo.adas2propertyCount = readFunc(int,32)
        else:
            laneLinkInfo.SDLinkageStatus = 0
            laneLinkInfo.adas2propertyCount = 0
        
        laneLinkInfo.adas2propertyArray = []
        for _ in range(laneLinkInfo.adas2propertyCount):
            laneLinkInfo.adas2propertyArray.append(self.ADAS2property(
                OSMID = readFunc(int,64),
                laneClassCode = readFunc(int,8),
                subLinkClassCode = readFunc(int,8),
                infoFlag = readFunc(int,8)))
            
        laneLinkInfo.routeConversionStatusCount = readFunc(int,16)
        laneLinkInfo.routeConversionStatusArray = []
        for _ in range(laneLinkInfo.routeConversionStatusCount):
            laneLinkInfo.routeConversionStatusArray.append(readFunc(int,16))
        return laneLinkInfo
            
    def printHeader(self, sheet, row, col, _level = 1):
        #ethernetSpecVersion = getEthernetSpecVer()
        sheet.set_row(0, 22.5)
        
        sheet.insert_button(row, 3, {'macro':   "'SmallFit \"A:" + getColumnName(self.commonHeader.columnCount() + 33-1) + "\"'", #詳細情報は除外
                                    'caption': '-> 狭く表示 <-',
                                    'width':   100,
                                    'height':  30})
        
        sheet.insert_button(row, 6, {'macro':   "'AutoFit \"A:" + getColumnName(self.commonHeader.columnCount() + 33-1) + "\"'", #詳細情報は除外
                                    'caption': '<- 広く表示 ->',
                                    'width':   100,
                                    'height':  30})
        
        sheet.insert_button(row, self.commonHeader.columnCount()+4, {'macro':   "'makeLaneSelectScript \"" + 
                                      getCellName(row+2, 1) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+4) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+6) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+1) + "\"'",
                                    'caption': '↓ QGIS描画',
                                    'width':   100,
                                    'height':  30})

        [_, col, _] = self.commonHeader.printHeader(sheet, row+1, col)
        
        strList = [
            '送信データの分割数', 
            '送信データの分割番号',
            '経路Type', 
            'レーンリンク情報数',
            'レーンリンクID', 
            '経路変換状態', 
            'レーン優先度', 
            'レーン番号',
            '進行方向レーン数',
            '最高速度情報[Km/h]',
            'Road Type',
            'Lane_Add_Remove_Type',
            'Accelerating Lane',
            'Decelerating Lane',
            'Lane Type',
            'Crossing Type (only tunnel)',
            'Left Change Allowed',
            'Right Change Allowed',
            '距離(リンク長)[m]',
            '方位角[deg]',
            '曲率[1/m]',
            '左側車線レーンリンクID',
            '右側車線レーンリンクID',
            'MAP Functional Authority',
            'Functional Authority 3',
            'Functional Authority 2',
            'Functional Authority 1',
            '鮮度情報チェック状態',
            '鮮度情報',
            'PoCRフラグ',
            'SDLinkage有無',
            '接続先レーンリンク数',
            'Lane Line情報数',
            'ADAS2.0属性数',
            '経路変換状態数',
            '詳細情報']
                    
        sheet.write_row(row+1, col, strList, sheet.cellFormats('header'))
        col += len(strList)

        sheet.set_row(1, 20)
        sheet.autofilter(1, 0, 1, col-1)
        sheet.freeze_panes(2, 0)
        return [row+2, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        #ethernetSpecVersion = getEthernetSpecVer()
        newRow = row
        newCol = col
        [_, newCol, _] = self.commonHeader.printValue(sheet, newRow, newCol)
        
        valueList = [
            (self.segmentCount),
            (self.segmentIndex),
            RecommendLaneMessage.RouteTypeDic[self.routeType],
            (self.dataArrayCount)]
        
        sheet.write_row(newRow, newCol, valueList)
        newCol += len(valueList)
        valueLastCol = newCol
        
        if len(self.dataArray) > 0:                    
            if sheet.useMultiLine == True:
                for linkeData in self.dataArray:
                    [newRow, _, _] = linkeData.printValue(sheet, newRow, newCol)
                
                for c in range(col,valueLastCol):
                    merge_rows(sheet, row, c, newRow-row)
            else:
                newRow += 1
        else:
            newRow += 1
        
        return [newRow, 0, []]
                        
#-----------------------------------------------#
#----   CarPositionMessage                  ----#
#-----------------------------------------------#
class CarPositionMessage(Message, AnalyzePositionError):

    @dataclass
    class CarPositionBeforeCorrection:
        latitude: int
        longitude: int
        ellipsoidHigh: int
        geoidHigh: int
        carDirection: int
        errRadiusLong: int
        errRadiusShort: int
        errRadiusDirection: int

    @dataclass
    class CarPositionAfterCorrection:
        carDirection: int
        latitude: int
        longitude: int
        ellipsoidHigh: int

    @dataclass
    class LaneProjectionPosition:
        laneDirection: int
        latitude: int
        longitude: int
        ellipsoidHigh: int
    
    def getAnalyzePositionErrorLonLat(self): #誤差評価対象となる経度緯度
        lat = self.carPositionBeforeCorrection.latitude * 360.0 / (1<<32)
        lon = self.carPositionBeforeCorrection.longitude * 360.0 / (1<<32)
        return [lon, lat]
    
    def getLonLat(self):
        lat = self.laneProjectionPosition.latitude * 360.0 / (1<<32)
        lon = self.laneProjectionPosition.longitude * 360.0 / (1<<32)
        if checkInvalidLonLat(lon, lat) == False:
            lat = self.carPositionBeforeCorrection.latitude * 360.0 / (1<<32)
            lon = self.carPositionBeforeCorrection.longitude * 360.0 / (1<<32)
        return [lon, lat]
    
    def getLonLatZ(self, withBearing = False):
        lat = self.laneProjectionPosition.latitude * 360.0 / (1<<32)
        lon = self.laneProjectionPosition.longitude * 360.0 / (1<<32)
        z = self.laneProjectionPosition.ellipsoidHigh / 1000.0 # mm -> m
        bearing = self.laneProjectionPosition.laneDirection * 0.01
        if checkInvalidLonLat(lon, lat) == False:
            lat = self.carPositionBeforeCorrection.latitude * 360.0 / (1<<32)
            lon = self.carPositionBeforeCorrection.longitude * 360.0 / (1<<32)
            z = self.carPositionBeforeCorrection.ellipsoidHigh / 1000.0 # mm -> m
            bearing = self.carPositionBeforeCorrection.carDirection * 0.01
        if withBearing:
            return [lon, lat, z, bearing]
        else:
            return [lon, lat, z]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        AnalyzePositionError.__init__(self)
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.timeStampAD = readFunc(int,48)
        self.invalidFlag = readFunc(int,16)
        self.positionValidStatus = readFunc(int,8)
        self.cameraCorrectionFlag = readFunc(int,8)
        self.laneProjectionFlag = readFunc(int,8)
        readFunc(int,8) #reserved (old version)  # todo: It will be delete "MPU入出力データ台帳Gen2向け_20200303"
        readFunc(int,32) #reserved (old version)  # todo: It will be delete "MPU入出力データ台帳Gen2向け_20200303"
        self.carPositionBeforeCorrection = self.CarPositionBeforeCorrection(
            latitude = readFunc(int,32,True),
            longitude = readFunc(int,32,True),
            ellipsoidHigh = readFunc(int,32,True),
            geoidHigh = readFunc(int,32,True),
            carDirection = readFunc(int,16),
            errRadiusLong = readFunc(int,16),
            errRadiusShort = readFunc(int,16),
            errRadiusDirection = readFunc(int,16))
        self.timeStampCameraCorrection = readFunc(int,48)
        self.carPositionAfterCorrection = self.CarPositionAfterCorrection(
            carDirection = readFunc(int,16),
            latitude = readFunc(int,32,True),
            longitude = readFunc(int,32,True),
            ellipsoidHigh = readFunc(int,32,True))
        self.timeStampLaneProjection = readFunc(int,48)
        self.laneProjectionPosition = self.LaneProjectionPosition(
            laneDirection = readFunc(int,16),
            latitude = readFunc(int,32,True),
            longitude = readFunc(int,32,True),
            ellipsoidHigh = readFunc(int,32,True))
        self.assertMessageSize()
        if oldMessage != None:
            self.timeStampAD_old = oldMessage.timeStampAD
            self.timeStampCameraCorrection_old = oldMessage.timeStampCameraCorrection
            self.timeStampLaneProjection_old = oldMessage.timeStampLaneProjection
        else:
            self.timeStampAD_old = 0
            self.timeStampCameraCorrection_old = 0
            self.timeStampLaneProjection_old = 0
                
    def printHeader(self, sheet, row, col, _level = 1):
        sheet.set_row(0, 22.5)
        
        sheet.insert_button(row, 3, {'macro':   "'SmallFit \"A:" + getColumnName(self.commonHeader.columnCount() + 22) + "\"'",
                                    'caption': '-> 狭く表示 <-',
                                    'width':   100,
                                    'height':  30})
        
        sheet.insert_button(row, 6, {'macro':   "'AutoFit \"A:" + getColumnName(self.commonHeader.columnCount() + 22) + "\"'",
                                    'caption': '<- 広く表示 ->',
                                    'width':   100,
                                    'height':  30})
        
        sheet.insert_button(row, self.commonHeader.columnCount()+5, {'macro':   "'makePolyLineScript \"" + 
                                      getCellName(row+3, 1) + "\",\"" + 
                                      getCellName(row+3, self.commonHeader.columnCount()+6) + "\",\"" + 
                                      getCellName(row+3, self.commonHeader.columnCount()+5) + "\"'",
                                    'caption': '↓ 緯経度QGIS描画',
                                    'width':   120,
                                    'height':  30})
        
        sheet.insert_button(row, self.commonHeader.columnCount()+10, {'macro':   "'makeDistributionScript \"" + 
                                      getCellName(row+3, 1) + "\",\"" + 
                                      getCellName(row+3, self.commonHeader.columnCount()+6) + "\",\"" + 
                                      getCellName(row+3, self.commonHeader.columnCount()+5) + "\",\"" + 
                                      getCellName(row+3, self.commonHeader.columnCount()+10) + "\",\"" + 
                                      getCellName(row+3, self.commonHeader.columnCount()+11) + "\",\"" + 
                                      getCellName(row+3, self.commonHeader.columnCount()+12) + "\"'",
                                    'caption': '↓ 誤差QGIS描画',
                                    'width':   120,
                                    'height':  30})
        
        sheet.insert_button(row, self.commonHeader.columnCount()+15, {'macro':   "'makePolyLineScript \"" + 
                                      getCellName(row+3, 1) + "\",\"" + 
                                      getCellName(row+3, self.commonHeader.columnCount()+16) + "\",\"" + 
                                      getCellName(row+3, self.commonHeader.columnCount()+15) + "\"'",
                                    'caption': '↓ 緯経度QGIS描画',
                                    'width':   120,
                                    'height':  30})
        
        sheet.insert_button(row, self.commonHeader.columnCount()+20, {'macro':   "'makePolyLineScript \"" + 
                                      getCellName(row+3, 1) + "\",\"" + 
                                      getCellName(row+3, self.commonHeader.columnCount()+21) + "\",\"" + 
                                      getCellName(row+3, self.commonHeader.columnCount()+20) + "\"'",
                                    'caption': '↓ 緯経度QGIS描画',
                                    'width':   120,
                                    'height':  30})
        
        newCol = col
        sheet.write(row+1, newCol, 'Common Header', sheet.cellFormats('header'))
        merge_cols(sheet, row+1, newCol, self.commonHeader.columnCount(), True)
        newCol += self.commonHeader.columnCount()
        newCol += 6
        sheet.write(row+1, newCol, '自律航法位置情報（カメラ補正前）', sheet.cellFormats('header'))
        merge_cols(sheet, row+1, newCol, 8, True)
        newCol += 8
        newCol += 2
        sheet.write(row+1, newCol, 'カメラ補正後位置情報', sheet.cellFormats('header'))
        merge_cols(sheet, row+1, newCol, 4, True)
        newCol += 4
        newCol += 2
        sheet.write(row+1, newCol, 'レーン投影位置情報', sheet.cellFormats('header'))
        merge_cols(sheet, row+1, newCol, 4, True)
        sheet.set_row(1, 20)
        
        newCol = col
        [_, newCol, _] = self.commonHeader.printHeader(sheet, row+2, newCol)
        
        sheet.write_row(row+2, newCol, [
            '自律航法位置タイムスタンプ[μs]',
            '差分[ms]',
            '無効フラグ',
            '位置有効ステータス',
            'カメラ補正情報有無',
            'レーン投影状態',
            '緯度[deg]', 
            '経度[deg]', 
            '楕円体高度[mm]',
            'ジオイド高[mm]',
            '車両方位[deg]',
            '誤差楕円長径[cm]',
            '誤差楕円短径[cm]',
            '誤差楕円長径方位[deg]',
            'カメラ補正後データタイムスタンプ[μs]',
            '差分[ms]',
            '車両方位[deg]',
            '緯度[deg]',
            '経度[deg]',
            '楕円体高度[mm]',
            'レーン投影後データタイムスタンプ[μs]',
            '差分[ms]',
            'レーン方位[deg]',
            '緯度[deg]',
            '経度[deg]',
            '楕円体高度[mm]'], sheet.cellFormats('header'))
        newCol += 26
         
        sheet.freeze_panes(3, 0)
        sheet.set_row(2, 20)
        sheet.autofilter(2, 0, 2, newCol-1)
        
        return [row+3, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [
            self.timeStampAD,
            (self.timeStampAD - self.timeStampAD_old) / 1000,
            hex(self.invalidFlag),
            self.positionValidStatus,
            self.cameraCorrectionFlag,
            self.laneProjectionFlag,
            self.carPositionBeforeCorrection.latitude * 360.0 / (1<<32),
            self.carPositionBeforeCorrection.longitude * 360.0 / (1<<32),
            self.carPositionBeforeCorrection.ellipsoidHigh,
            self.carPositionBeforeCorrection.geoidHigh,
            self.carPositionBeforeCorrection.carDirection / 100.0,
            self.carPositionBeforeCorrection.errRadiusLong,
            self.carPositionBeforeCorrection.errRadiusShort,
            self.carPositionBeforeCorrection.errRadiusDirection / 100.0,
            self.timeStampCameraCorrection,
            (self.timeStampCameraCorrection - self.timeStampCameraCorrection_old) / 1000,
            self.carPositionAfterCorrection.carDirection / 100.0,
            self.carPositionAfterCorrection.latitude * 360.0 / (1<<32),
            self.carPositionAfterCorrection.longitude * 360.0 / (1<<32),
            self.carPositionAfterCorrection.ellipsoidHigh,
            self.timeStampLaneProjection,
            (self.timeStampLaneProjection - self.timeStampLaneProjection_old) / 1000,
            self.laneProjectionPosition.laneDirection / 100.0,
            self.laneProjectionPosition.latitude * 360.0 / (1<<32),
            self.laneProjectionPosition.longitude * 360.0 / (1<<32),
            self.laneProjectionPosition.ellipsoidHigh])
            
        return [row+1, 0, []]
     
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
        chart = book.add_chart({'type': 'line'})
        chart.set_title({
            'name': '自律航法位置タイムスタンプ[μs]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'values':     "='{0}'!$K$1:$K${1}".format(sheet.name, totalRows)})
        sheet.insert_chart('C18', chart)
        
        chart = book.add_chart({'type': 'scatter'})
        chart.set_title({
            'name': '自律航法位置タイムスタンプ 差分[ms]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'name': '間隔[ms]',
            'categories': "='{0}'!$A$1:$A${1}".format(sheet.name, totalRows),
            'values':     "='{0}'!$L$1:$L${1}".format(sheet.name, totalRows)})
        chart.set_y_axis({'min': 0, 'max': 100})
        sheet.insert_chart('J18', chart)
        
        chart = book.add_chart({'type': 'line'})
        chart.set_title({
            'name': 'カメラ補正後データタイムスタンプ[μs]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'values':     "='{0}'!$Y$1:$Y${1}".format(sheet.name, totalRows)})
        sheet.insert_chart('C32', chart)
        
        chart = book.add_chart({'type': 'scatter'})
        chart.set_title({
            'name': 'カメラ補正後データタイムスタンプ 差分[ms]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'name': '間隔[ms]',
            'categories': "='{0}'!$A$1:$A${1}".format(sheet.name, totalRows),
            'values':     "='{0}'!$Z$1:$Z${1}".format(sheet.name, totalRows)})
        chart.set_y_axis({'min': 0, 'max': 200})
        sheet.insert_chart('J32', chart)
        
        chart = book.add_chart({'type': 'line'})
        chart.set_title({
            'name': 'レーン投影後データタイムスタンプ[μs]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'values':     "='{0}'!$AE$1:$AE${1}".format(sheet.name, totalRows)})
        sheet.insert_chart('C46', chart)
        
        chart = book.add_chart({'type': 'scatter'})
        chart.set_title({
            'name': 'レーン投影後データタイムスタンプ 差分[ms]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'name': '間隔[ms]',
            'categories': "='{0}'!$A$1:$A${1}".format(sheet.name, totalRows),
            'values':     "='{0}'!$AF$1:$AF${1}".format(sheet.name, totalRows)})
        chart.set_y_axis({'min': 0, 'max': 100})
        sheet.insert_chart('J46', chart)
        
    class LayerType(Enum):
        CarPosition_CarPos = 3
        CarPosition_LaneProj = 5
        CarPosition_CameraPos = 6
        CarPosition_ErrProb = 15
        CarPosition_ErrDist = 19
    
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.CarPosition_CarPos:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(200,200,200))
            symbol.setWidth(0.6)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
            
        elif layerType == cls.LayerType.CarPosition_CameraPos:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(0,255,255))
            symbol.setWidth(0.8)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.CarPosition_LaneProj:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(0,0,255))
            symbol.setWidth(0.8)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
            
        elif layerType == cls.LayerType.CarPosition_ErrProb or layerType == cls.LayerType.CarPosition_ErrDist:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(100,100,255))
            symbol.setWidth(1)
            symbol.setOpacity(0.5)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
        
        else:
            return None
    
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if realTimeMode == DrawMode.FullDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw:
            newLayer_laneProj = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&field=bearing:double&index=yes',name+'(laneProj)','memory')
            newLayer_laneProj = self.SetLayerStyle(self.LayerType.CarPosition_LaneProj, newLayer_laneProj)
        elif realTimeMode == DrawMode.QGIS_RealTimeDraw:
            newLayer_laneProj = iface_obj.addVectorLayer('LineString?crs=epsg:4612',name+'(laneProj)','memory')
            newLayer_laneProj = self.SetLayerStyle(self.LayerType.CarPosition_LaneProj, newLayer_laneProj)
        
        #realTime描画でない場合のみ、カメラ補正位置を描画する
        if realTimeMode == DrawMode.FullDraw:
            newLayer_cameraPos = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&field=bearing:double&index=yes',name+'(camera)','memory')
            newLayer_cameraPos = self.SetLayerStyle(self.LayerType.CarPosition_CameraPos, newLayer_cameraPos)
        
        if realTimeMode == DrawMode.FullDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw:
            newLayer_carPos = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&field=bearing:double&index=yes',name+'(carPos)','memory')
        elif realTimeMode == DrawMode.QGIS_RealTimeDraw:
            newLayer_carPos = iface_obj.addVectorLayer('LineString?crs=epsg:4612',name+'(carPos)','memory')
        newLayer_carPos = self.SetLayerStyle(self.LayerType.CarPosition_CarPos, newLayer_carPos)

        if realTimeMode == DrawMode.FullDraw:
            newLayer_errProb = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&field=LongAxis[cm]:double&field=ShortAxis[cm]:double&field=Theta[Deg]:double&index=yes',name+'(errProb)','memory')
            newLayer_errProb = self.SetLayerStyle(self.LayerType.CarPosition_ErrProb, newLayer_errProb)
            if self.positionError != None:
                newLayer_errDist = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=errorDistance[m]:double&index=yes',name+'(errDist)','memory')
                newLayer_errDist = self.SetLayerStyle(self.LayerType.CarPosition_ErrDist, newLayer_errDist) 
            
        elif realTimeMode == DrawMode.QGIS_RealTimeDraw:
            newLayer_errProb = iface_obj.addVectorLayer('LineString?crs=epsg:4612',name+'(errDist)','memory')
            newLayer_errProb = self.SetLayerStyle(self.LayerType.CarPosition_ErrProb, newLayer_errProb)
        
        #realTime描画でない場合のみ、カメラ補正位置を描画する
        if realTimeMode == DrawMode.FullDraw:
            if self.positionError != None:
                return [newLayer_errProb, newLayer_carPos, newLayer_cameraPos, newLayer_laneProj, newLayer_errDist]
            else:
                return [newLayer_errProb, newLayer_carPos, newLayer_cameraPos, newLayer_laneProj]
        elif realTimeMode == DrawMode.QGIS_RealTimeDraw:
            return [newLayer_errProb, newLayer_carPos, newLayer_laneProj]
        else:
            return [newLayer_carPos, newLayer_laneProj]
        
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        old = self.oldMessage
        layer_err = None
        layer_carPos = None
        layer_cameraPos = None
        layer_laneProj = None
        layer_ed = None
        for layerListItem in layerList:
            if layerListItem[1] == CarPositionMessage.LayerType.CarPosition_ErrProb.value:
                layer_err = layerListItem[0]
            elif layerListItem[1] == CarPositionMessage.LayerType.CarPosition_CarPos.value:
                layer_carPos  = layerListItem[0]
            elif layerListItem[1] == CarPositionMessage.LayerType.CarPosition_CameraPos.value:
                layer_cameraPos = layerListItem[0]
            elif layerListItem[1] == CarPositionMessage.LayerType.CarPosition_LaneProj.value:
                layer_laneProj  = layerListItem[0]
            elif layerListItem[1] == CarPositionMessage.LayerType.CarPosition_ErrDist.value:
                layer_ed = layerListItem[0]
        
        scaleRate = 0.00000009
        lat = self.carPositionBeforeCorrection.latitude * 360.0 / (1<<32)
        lon = self.carPositionBeforeCorrection.longitude * 360.0 / (1<<32)
        z = self.carPositionBeforeCorrection.ellipsoidHigh / 1000.0 #mm -> m
        if checkInvalidLonLat(lon, lat) == True:
            if layer_err != None:
                feature = QgsFeature()
                eclipsePointList = []
                PointList = [
                    QDateTime(self.commonHeader.logTime),
                    lon,
                    lat,
                    self.carPositionBeforeCorrection.errRadiusLong,
                    self.carPositionBeforeCorrection.errRadiusShort,
                    -(self.carPositionBeforeCorrection.errRadiusDirection / 100.0) + 90] # 北が0度で、時計回りにしているため、XY座標に変換
                for t in range(0, 361, 20):
                    w = math.radians(t)
                    th = math.radians(PointList[5])
                    eclipsePointList.append(QgsPoint(
                        PointList[1] + scaleRate*(PointList[3]*math.cos(w)*math.cos(th) - PointList[4]*math.sin(w)*math.sin(th)),
                        PointList[2] + scaleRate*(PointList[3]*math.cos(w)*math.sin(th) + PointList[4]*math.sin(w)*math.cos(th)),
                        z
                    ))
                feature.setGeometry(QgsGeometry.fromPolyline(eclipsePointList))
                if realTimeMode == DrawMode.FullDraw:
                    feature.setAttributes(PointList)
                layer_err.dataProvider().addFeatures( [feature] )
                
            if layer_ed != None and self.positionError != None and self.positionError.distance > 0:
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromMultiPolylineXY([[QgsPointXY(self.positionError.foot[0], self.positionError.foot[1]), QgsPointXY(lon, lat)]]))
                feature.setAttributes([QDateTime(self.commonHeader.logTime), self.positionError.distance])
                layer_ed.dataProvider().addFeatures( [feature] )
        
        if old != None:
            if layer_carPos != None:
                lat = self.carPositionBeforeCorrection.latitude * 360.0 / (1<<32)
                lon = self.carPositionBeforeCorrection.longitude * 360.0 / (1<<32)
                z = self.carPositionBeforeCorrection.ellipsoidHigh / 1000.0 #mm -> m
                oldLat = old.carPositionBeforeCorrection.latitude * 360.0 / (1<<32)
                oldLon = old.carPositionBeforeCorrection.longitude * 360.0 / (1<<32)
                oldZ = old.carPositionBeforeCorrection.ellipsoidHigh / 1000.0 #mm -> m
                if checkInvalidLonLat(lon, lat, oldLon, oldLat, allowSamePoint = True) == True:
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline(
                        [QgsPoint(oldLon, oldLat, oldZ), QgsPoint(lon, lat, z)] ))
                    if realTimeMode == DrawMode.FullDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw:
                        feature.setAttributes([QDateTime(self.commonHeader.logTime), lon, lat, self.carPositionBeforeCorrection.carDirection / 100.0])
                    layer_carPos.dataProvider().addFeatures( [feature] )
            
            if layer_cameraPos != None:
                lat = self.carPositionAfterCorrection.latitude * 360.0 / (1<<32)
                lon = self.carPositionAfterCorrection.longitude * 360.0 / (1<<32)
                z = self.carPositionAfterCorrection.ellipsoidHigh / 1000.0 #mm -> m
                oldLat = old.carPositionAfterCorrection.latitude * 360.0 / (1<<32)
                oldLon = old.carPositionAfterCorrection.longitude * 360.0 / (1<<32)
                oldZ = old.carPositionAfterCorrection.ellipsoidHigh / 1000.0 #mm -> m
                if checkInvalidLonLat(lon, lat, oldLon, oldLat, allowSamePoint = True) == True:
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline(
                        [QgsPoint(oldLon, oldLat, oldZ), QgsPoint(lon, lat, z)] ))
                    feature.setAttributes([QDateTime(self.commonHeader.logTime), lon, lat, self.carPositionAfterCorrection.carDirection / 100.0])
                    layer_cameraPos.dataProvider().addFeatures( [feature] )
            
            if layer_laneProj != None:
                lat = self.laneProjectionPosition.latitude * 360.0 / (1<<32)
                lon = self.laneProjectionPosition.longitude * 360.0 / (1<<32)
                z = self.laneProjectionPosition.ellipsoidHigh / 1000.0 #mm -> m
                oldLat = old.laneProjectionPosition.latitude * 360.0 / (1<<32)
                oldLon = old.laneProjectionPosition.longitude * 360.0 / (1<<32)
                oldZ = old.laneProjectionPosition.ellipsoidHigh / 1000.0 #mm -> m
                if checkInvalidLonLat(lon, lat, oldLon, oldLat, allowSamePoint = True) == True:
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline(
                        [QgsPoint(oldLon, oldLat, oldZ), QgsPoint(lon, lat, z)] ))
                    if realTimeMode == DrawMode.FullDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw:
                        feature.setAttributes([QDateTime(self.commonHeader.logTime), lon, lat, self.laneProjectionPosition.laneDirection / 100.0])
                    layer_laneProj.dataProvider().addFeatures( [feature] )
            

#-----------------------------------------------#
#----   IVIDataStatus                      ----#
#-----------------------------------------------#
class IVIDataStatus(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.dataReceiveStatus = readFunc(int,32)
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write_row(row, col, [
            'IVIデータ受信状態',
            '(Lat-Lon)',
            '(Position)',
            '(Segment)',
            '(Stub)',
            '(Profile Long)'], sheet.cellFormats('header'))
        col += 6
        
        sheet.write(row, col, ' * パケット揺らぎエラー、パケットロストエラー、チェックサムエラー')
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [
            (hex(self.dataReceiveStatus)),
            format(((self.dataReceiveStatus & 0x000F0000) >> 16), '03b'),
            format(((self.dataReceiveStatus & 0x0000F000) >> 12), '03b'),
            format(((self.dataReceiveStatus & 0x00000F00) >> 8), '03b'),
            format(((self.dataReceiveStatus & 0x000000F0) >> 4), '03b'),
            format(((self.dataReceiveStatus & 0x0000000F)), '03b')])
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    

#-----------------------------------------------#
#----   MapLinkageStatus                    ----#
#-----------------------------------------------#
class MapLinkageStatus(Message):
    StatusDic = {0:'未返還(0)', 1:'変換成功(1)', 2:'変換失敗(2)'}
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.status = readFunc(int,32)
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write(row, col, 'MapLinkage状態', sheet.cellFormats('header'))
        col += 1
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write(row, col, MapLinkageStatus.StatusDic.get(self.status, '[error]'))
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    

#-----------------------------------------------#
#----(ADAS-FrCamera) CAM InfrastructureList ----#
#-----------------------------------------------#
class CAMInfrastructureList(Message):
    def __init__(self, index, time, definitionID, data):
        #これはMAPECU-FrCamera間のメッセージであるため、E2E Header(12byte)を除去し、疑似Common Headerをつける
        data = struct.pack('>I', len(data)-12+20) + b'\x00\x00\x00\x00\x00\x00\x00\x00' + struct.pack('>I', definitionID) + b'\x00\x00\x00\x00' + data[12:]
        super().__init__(index, time, definitionID, data)
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue        
        self.CamCrossRoadDetected = readFunc(int, 8, sign=False)
        self.CamDistToCrossRoad = readFunc(float, 32, sign=True)
        self.CamCorssRoadConfidence = readFunc(int, 8, sign=False)
        self.CamRoundaboutDetected = readFunc(int, 8, sign=False)
        self.CamDistToRoundabout = readFunc(float, 32, sign=True)
        self.CamRoundaboutConfidence = readFunc(int, 8, sign=False)
        self.CamTollboothDetected = readFunc(int, 8, sign=False)
        self.CamDistToTollbooth = readFunc(float, 32, sign=True)
        self.CamTollboothConfidence = readFunc(int, 8, sign=False)
        self.CamNbTFLDetected = readFunc(int, 8, sign=False)
        self.CamNearestTFLDistance = readFunc(float, 32, sign=True)
        self.CamCycLaneDetected = readFunc(int, 8, sign=False)
        self.CamDisToCycLane = readFunc(float, 32, sign=True)
        self.CamPedAreaDetected = readFunc(int, 8, sign=False)
        self.CamDistToPedArea = readFunc(float, 32, sign=True)
        self.CamCycAreaDetected = readFunc(int, 8, sign=False)
        self.CamDisToCycArea = readFunc(float, 32, sign=True)
        self.CamCycPathDetected = readFunc(int, 8, sign=False)
        self.CamDistToCycPath = readFunc(float, 32, sign=True)
        self.CamCrossWalkDetected = readFunc(int, 8, sign=False)
        self.CamDistToCrossWalk = readFunc(float, 32, sign=True)
        self.CamConstructionArea = readFunc(int, 8, sign=False)
        self.CamDayTimeIndicator = readFunc(int, 8, sign=False)
        self.CamLaneCrossingLeft = readFunc(int, 8, sign=False)
        self.CamLaneCrossingRight = readFunc(int, 8, sign=False)
        self.CamTimeToLeftLaneCrossing = readFunc(float, 32, sign=True)
        self.CamTimeToRightLaneCrossing = readFunc(float, 32, sign=True)
        self.CamRoadType = readFunc(int, 8, sign=False)
        self.CamRoadTypeConfidence = readFunc(int, 8, sign=False)
        self.CamHighWayExitDetected = readFunc(int, 8, sign=False)
        self.CamHighWayExitConfidence = readFunc(int, 8, sign=False)
        self.CamHighWayExitLeftConfidence = readFunc(int, 8, sign=False)
        self.CamHighWayExitRightConfidence = readFunc(int, 8, sign=False)
        self.CamHighWayExitDistance = readFunc(float, 32, sign=True)
        self.CamHighWayExitDistanceConfidence = readFunc(int, 8, sign=False)
        self.CamHPPOffset = readFunc(float, 32, sign=True)
        self.CamHPPOffsetSTD = readFunc(float, 32, sign=True)
        self.CamHPPYawAngle = readFunc(float, 32, sign=True)
        self.CamHPPYawAngleSTD = readFunc(float, 32, sign=True)
        self.CamHPPCurvature = readFunc(float, 32, sign=True)
        self.CamHPPCurvatureSTD = readFunc(float, 32, sign=True)
        self.CamHPPdCurvature = readFunc(float, 32, sign=True)
        self.CamHPPdCurvatureSTD = readFunc(float, 32, sign=True)
        self.CamHPPLaneWidthEstimation = readFunc(float, 32, sign=True)
        self.NotUsed4 = readFunc(int, 8, sign=False)
        self.NotUsed5 = readFunc(int, 16, sign=False)
        self.CamHPPConfidence = readFunc(int, 8, sign=False)
        self.Lane_Assignment_Host_Index_near = readFunc(float, 32, sign=True)
        self.Lane_Assignment_Host_Index_far = readFunc(float, 32, sign=True)
        self.NumOfLanes_near = readFunc(float, 32, sign=True)
        self.NumOfLanes_far = readFunc(float, 32, sign=True)
        self.CamStopRoadLineOnPathDetection = readFunc(int, 8, sign=False)
        self.CamStopRoadLineOnPathDistance = readFunc(float, 32, sign=True)
        self.CamYieldRoadLineOnPathDetection = readFunc(int, 8, sign=False)
        self.CamYieldRoadLineOnPathDistance = readFunc(float, 32, sign=True)
        self.CamStopRoadSignOnPathDetection = readFunc(int, 8, sign=False)
        self.CamStopRoadSignOnPathDistance = readFunc(float, 32, sign=True)
        self.CamYieldRoadSignOnPathDetection = readFunc(int, 8, sign=False)
        self.CamYieldRoadSignOnPathDistance = readFunc(float, 32, sign=True)
        self.Cam_MainObjectID = readFunc(int, 8, sign=False)
        self.Cam_TFL_Information_Status = readFunc(int, 8, sign=False)
        self.Cam_TFL_TimeToCollision = readFunc(float, 32, sign=True)
        self.Cam_TFL_TimeToCollisionDecision = readFunc(int, 8, sign=False)
        self.Cam_TFL_SuppressionReasonDriver = readFunc(int, 8, sign=False)
        self.Cam_TFL_SuppressionReason = readFunc(int, 8, sign=False)
        self.Cam_StopSign_Information_Status = readFunc(int, 8, sign=False)
        self.Cam_StopSignTimeToCollision = readFunc(float, 32, sign=True)
        self.Cam_StopSignWarningSuppression = readFunc(int, 8, sign=False)
        self.Cam_StopLineDist = readFunc(float, 32, sign=True)
        self.Cam_StopLineValid = readFunc(int, 8, sign=False)
        self.Cam_JNC_Status = readFunc(int, 8, sign=False)
        self.CamLeftLineID = readFunc(int, 32, sign=False)
        self.CamLeftLineQuality = readFunc(int, 8, sign=False)
        self.CamLeftLineStartViewRange = readFunc(float, 32, sign=True)
        self.CamLeftLineStartViewRangeVAR = readFunc(float, 32, sign=True)
        self.CamLeftLineEndViewRange = readFunc(float, 32, sign=True)
        self.CamLeftLineEndViewRangeVAR = readFunc(float, 32, sign=True)
        self.CamLeftLineMarkWidth = readFunc(float, 32, sign=True)
        self.CamLeftLineType = readFunc(int, 8, sign=False)
        self.CamLeftLineColor = readFunc(int, 8, sign=False)
        self.CamLeftLineExistenceProb = readFunc(int, 8, sign=False)
        self.CamLeftLineOffset = readFunc(float, 32, sign=True)
        self.CamLeftLineOffsetVAR = readFunc(float, 32, sign=True)
        self.CamLeftLineYawAngle = readFunc(float, 32, sign=True)
        self.CamLeftLineYawAngleVAR = readFunc(float, 32, sign=True)
        self.CamLeftLineCurvature = readFunc(float, 32, sign=True)
        self.CamLeftLineCurvatureVAR = readFunc(float, 32, sign=True)
        self.CamLeftLineCurvatureRate = readFunc(float, 32, sign=True)
        self.CamLeftLineCurvatureRateVAR = readFunc(float, 32, sign=True)
        self.CamRightLineID = readFunc(int, 32, sign=False)
        self.CamRightLineQuality = readFunc(int, 8, sign=False)
        self.CamRightLineStartViewRange = readFunc(float, 32, sign=True)
        self.CamRightLineStartViewRangeVAR = readFunc(float, 32, sign=True)
        self.CamRightLineEndViewRange = readFunc(float, 32, sign=True)
        self.CamRightLineEndViewRangeVAR = readFunc(float, 32, sign=True)
        self.CamRightLineMarkWidth = readFunc(float, 32, sign=True)
        self.CamRightLineType = readFunc(int, 8, sign=False)
        self.CamRightLineColor = readFunc(int, 8, sign=False)
        self.CamRightLineExistenceProb = readFunc(int, 8, sign=False)
        self.CamLeftLineASIL = readFunc(int, 8, sign=False)
        self.CamRightLineASIL = readFunc(int, 8, sign=False)
        self.NotUsed3 = readFunc(int, 8, sign=False)
        self.CamRightLineOffset = readFunc(float, 32, sign=True)
        self.CamRightLineOffsetVAR = readFunc(float, 32, sign=True)
        self.CamRightLineYawAngle = readFunc(float, 32, sign=True)
        self.CamRightLineYawAngleVAR = readFunc(float, 32, sign=True)
        self.CamRightLineCurvature = readFunc(float, 32, sign=True)
        self.CamRightLineCurvatureVAR = readFunc(float, 32, sign=True)
        self.CamRightLineCurvatureRate = readFunc(float, 32, sign=True)
        self.CamRightLineCurvatureRateVAR = readFunc(float, 32, sign=True)
        self.CamLeftLeftLineID = readFunc(int, 32, sign=False)
        self.CamLeftLeftLineQuality = readFunc(int, 8, sign=False)
        self.CamLeftLeftLineStartViewRange = readFunc(float, 32, sign=True)
        self.CamLeftLeftLineStartViewRangeVAR = readFunc(float, 32, sign=True)
        self.CamLeftLeftLineEndViewRange = readFunc(float, 32, sign=True)
        self.CamLeftLeftLineEndViewRangeVAR = readFunc(float, 32, sign=True)
        self.CamLeftLeftLineMarkWidth = readFunc(float, 32, sign=True)
        self.CamLeftLeftLineType = readFunc(int, 8, sign=False)
        self.CamLeftLeftLineExistenceProb = readFunc(float, 32, sign=True)
        self.CamLeftLeftLineOffset = readFunc(float, 32, sign=True)
        self.CamLeftLeftLineOffsetVAR = readFunc(float, 32, sign=True)
        self.CamLeftLeftLineYawAngle = readFunc(float, 32, sign=True)
        self.CamLeftLeftLineYawAngleVAR = readFunc(float, 32, sign=True)
        self.CamLeftLeftLineCurvature = readFunc(float, 32, sign=True)
        self.CamLeftLeftLineCurvatureVAR = readFunc(float, 32, sign=True)
        self.CamLeftLeftLineCurvatureRate = readFunc(float, 32, sign=True)
        self.CamLeftLeftLineCurvatureRateVAR = readFunc(float, 32, sign=True)
        self.CamRightRightLineID = readFunc(int, 32, sign=False)
        self.CamRightRightLineQuality = readFunc(int, 8, sign=False)
        self.CamRightRightLineStartViewRange = readFunc(float, 32, sign=True)
        self.CamRightRightLineEndViewRange = readFunc(float, 32, sign=True)
        self.CamRightRightLineMarkWidth = readFunc(float, 32, sign=True)
        self.CamRightRightLineType = readFunc(int, 8, sign=False)
        self.CamRightRightLineExistenceProb = readFunc(float, 32, sign=True)
        self.CamRightRightLineOffset = readFunc(float, 32, sign=True)
        self.CamRightRightLineOffsetVAR = readFunc(float, 32, sign=True)
        self.CamRightRightLineYawAngle = readFunc(float, 32, sign=True)
        self.CamRightRightLineYawAngleVAR = readFunc(float, 32, sign=True)
        self.CamRightRightLineCurvature = readFunc(float, 32, sign=True)
        self.CamRightRightLineCurvatureVAR = readFunc(float, 32, sign=True)
        self.CamRightRightLineCurvatureRate = readFunc(float, 32, sign=True)
        self.CamRightRightLineCurvatureRateVAR = readFunc(float, 32, sign=True)
        self.CamTimestampLeftLine = readFunc(int, 32, sign=False)
        self.CamTimestampRightLine = readFunc(int, 32, sign=False)
        self.CamTimestampLeftLeftLine = readFunc(int, 32, sign=False)
        self.CamTimestampRightRightLine = readFunc(int, 32, sign=False)
        self.Cam_Number_Of_Lines = readFunc(int, 8, sign=False)
        self.Cam_LDW_Warning = readFunc(int, 8, sign=False)
        self.Cam_LDW_NRTA_Reasons = readFunc(int, 8, sign=False)
        self.Cam_LDW_RTA = readFunc(int, 8, sign=False)
        self.Cam_LDW_Inhibit_Reasons = readFunc(int, 8, sign=False)
        self.Cam_CarPoolLane_Offset = readFunc(float, 32, sign=True)
        self.Cam_CarPoolLane_Detect = readFunc(int, 8, sign=False)
        self.Cam_SnowOnRoadDetected = readFunc(int, 8, sign=False)
        self.Cam_TripleLineMark_Confidence = readFunc(int, 8, sign=False)
        self.Cam_LeftTripleLineMarkWidth = readFunc(float, 32, sign=True)
        self.Cam_RightTripleLineMarkWidth = readFunc(float, 32, sign=True)
        self.CamRightRightLineStartViewRangeVAR = readFunc(float, 32, sign=True)
        self.CamRightRightLineEndViewRangeVAR = readFunc(float, 32, sign=True)

    def printHeader(self, sheet, row, col, _level = 1):
        [_, col, _] = self.commonHeader.printHeader(sheet, row, col)
        
        titleStr = [
            'CamCrossRoadDetected',
            'CamDistToCrossRoad',
            'CamCorssRoadConfidence',
            'CamRoundaboutDetected',
            'CamDistToRoundabout',
            'CamRoundaboutConfidence',
            'CamTollboothDetected',
            'CamDistToTollbooth',
            'CamTollboothConfidence',
            'CamNbTFLDetected',
            'CamNearestTFLDistance',
            'CamCycLaneDetected',
            'CamDisToCycLane',
            'CamPedAreaDetected',
            'CamDistToPedArea',
            'CamCycAreaDetected',
            'CamDisToCycArea',
            'CamCycPathDetected',
            'CamDistToCycPath',
            'CamCrossWalkDetected',
            'CamDistToCrossWalk',
            'CamConstructionArea',
            'CamDayTimeIndicator',
            'CamLaneCrossingLeft',
            'CamLaneCrossingRight',
            'CamTimeToLeftLaneCrossing',
            'CamTimeToRightLaneCrossing',
            'CamRoadType',
            'CamRoadTypeConfidence',
            'CamHighWayExitDetected',
            'CamHighWayExitConfidence',
            'CamHighWayExitLeftConfidence',
            'CamHighWayExitRightConfidence',
            'CamHighWayExitDistance',
            'CamHighWayExitDistanceConfidence',
            'CamHPPOffset',
            'CamHPPOffsetSTD',
            'CamHPPYawAngle',
            'CamHPPYawAngleSTD',
            'CamHPPCurvature',
            'CamHPPCurvatureSTD',
            'CamHPPdCurvature',
            'CamHPPdCurvatureSTD',
            'CamHPPLaneWidthEstimation',
            'NotUsed4',
            'NotUsed5',
            'CamHPPConfidence',
            'Lane_Assignment_Host_Index_near',
            'Lane_Assignment_Host_Index_far',
            'NumOfLanes_near',
            'NumOfLanes_far',
            'CamStopRoadLineOnPathDetection',
            'CamStopRoadLineOnPathDistance',
            'CamYieldRoadLineOnPathDetection',
            'CamYieldRoadLineOnPathDistance',
            'CamStopRoadSignOnPathDetection',
            'CamStopRoadSignOnPathDistance',
            'CamYieldRoadSignOnPathDetection',
            'CamYieldRoadSignOnPathDistance',
            'Cam_MainObjectID',
            'Cam_TFL_Information_Status',
            'Cam_TFL_TimeToCollision',
            'Cam_TFL_TimeToCollisionDecision',
            'Cam_TFL_SuppressionReasonDriver',
            'Cam_TFL_SuppressionReason',
            'Cam_StopSign_Information_Status',
            'Cam_StopSignTimeToCollision',
            'Cam_StopSignWarningSuppression',
            'Cam_StopLineDist',
            'Cam_StopLineValid',
            'Cam_JNC_Status',
            'CamLeftLineID',
            'CamLeftLineQuality',
            'CamLeftLineStartViewRange',
            'CamLeftLineStartViewRangeVAR',
            'CamLeftLineEndViewRange',
            'CamLeftLineEndViewRangeVAR',
            'CamLeftLineMarkWidth',
            'CamLeftLineType',
            'CamLeftLineColor',
            'CamLeftLineExistenceProb',
            'CamLeftLineOffset',
            'CamLeftLineOffsetVAR',
            'CamLeftLineYawAngle',
            'CamLeftLineYawAngleVAR',
            'CamLeftLineCurvature',
            'CamLeftLineCurvatureVAR',
            'CamLeftLineCurvatureRate',
            'CamLeftLineCurvatureRateVAR',
            'CamRightLineID',
            'CamRightLineQuality',
            'CamRightLineStartViewRange',
            'CamRightLineStartViewRangeVAR',
            'CamRightLineEndViewRange',
            'CamRightLineEndViewRangeVAR',
            'CamRightLineMarkWidth',
            'CamRightLineType',
            'CamRightLineColor',
            'CamRightLineExistenceProb',
            'CamLeftLineASIL',
            'CamRightLineASIL',
            'NotUsed3',
            'CamRightLineOffset',
            'CamRightLineOffsetVAR',
            'CamRightLineYawAngle',
            'CamRightLineYawAngleVAR',
            'CamRightLineCurvature',
            'CamRightLineCurvatureVAR',
            'CamRightLineCurvatureRate',
            'CamRightLineCurvatureRateVAR',
            'CamLeftLeftLineID',
            'CamLeftLeftLineQuality',
            'CamLeftLeftLineStartViewRange',
            'CamLeftLeftLineStartViewRangeVAR',
            'CamLeftLeftLineEndViewRange',
            'CamLeftLeftLineEndViewRangeVAR',
            'CamLeftLeftLineMarkWidth',
            'CamLeftLeftLineType',
            'CamLeftLeftLineExistenceProb',
            'CamLeftLeftLineOffset',
            'CamLeftLeftLineOffsetVAR',
            'CamLeftLeftLineYawAngle',
            'CamLeftLeftLineYawAngleVAR',
            'CamLeftLeftLineCurvature',
            'CamLeftLeftLineCurvatureVAR',
            'CamLeftLeftLineCurvatureRate',
            'CamLeftLeftLineCurvatureRateVAR',
            'CamRightRightLineID',
            'CamRightRightLineQuality',
            'CamRightRightLineStartViewRange',
            'CamRightRightLineEndViewRange',
            'CamRightRightLineMarkWidth',
            'CamRightRightLineType',
            'CamRightRightLineExistenceProb',
            'CamRightRightLineOffset',
            'CamRightRightLineOffsetVAR',
            'CamRightRightLineYawAngle',
            'CamRightRightLineYawAngleVAR',
            'CamRightRightLineCurvature',
            'CamRightRightLineCurvatureVAR',
            'CamRightRightLineCurvatureRate',
            'CamRightRightLineCurvatureRateVAR',
            'CamTimestampLeftLine',
            'CamTimestampRightLine',
            'CamTimestampLeftLeftLine',
            'CamTimestampRightRightLine',
            'Cam_Number_Of_Lines',
            'Cam_LDW_Warning',
            'Cam_LDW_NRTA_Reasons',
            'Cam_LDW_RTA',
            'Cam_LDW_Inhibit_Reasons',
            'Cam_CarPoolLane_Offset',
            'Cam_CarPoolLane_Detect',
            'Cam_SnowOnRoadDetected',
            'Cam_TripleLineMark_Confidence',
            'Cam_LeftTripleLineMarkWidth',
            'Cam_RightTripleLineMarkWidth',
            'CamRightRightLineStartViewRangeVAR',
            'CamRightRightLineEndViewRangeVAR',
            ]
        
        sheet.write_row(row, col, titleStr, sheet.cellFormats('header'))
        col += len(titleStr)
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        
        sheet.write_row(row, col, [
            self.CamCrossRoadDetected,
            self.CamDistToCrossRoad,
            self.CamCorssRoadConfidence,
            self.CamRoundaboutDetected,
            self.CamDistToRoundabout,
            self.CamRoundaboutConfidence,
            self.CamTollboothDetected,
            self.CamDistToTollbooth,
            self.CamTollboothConfidence,
            self.CamNbTFLDetected,
            self.CamNearestTFLDistance,
            self.CamCycLaneDetected,
            self.CamDisToCycLane,
            self.CamPedAreaDetected,
            self.CamDistToPedArea,
            self.CamCycAreaDetected,
            self.CamDisToCycArea,
            self.CamCycPathDetected,
            self.CamDistToCycPath,
            self.CamCrossWalkDetected,
            self.CamDistToCrossWalk,
            self.CamConstructionArea,
            self.CamDayTimeIndicator,
            self.CamLaneCrossingLeft,
            self.CamLaneCrossingRight,
            self.CamTimeToLeftLaneCrossing,
            self.CamTimeToRightLaneCrossing,
            self.CamRoadType,
            self.CamRoadTypeConfidence,
            self.CamHighWayExitDetected,
            self.CamHighWayExitConfidence,
            self.CamHighWayExitLeftConfidence,
            self.CamHighWayExitRightConfidence,
            self.CamHighWayExitDistance,
            self.CamHighWayExitDistanceConfidence,
            self.CamHPPOffset,
            self.CamHPPOffsetSTD,
            self.CamHPPYawAngle,
            self.CamHPPYawAngleSTD,
            self.CamHPPCurvature,
            self.CamHPPCurvatureSTD,
            self.CamHPPdCurvature,
            self.CamHPPdCurvatureSTD,
            self.CamHPPLaneWidthEstimation,
            self.NotUsed4,
            self.NotUsed5,
            self.CamHPPConfidence,
            self.Lane_Assignment_Host_Index_near,
            self.Lane_Assignment_Host_Index_far,
            self.NumOfLanes_near,
            self.NumOfLanes_far,
            self.CamStopRoadLineOnPathDetection,
            self.CamStopRoadLineOnPathDistance,
            self.CamYieldRoadLineOnPathDetection,
            self.CamYieldRoadLineOnPathDistance,
            self.CamStopRoadSignOnPathDetection,
            self.CamStopRoadSignOnPathDistance,
            self.CamYieldRoadSignOnPathDetection,
            self.CamYieldRoadSignOnPathDistance,
            self.Cam_MainObjectID,
            self.Cam_TFL_Information_Status,
            self.Cam_TFL_TimeToCollision,
            self.Cam_TFL_TimeToCollisionDecision,
            self.Cam_TFL_SuppressionReasonDriver,
            self.Cam_TFL_SuppressionReason,
            self.Cam_StopSign_Information_Status,
            self.Cam_StopSignTimeToCollision,
            self.Cam_StopSignWarningSuppression,
            self.Cam_StopLineDist,
            self.Cam_StopLineValid,
            self.Cam_JNC_Status,
            self.CamLeftLineID,
            self.CamLeftLineQuality,
            self.CamLeftLineStartViewRange,
            self.CamLeftLineStartViewRangeVAR,
            self.CamLeftLineEndViewRange,
            self.CamLeftLineEndViewRangeVAR,
            self.CamLeftLineMarkWidth,
            self.CamLeftLineType,
            self.CamLeftLineColor,
            self.CamLeftLineExistenceProb,
            self.CamLeftLineOffset,
            self.CamLeftLineOffsetVAR,
            self.CamLeftLineYawAngle,
            self.CamLeftLineYawAngleVAR,
            self.CamLeftLineCurvature,
            self.CamLeftLineCurvatureVAR,
            self.CamLeftLineCurvatureRate,
            self.CamLeftLineCurvatureRateVAR,
            self.CamRightLineID,
            self.CamRightLineQuality,
            self.CamRightLineStartViewRange,
            self.CamRightLineStartViewRangeVAR,
            self.CamRightLineEndViewRange,
            self.CamRightLineEndViewRangeVAR,
            self.CamRightLineMarkWidth,
            self.CamRightLineType,
            self.CamRightLineColor,
            self.CamRightLineExistenceProb,
            self.CamLeftLineASIL,
            self.CamRightLineASIL,
            self.NotUsed3,
            self.CamRightLineOffset,
            self.CamRightLineOffsetVAR,
            self.CamRightLineYawAngle,
            self.CamRightLineYawAngleVAR,
            self.CamRightLineCurvature,
            self.CamRightLineCurvatureVAR,
            self.CamRightLineCurvatureRate,
            self.CamRightLineCurvatureRateVAR,
            self.CamLeftLeftLineID,
            self.CamLeftLeftLineQuality,
            self.CamLeftLeftLineStartViewRange,
            self.CamLeftLeftLineStartViewRangeVAR,
            self.CamLeftLeftLineEndViewRange,
            self.CamLeftLeftLineEndViewRangeVAR,
            self.CamLeftLeftLineMarkWidth,
            self.CamLeftLeftLineType,
            self.CamLeftLeftLineExistenceProb,
            self.CamLeftLeftLineOffset,
            self.CamLeftLeftLineOffsetVAR,
            self.CamLeftLeftLineYawAngle,
            self.CamLeftLeftLineYawAngleVAR,
            self.CamLeftLeftLineCurvature,
            self.CamLeftLeftLineCurvatureVAR,
            self.CamLeftLeftLineCurvatureRate,
            self.CamLeftLeftLineCurvatureRateVAR,
            self.CamRightRightLineID,
            self.CamRightRightLineQuality,
            self.CamRightRightLineStartViewRange,
            self.CamRightRightLineEndViewRange,
            self.CamRightRightLineMarkWidth,
            self.CamRightRightLineType,
            self.CamRightRightLineExistenceProb,
            self.CamRightRightLineOffset,
            self.CamRightRightLineOffsetVAR,
            self.CamRightRightLineYawAngle,
            self.CamRightRightLineYawAngleVAR,
            self.CamRightRightLineCurvature,
            self.CamRightRightLineCurvatureVAR,
            self.CamRightRightLineCurvatureRate,
            self.CamRightRightLineCurvatureRateVAR,
            self.CamTimestampLeftLine,
            self.CamTimestampRightLine,
            self.CamTimestampLeftLeftLine,
            self.CamTimestampRightRightLine,
            self.Cam_Number_Of_Lines,
            self.Cam_LDW_Warning,
            self.Cam_LDW_NRTA_Reasons,
            self.Cam_LDW_RTA,
            self.Cam_LDW_Inhibit_Reasons,
            self.Cam_CarPoolLane_Offset,
            self.Cam_CarPoolLane_Detect,
            self.Cam_SnowOnRoadDetected,
            self.Cam_TripleLineMark_Confidence,
            self.Cam_LeftTripleLineMarkWidth,
            self.Cam_RightTripleLineMarkWidth,
            self.CamRightRightLineStartViewRangeVAR,
            self.CamRightRightLineEndViewRangeVAR,
            ])
        
        return  [row+1, 0, []]  
    
    class LayerType(Enum):
        Cam_LeftRight_Lane_ADAS = 52
        
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.Cam_LeftRight_Lane_ADAS:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(128,77,144))
            symbol.setWidth(0.5)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
        
        else:
            return None
        
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        #realTime描画でない場合のみ、速度矢印を描く
        newLayer_lane = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime'
                                                 + '&field=Quality:double&field=Position:double&field=LineType:int&field=LineColor:int'
                                                 + '&index=yes',name,'memory')
        newLayer_lane = self.SetLayerStyle(self.LayerType.Cam_LeftRight_Lane_ADAS, newLayer_lane)
        
        return [newLayer_lane]
        
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        old = self.oldMessage
        newLayer_lane = None
        self.leftLaneLong = 180
        self.leftLaneLat = 180
        self.rightLaneLong = 180
        self.rightLaneLat = 180
        self.nextLeftLaneLong = 180
        self.nextLeftLaneLat = 180
        self.nextRightLaneLong = 180
        self.nextRightLaneLat = 180
        
        for layerListItem in layerList:
            if layerListItem[1] == CAMInfrastructureList.LayerType.Cam_LeftRight_Lane_ADAS.value:
                newLayer_lane = layerListItem[0]
        if newLayer_lane != None:
            if self.relatedADPositionMessage == None:
                return
            if self.relatedADPositionMessage.oldMessage == None:
                return
            [lon, lat, z] = self.relatedADPositionMessage.getLonLatZ()
            [oldLon, oldLat, oldZ] = self.relatedADPositionMessage.oldMessage.getLonLatZ()
            if checkInvalidLonLat(lon, lat, oldLon, oldLat) == True:
                scaleRate = 0.00000009
                length = sqrt(((lat-oldLat) ** 2 + (lon-oldLon) ** 2))
                normX = (lon-oldLon) / length
                normY = (lat-oldLat) / length
                vX = normX*math.cos(math.pi/2) - normY*math.sin(math.pi/2)
                vY = normX*math.sin(math.pi/2) + normY*math.cos(math.pi/2)
                
                if self.CamLeftLineOffset != 0:
                    self.leftLaneLong = scaleRate*self.CamLeftLineOffset*(vX) + lon
                    self.leftLaneLat = scaleRate*self.CamLeftLineOffset*(vY) + lat
                if self.CamRightLineOffset != 0:
                    self.rightLaneLong = scaleRate*self.CamRightLineOffset*(vX) + lon
                    self.rightLaneLat = scaleRate*self.CamRightLineOffset*(vY) + lat
                if self.CamLeftLeftLineOffset != 0:
                    self.nextLeftLaneLong = scaleRate*self.CamLeftLeftLineOffset*(vX) + lon
                    self.nextLeftLaneLat = scaleRate*self.CamLeftLeftLineOffset*(vY) + lat
                if self.CamRightRightLineOffset != 0:
                    self.nextRightLaneLong = scaleRate*self.CamRightRightLineOffset*(vX) + lon
                    self.nextRightLaneLat = scaleRate*self.CamRightRightLineOffset*(vY) + lat
                
                if old == None:
                    return
#                 if checkInvalidLonLat(self.leftLaneLong, self.leftLaneLat, old.leftLaneLong, old.leftLaneLat) == True:
#                     polylines = [[QgsPointXY(old.leftLaneLong, old.leftLaneLat, oldZ), QgsPointXY(self.leftLaneLong, self.leftLaneLat, z)]]
#                     feature = QgsFeature()
#                     feature.setGeometry(QgsGeometry.fromMultiPolylineXY(polylines))
#                     feature.setAttributes([QDateTime(self.commonHeader.logTime), self.CamLeftLineExistenceProb, self.CamLeftLineOffset, self.CamLeftLeftLineType, self.CamLeftLineColor])
#                     newLayer_lane.dataProvider().addFeatures( [feature] )
#                     
#                 if checkInvalidLonLat(self.rightLaneLong, self.rightLaneLat, old.rightLaneLong, old.rightLaneLat) == True:   
#                     polylines = [[QgsPointXY(old.rightLaneLong, old.rightLaneLat, oldZ), QgsPointXY(self.rightLaneLong, self.rightLaneLat, z)]]
#                     feature = QgsFeature()
#                     feature.setGeometry(QgsGeometry.fromMultiPolylineXY(polylines))
#                     feature.setAttributes([QDateTime(self.commonHeader.logTime), self.CamRightLineExistenceProb, self.CamRightLineOffset, self.CamRightLineType, self.CamRightLineColor])
#                     newLayer_lane.dataProvider().addFeatures( [feature] )
#                     
#                 if checkInvalidLonLat(self.nextLeftLaneLong, self.nextLeftLaneLat, old.nextLeftLaneLong, old.nextLeftLaneLat) == True:
#                     polylines = [[QgsPointXY(old.nextLeftLaneLong, old.nextLeftLaneLat, oldZ), QgsPointXY(self.nextLeftLaneLong, self.nextLeftLaneLat, z)]]
#                     feature = QgsFeature()
#                     feature.setGeometry(QgsGeometry.fromMultiPolylineXY(polylines))
#                     feature.setAttributes([QDateTime(self.commonHeader.logTime), self.CamLeftLeftLineExistenceProb, self.CamLeftLeftLineOffset, self.CamLeftLeftLineType, -1])
#                     newLayer_lane.dataProvider().addFeatures( [feature] )
#                     
#                 if checkInvalidLonLat(self.nextRightLaneLong, self.nextRightLaneLat, old.nextRightLaneLong, old.nextRightLaneLat) == True:   
#                     polylines = [[QgsPointXY(old.nextRightLaneLong, old.nextRightLaneLat, oldZ), QgsPointXY(self.nextRightLaneLong, self.nextRightLaneLat, z)]]
#                     feature = QgsFeature()
#                     feature.setGeometry(QgsGeometry.fromMultiPolylineXY(polylines))
#                     feature.setAttributes([QDateTime(self.commonHeader.logTime), self.CamRightRightLineExistenceProb, self.CamRightRightLineOffset, self.CamRightRightLineType, -1])
#                     newLayer_lane.dataProvider().addFeatures( [feature] )        
                if checkInvalidLonLat(self.leftLaneLong, self.leftLaneLat, old.leftLaneLong, old.leftLaneLat) == True:
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(old.leftLaneLong, old.leftLaneLat, oldZ), QgsPoint(self.leftLaneLong, self.leftLaneLat, z)]))
                    feature.setAttributes([QDateTime(self.commonHeader.logTime), self.CamLeftLineExistenceProb, self.CamLeftLineOffset, self.CamLeftLeftLineType, self.CamLeftLineColor])
                    newLayer_lane.dataProvider().addFeatures( [feature] )
                    
                if checkInvalidLonLat(self.rightLaneLong, self.rightLaneLat, old.rightLaneLong, old.rightLaneLat) == True:   
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(old.rightLaneLong, old.rightLaneLat, oldZ), QgsPoint(self.rightLaneLong, self.rightLaneLat, z)]))
                    feature.setAttributes([QDateTime(self.commonHeader.logTime), self.CamRightLineExistenceProb, self.CamRightLineOffset, self.CamRightLineType, self.CamRightLineColor])
                    newLayer_lane.dataProvider().addFeatures( [feature] )
                    
                if checkInvalidLonLat(self.nextLeftLaneLong, self.nextLeftLaneLat, old.nextLeftLaneLong, old.nextLeftLaneLat) == True: 
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(old.nextLeftLaneLong, old.nextLeftLaneLat, oldZ), QgsPoint(self.nextLeftLaneLong, self.nextLeftLaneLat, z)]))
                    feature.setAttributes([QDateTime(self.commonHeader.logTime), self.CamLeftLeftLineExistenceProb, self.CamLeftLeftLineOffset, self.CamLeftLeftLineType, -1])
                    newLayer_lane.dataProvider().addFeatures( [feature] )
                    
                if checkInvalidLonLat(self.nextRightLaneLong, self.nextRightLaneLat, old.nextRightLaneLong, old.nextRightLaneLat) == True:   
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(old.nextRightLaneLong, old.nextRightLaneLat, oldZ), QgsPoint(self.nextRightLaneLong, self.nextRightLaneLat, z)]))
                    feature.setAttributes([QDateTime(self.commonHeader.logTime), self.CamRightRightLineExistenceProb, self.CamRightRightLineOffset, self.CamRightRightLineType, -1])
                    newLayer_lane.dataProvider().addFeatures( [feature] )  
                    

#-----------------------------------------------#
#----   CAM LaneInfrastructureInfo          ----#
#-----------------------------------------------#
class CAMLaneInfrastructureInfo(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        readFunc(int, 16) #reserved
        self.TSR1VisionOnlySignType = readFunc(int, 16, sign=False)
        self.TSR1VisionOnlySuppSignType = readFunc(int, 16, sign=False)
        self.TSR1SignPositionX = readFunc(float, 32, sign=True)
        self.TSR1SignPositionY = readFunc(float, 32, sign=True)
        self.TSR1SignPositionZ = readFunc(float, 32, sign=True)
        self.TSR1FilterType = readFunc(int, 8, sign=False)
        self.TSR1NoEntryVisionStatus = readFunc(int, 8, sign=False)
        self.TSR1SignHeight = readFunc(float, 32, sign=True)
        self.TSR1SignWidth = readFunc(float, 32, sign=True)
        self.TSR2VisionOnlySignType = readFunc(int, 16, sign=False)
        self.TSR2VisionOnlySuppSignType = readFunc(int, 16, sign=False)
        self.TSR2SignPositionX = readFunc(float, 32, sign=True)
        self.TSR2SignPositionY = readFunc(float, 32, sign=True)
        self.TSR2SignPositionZ = readFunc(float, 32, sign=True)
        self.TSR2FilterType = readFunc(int, 8, sign=False)
        self.TSR2NoEntryVisionStatus = readFunc(int, 8, sign=False)
        self.TSR2SignHeight = readFunc(float, 32, sign=True)
        self.TSR2SignWidth = readFunc(float, 32, sign=True)
        self.TSR3VisionOnlySignType = readFunc(int, 16, sign=False)
        self.TSR3VisionOnlySuppSignType = readFunc(int, 16, sign=False)
        self.TSR3SignPositionX = readFunc(float, 32, sign=True)
        self.TSR3SignPositionY = readFunc(float, 32, sign=True)
        self.TSR3SignPositionZ = readFunc(float, 32, sign=True)
        self.TSR3FilterType = readFunc(int, 8, sign=False)
        self.TSR3NoEntryVisionStatus = readFunc(int, 8, sign=False)
        self.TSR3SignHeight = readFunc(float, 32, sign=True)
        self.TSR3SignWidth = readFunc(float, 32, sign=True)
        self.TSR4VisionOnlySignType = readFunc(int, 16, sign=False)
        self.TSR4VisionOnlySuppSignType = readFunc(int, 16, sign=False)
        self.TSR4SignPositionX = readFunc(float, 32, sign=True)
        self.TSR4SignPositionY = readFunc(float, 32, sign=True)
        self.TSR4SignPositionZ = readFunc(float, 32, sign=True)
        self.TSR4FilterType = readFunc(int, 8, sign=False)
        self.TSR4NoEntryVisionStatus = readFunc(int, 8, sign=False)
        self.TSR4SignHeight = readFunc(float, 32, sign=True)
        self.TSR4SignWidth = readFunc(float, 32, sign=True)
        self.TSR5VisionOnlySignType = readFunc(int, 16, sign=False)
        self.TSR5VisionOnlySuppSignType = readFunc(int, 16, sign=False)
        self.TSR5SignPositionX = readFunc(float, 32, sign=True)
        self.TSR5SignPositionY = readFunc(float, 32, sign=True)
        self.TSR5SignPositionZ = readFunc(float, 32, sign=True)
        self.TSR5FilterType = readFunc(int, 8, sign=False)
        self.TSR5NoEntryVisionStatus = readFunc(int, 8, sign=False)
        self.TSR5SignHeight = readFunc(float, 32, sign=True)
        self.TSR5SignWidth = readFunc(float, 32, sign=True)
        
        self.TSR6VisionOnlySignType = readFunc(int, 16, sign=False)
        self.TSR6VisionOnlySuppSignType = readFunc(int, 16, sign=False)
        self.TSR6SignPositionX = readFunc(float, 32, sign=True)
        self.TSR6SignPositionY = readFunc(float, 32, sign=True)
        self.TSR6SignPositionZ = readFunc(float, 32, sign=True)
        self.TSR6FilterType = readFunc(int, 8, sign=False)
        self.TSR6NoEntryVisionStatus = readFunc(int, 8, sign=False)
        self.TSR6SignHeight = readFunc(float, 32, sign=True)
        self.TSR6SignWidth = readFunc(float, 32, sign=True)
        self.TSR7VisionOnlySignType = readFunc(int, 16, sign=False)
        self.TSR7VisionOnlySuppSignType = readFunc(int, 16, sign=False)
        self.TSR7SignPositionX = readFunc(float, 32, sign=True)
        self.TSR7SignPositionY = readFunc(float, 32, sign=True)
        self.TSR7SignPositionZ = readFunc(float, 32, sign=True)
        self.TSR7FilterType = readFunc(int, 8, sign=False)
        self.TSR7NoEntryVisionStatus = readFunc(int, 8, sign=False)
        self.TSR7SignHeight = readFunc(float, 32, sign=True)
        self.TSR7SignWidth = readFunc(float, 32, sign=True)
        
        self.LeftLaneType = readFunc(int, 8, sign=False)
        self.LeftQuality = readFunc(int, 8, sign=False)
        self.LeftPosition = readFunc(float, 32, sign=True)
        self.LeftCurvature = readFunc(float, 32, sign=True)
        self.LeftCurvatureDerivative = readFunc(float, 32, sign=True)
        self.LeftWidthLeftMarking = readFunc(float, 32, sign=True)
        self.LeftHeadingAngle = readFunc(float, 32, sign=True)
        self.LeftViewRangeStart = readFunc(float, 32, sign=True)
        self.LeftViewRangeEnd = readFunc(float, 32, sign=True)
        self.LeftLaneCrossing = readFunc(int, 8, sign=False)
        self.LeftLaneMarkColor = readFunc(int, 8, sign=False)
        self.LeftPREDDISTBASEDEXTRAPOLATION = readFunc(int, 8, sign=False)
        self.LeftPREDOTHERSIDE = readFunc(int, 8, sign=False)
        self.LeftPREDOVERRIDE = readFunc(int, 8, sign=False)
        self.LeftPREDOCCLUDEDLMEXTRAPOLATION = readFunc(int, 8, sign=False)
        self.LeftPREDHEADWAYORIENTED = readFunc(int, 8, sign=False)
        self.LeftSOURCEDIVERGINGLANES = readFunc(int, 8, sign=False)
        self.LeftSOURCEGUARDRAILSHADOW = readFunc(int, 8, sign=False)
        self.LeftPREDSOURCEVRTLMERGE = readFunc(int, 8, sign=False)
        self.ConfidenceOfSingleFrameLeft = readFunc(float, 32, sign=True)
        self.ConfidenceOfTLMLeft = readFunc(int, 8, sign=False)
        self.VarianceOfTLMLeft = readFunc(float, 32, sign=True)
        self.RightLaneType = readFunc(int, 8, sign=False)
        self.RightQuality = readFunc(int, 8, sign=False)
        self.RightPosition = readFunc(float, 32, sign=True)
        self.RightCurvature = readFunc(float, 32, sign=True)
        self.RightCurvatureDerivative = readFunc(float, 32, sign=True)
        self.RightWidthRightMarking = readFunc(float, 32, sign=True)
        self.RightHeadingAngle = readFunc(float, 32, sign=True)
        self.RightViewRangeStart = readFunc(float, 32, sign=True)
        self.RightViewRangeEnd = readFunc(float, 32, sign=True)
        self.RightLaneCrossing = readFunc(int, 8, sign=False)
        self.RightLaneMarkColor = readFunc(int, 8, sign=False)
        self.RightPREDDISTBASEDEXTRAPOLATION = readFunc(int, 8, sign=False)
        self.RightPREDOTHERSIDE = readFunc(int, 8, sign=False)
        self.RightPREDOVERRIDE = readFunc(int, 8, sign=False)
        self.RightPREDOCCLUDEDLMEXTRAPOLATION = readFunc(int, 8, sign=False)
        self.RightPREDHEADWAYORIENTED = readFunc(int, 8, sign=False)
        self.RightSOURCEDIVERGINGLANES = readFunc(int, 8, sign=False)
        self.RightSOURCEGUARDRAILSHADOW = readFunc(int, 8, sign=False)
        self.RightPREDSOURCEVRTLMERGE = readFunc(int, 8, sign=False)
        self.ConfidenceOfSingleFrameRight = readFunc(float, 32, sign=True)
        self.ConfidenceOfTLMRight = readFunc(int, 8, sign=False)
        self.VarianceOfTLMRight = readFunc(float, 32, sign=True)
        
        self.NextLeftLaneType = readFunc(int, 8, sign=False)
        self.NextLeftQuality = readFunc(int, 8, sign=False)
        self.NextLeftPosition = readFunc(float, 32, sign=True)
        self.NextLeftCurvature = readFunc(float, 32, sign=True)
        self.NextLeftCurvatureDerivative = readFunc(float, 32, sign=True)
        self.NextLeftLaneMarkWidth = readFunc(float, 32, sign=True)
        self.NextLeftHeadingAngle = readFunc(float, 32, sign=True)
        self.NextLeftViewRangeStart = readFunc(float, 32, sign=True)
        self.NextLeftViewRangeEnd = readFunc(float, 32, sign=True)
        self.NextRightLaneType = readFunc(int, 8, sign=False)
        self.NextRightQuality = readFunc(int, 8, sign=False)
        self.NextRightPosition = readFunc(float, 32, sign=True)
        self.NextRightCurvature = readFunc(float, 32, sign=True)
        self.NextRightCurvatureDerivative = readFunc(float, 32, sign=True)
        self.NextRightLaneMarkWidth = readFunc(float, 32, sign=True)
        self.NextRightHeadingAngle = readFunc(float, 32, sign=True)
        self.NextRightViewRangeStart = readFunc(float, 32, sign=True)
        self.NextRightViewRangeEnd = readFunc(float, 32, sign=True)
        self.LaneConfidenceMeasureNextLeft = readFunc(float, 32, sign=True)
        self.LaneConfidenceMeasureNextRight = readFunc(float, 32, sign=True)
        self.ConfidenceOfSNOW = readFunc(int, 8, sign=False)
        
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        
        strList = [
            'TSR1VisionOnlySignType',
            'TSR1VisionOnlySuppSignType',
            'TSR1SignPositionX',
            'TSR1SignPositionY',
            'TSR1SignPositionZ',
            'TSR1FilterType',
            'TSR1NoEntryVisionStatus',
            'TSR1SignHeight',
            'TSR1SignWidth',
            'TSR2VisionOnlySignType',
            'TSR2VisionOnlySuppSignType',
            'TSR2SignPositionX',
            'TSR2SignPositionY',
            'TSR2SignPositionZ',
            'TSR2FilterType',
            'TSR2NoEntryVisionStatus',
            'TSR2SignHeight',
            'TSR2SignWidth',
            'TSR3VisionOnlySignType',
            'TSR3VisionOnlySuppSignType',
            'TSR3SignPositionX',
            'TSR3SignPositionY',
            'TSR3SignPositionZ',
            'TSR3FilterType',
            'TSR3NoEntryVisionStatus',
            'TSR3SignHeight',
            'TSR3SignWidth',
            'TSR4VisionOnlySignType',
            'TSR4VisionOnlySuppSignType',
            'TSR4SignPositionX',
            'TSR4SignPositionY',
            'TSR4SignPositionZ',
            'TSR4FilterType',
            'TSR4NoEntryVisionStatus',
            'TSR4SignHeight',
            'TSR4SignWidth',
            'TSR5VisionOnlySignType',
            'TSR5VisionOnlySuppSignType',
            'TSR5SignPositionX',
            'TSR5SignPositionY',
            'TSR5SignPositionZ',
            'TSR5FilterType',
            'TSR5NoEntryVisionStatus',
            'TSR5SignHeight',
            'TSR5SignWidth',
            
            'TSR6VisionOnlySignType',
            'TSR6VisionOnlySuppSignType',
            'TSR6SignPositionX',
            'TSR6SignPositionY',
            'TSR6SignPositionZ',
            'TSR6FilterType',
            'TSR6NoEntryVisionStatus',
            'TSR6SignHeight',
            'TSR6SignWidth',
            'TSR7VisionOnlySignType',
            'TSR7VisionOnlySuppSignType',
            'TSR7SignPositionX',
            'TSR7SignPositionY',
            'TSR7SignPositionZ',
            'TSR7FilterType',
            'TSR7NoEntryVisionStatus',
            'TSR7SignHeight',
            'TSR7SignWidth',
            
            'LeftLaneType',
            'LeftQuality',
            'LeftPosition',
            'LeftCurvature',
            'LeftCurvatureDerivative',
            'LeftWidthLeftMarking',
            'LeftHeadingAngle',
            'LeftViewRangeStart',
            'LeftViewRangeEnd',
            'LeftLaneCrossing',
            'LeftLaneMarkColor',
            'LeftPREDDISTBASEDEXTRAPOLATION',
            'LeftPREDOTHERSIDE',
            'LeftPREDOVERRIDE',
            'LeftPREDOCCLUDEDLMEXTRAPOLATION',
            'LeftPREDHEADWAYORIENTED',
            'LeftSOURCEDIVERGINGLANES',
            'LeftSOURCEGUARDRAILSHADOW',
            'LeftPREDSOURCEVRTLMERGE',
            'ConfidenceOfSingleFrameLeft',
            'ConfidenceOfTLMLeft',
            'VarianceOfTLMLeft',
            'RightLaneType',
            'RightQuality',
            'RightPosition',
            'RightCurvature',
            'RightCurvatureDerivative',
            'RightWidthRightMarking',
            'RightHeadingAngle',
            'RightViewRangeStart',
            'RightViewRangeEnd',
            'RightLaneCrossing',
            'RightLaneMarkColor',
            'RightPREDDISTBASEDEXTRAPOLATION',
            'RightPREDOTHERSIDE',
            'RightPREDOVERRIDE',
            'RightPREDOCCLUDEDLMEXTRAPOLATION',
            'RightPREDHEADWAYORIENTED',
            'RightSOURCEDIVERGINGLANES',
            'RightSOURCEGUARDRAILSHADOW',
            'RightPREDSOURCEVRTLMERGE',
            'ConfidenceOfSingleFrameRight',
            'ConfidenceOfTLMRight',
            'VarianceOfTLMRight',
            
            'NextLeftLaneType',
            'NextLeftQuality',
            'NextLeftPosition',
            'NextLeftCurvature',
            'NextLeftCurvatureDerivative',
            'NextLeftLaneMarkWidth',
            'NextLeftHeadingAngle',
            'NextLeftViewRangeStart',
            'NextLeftViewRangeEnd',
            'NextRightLaneType',
            'NextRightQuality',
            'NextRightPosition',
            'NextRightCurvature',
            'NextRightCurvatureDerivative',
            'NextRightLaneMarkWidth',
            'NextRightHeadingAngle',
            'NextRightViewRangeStart',
            'NextRightViewRangeEnd',
            'LaneConfidenceMeasureNextLeft',
            'LaneConfidenceMeasureNextRight',
            'ConfidenceOfSNOW']
        sheet.write_row(row, col, strList, sheet.cellFormats('header'))
        col += len(strList)
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return  [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [
            self.TSR1VisionOnlySignType,
            self.TSR1VisionOnlySuppSignType,
            self.TSR1SignPositionX,
            self.TSR1SignPositionY,
            self.TSR1SignPositionZ,
            self.TSR1FilterType,
            self.TSR1NoEntryVisionStatus,
            self.TSR1SignHeight,
            self.TSR1SignWidth,
            self.TSR2VisionOnlySignType,
            self.TSR2VisionOnlySuppSignType,
            self.TSR2SignPositionX,
            self.TSR2SignPositionY,
            self.TSR2SignPositionZ,
            self.TSR2FilterType,
            self.TSR2NoEntryVisionStatus,
            self.TSR2SignHeight,
            self.TSR2SignWidth,
            self.TSR3VisionOnlySignType,
            self.TSR3VisionOnlySuppSignType,
            self.TSR3SignPositionX,
            self.TSR3SignPositionY,
            self.TSR3SignPositionZ,
            self.TSR3FilterType,
            self.TSR3NoEntryVisionStatus,
            self.TSR3SignHeight,
            self.TSR3SignWidth,
            self.TSR4VisionOnlySignType,
            self.TSR4VisionOnlySuppSignType,
            self.TSR4SignPositionX,
            self.TSR4SignPositionY,
            self.TSR4SignPositionZ,
            self.TSR4FilterType,
            self.TSR4NoEntryVisionStatus,
            self.TSR4SignHeight,
            self.TSR4SignWidth,
            self.TSR5VisionOnlySignType,
            self.TSR5VisionOnlySuppSignType,
            self.TSR5SignPositionX,
            self.TSR5SignPositionY,
            self.TSR5SignPositionZ,
            self.TSR5FilterType,
            self.TSR5NoEntryVisionStatus,
            self.TSR5SignHeight,
            self.TSR5SignWidth,
            
            self.TSR6VisionOnlySignType,
            self.TSR6VisionOnlySuppSignType,
            self.TSR6SignPositionX,
            self.TSR6SignPositionY,
            self.TSR6SignPositionZ,
            self.TSR6FilterType,
            self.TSR6NoEntryVisionStatus,
            self.TSR6SignHeight,
            self.TSR6SignWidth,
            self.TSR7VisionOnlySignType,
            self.TSR7VisionOnlySuppSignType,
            self.TSR7SignPositionX,
            self.TSR7SignPositionY,
            self.TSR7SignPositionZ,
            self.TSR7FilterType,
            self.TSR7NoEntryVisionStatus,
            self.TSR7SignHeight,
            self.TSR7SignWidth,
            
            self.LeftLaneType,
            self.LeftQuality,
            self.LeftPosition,
            self.LeftCurvature,
            self.LeftCurvatureDerivative,
            self.LeftWidthLeftMarking,
            self.LeftHeadingAngle,
            self.LeftViewRangeStart,
            self.LeftViewRangeEnd,
            self.LeftLaneCrossing,
            self.LeftLaneMarkColor,
            self.LeftPREDDISTBASEDEXTRAPOLATION,
            self.LeftPREDOTHERSIDE,
            self.LeftPREDOVERRIDE,
            self.LeftPREDOCCLUDEDLMEXTRAPOLATION,
            self.LeftPREDHEADWAYORIENTED,
            self.LeftSOURCEDIVERGINGLANES,
            self.LeftSOURCEGUARDRAILSHADOW,
            self.LeftPREDSOURCEVRTLMERGE,
            self.ConfidenceOfSingleFrameLeft,
            self.ConfidenceOfTLMLeft,
            self.VarianceOfTLMLeft,
            self.RightLaneType,
            self.RightQuality,
            self.RightPosition,
            self.RightCurvature,
            self.RightCurvatureDerivative,
            self.RightWidthRightMarking,
            self.RightHeadingAngle,
            self.RightViewRangeStart,
            self.RightViewRangeEnd,
            self.RightLaneCrossing,
            self.RightLaneMarkColor,
            self.RightPREDDISTBASEDEXTRAPOLATION,
            self.RightPREDOTHERSIDE,
            self.RightPREDOVERRIDE,
            self.RightPREDOCCLUDEDLMEXTRAPOLATION,
            self.RightPREDHEADWAYORIENTED,
            self.RightSOURCEDIVERGINGLANES,
            self.RightSOURCEGUARDRAILSHADOW,
            self.RightPREDSOURCEVRTLMERGE,
            self.ConfidenceOfSingleFrameRight,
            self.ConfidenceOfTLMRight,
            self.VarianceOfTLMRight,
            
            self.NextLeftLaneType,
            self.NextLeftQuality,
            self.NextLeftPosition,
            self.NextLeftCurvature,
            self.NextLeftCurvatureDerivative,
            self.NextLeftLaneMarkWidth,
            self.NextLeftHeadingAngle,
            self.NextLeftViewRangeStart,
            self.NextLeftViewRangeEnd,
            self.NextRightLaneType,
            self.NextRightQuality,
            self.NextRightPosition,
            self.NextRightCurvature,
            self.NextRightCurvatureDerivative,
            self.NextRightLaneMarkWidth,
            self.NextRightHeadingAngle,
            self.NextRightViewRangeStart,
            self.NextRightViewRangeEnd,
            self.LaneConfidenceMeasureNextLeft,
            self.LaneConfidenceMeasureNextRight,
            self.ConfidenceOfSNOW])
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
    class LayerType(Enum):
        Cam_LeftRight_Lane = 51
        
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.Cam_LeftRight_Lane:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(128,77,144))
            symbol.setWidth(0.5)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
        
        else:
            return None
        
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        newLayer_lane = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime'
                                                 + '&field=Quality:double&field=Position:double&field=LineType:int&field=LineColor:int'
                                                 + '&index=yes',name,'memory')
        newLayer_lane = self.SetLayerStyle(self.LayerType.Cam_LeftRight_Lane, newLayer_lane)
        
        return [newLayer_lane]
        
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        old = self.oldMessage
        newLayer_lane = None
        self.leftLaneLong = 180
        self.leftLaneLat = 180
        self.rightLaneLong = 180
        self.rightLaneLat = 180
        self.nextLeftLaneLong = 180
        self.nextLeftLaneLat = 180
        self.nextRightLaneLong = 180
        self.nextRightLaneLat = 180
        
        for layerListItem in layerList:
            if layerListItem[1] == CAMLaneInfrastructureInfo.LayerType.Cam_LeftRight_Lane.value:
                newLayer_lane = layerListItem[0]
                
        if newLayer_lane != None:
            if self.relatedADPositionMessage == None:
                return
            if self.relatedADPositionMessage.oldMessage == None:
                return
            [lon, lat, z] = self.relatedADPositionMessage.getLonLatZ()
            [oldLon, oldLat, oldZ] = self.relatedADPositionMessage.oldMessage.getLonLatZ()
            if checkInvalidLonLat(lon, lat, oldLon, oldLat) == True:
                scaleRate = 0.00000009
                length = sqrt(((lat-oldLat) ** 2 + (lon-oldLon) ** 2))
                normX = (lon-oldLon) / length
                normY = (lat-oldLat) / length
                vX = normX*math.cos(math.pi/2) - normY*math.sin(math.pi/2)
                vY = normX*math.sin(math.pi/2) + normY*math.cos(math.pi/2)
                
                if self.LeftPosition != 0:
                    self.leftLaneLong = scaleRate*self.LeftPosition*(vX) + lon
                    self.leftLaneLat = scaleRate*self.LeftPosition*(vY) + lat
                if self.RightPosition != 0:
                    self.rightLaneLong = scaleRate*self.RightPosition*(vX) + lon
                    self.rightLaneLat = scaleRate*self.RightPosition*(vY) + lat
                if self.NextLeftPosition != 0:
                    self.nextLeftLaneLong = scaleRate*self.NextLeftPosition*(vX) + lon
                    self.nextLeftLaneLat = scaleRate*self.NextLeftPosition*(vY) + lat
                if self.NextRightPosition != 0:
                    self.nextRightLaneLong = scaleRate*self.NextRightPosition*(vX) + lon
                    self.nextRightLaneLat = scaleRate*self.NextRightPosition*(vY) + lat
                
                if old == None:
                    return
#                 if checkInvalidLonLat(self.leftLaneLong, self.leftLaneLat, old.leftLaneLong, old.leftLaneLat) == True:
#                     polylines = [[QgsPointXY(old.leftLaneLong, old.leftLaneLat, oldZ), QgsPointXY(self.leftLaneLong, self.leftLaneLat, z)]]
#                     feature = QgsFeature()
#                     feature.setGeometry(QgsGeometry.fromMultiPolylineXY(polylines))
#                     feature.setAttributes([QDateTime(self.commonHeader.logTime), 
#                                            self.LeftQuality, self.LeftPosition, self.LeftLaneType, self.LeftLaneMarkColor])
#                     newLayer_lane.dataProvider().addFeatures( [feature] )
#                     
#                 if checkInvalidLonLat(self.rightLaneLong, self.rightLaneLat, old.rightLaneLong, old.rightLaneLat) == True:   
#                     polylines = [[QgsPointXY(old.rightLaneLong, old.rightLaneLat, oldZ), QgsPointXY(self.rightLaneLong, self.rightLaneLat, z)]]
#                     feature = QgsFeature()
#                     feature.setGeometry(QgsGeometry.fromMultiPolylineXY(polylines))
#                     feature.setAttributes([QDateTime(self.commonHeader.logTime), 
#                                            self.RightQuality, self.RightPosition, self.RightLaneType, self.RightLaneMarkColor])
#                     newLayer_lane.dataProvider().addFeatures( [feature] )
#                     
#                 if checkInvalidLonLat(self.nextLeftLaneLong, self.nextLeftLaneLat, old.nextLeftLaneLong, old.nextLeftLaneLat) == True:
#                     polylines = [[QgsPointXY(old.nextLeftLaneLong, old.nextLeftLaneLat, oldZ), QgsPointXY(self.nextLeftLaneLong, self.nextLeftLaneLat, z)]]
#                     feature = QgsFeature()
#                     feature.setGeometry(QgsGeometry.fromMultiPolylineXY(polylines))
#                     feature.setAttributes([QDateTime(self.commonHeader.logTime), 
#                                            self.NextLeftQuality, self.NextLeftPosition, self.NextLeftLaneType, -1])
#                     newLayer_lane.dataProvider().addFeatures( [feature] )
#                     
#                 if checkInvalidLonLat(self.nextRightLaneLong, self.nextRightLaneLat, old.nextRightLaneLong, old.nextRightLaneLat) == True:   
#                     polylines = [[QgsPointXY(old.nextRightLaneLong, old.nextRightLaneLat, oldZ), QgsPointXY(self.nextRightLaneLong, self.nextRightLaneLat, z)]]
#                     feature = QgsFeature()
#                     feature.setGeometry(QgsGeometry.fromMultiPolylineXY(polylines))
#                     feature.setAttributes([QDateTime(self.commonHeader.logTime), 
#                                            self.NextRightQuality, self.NextRightPosition, self.NextRightLaneType, -1])
#                     newLayer_lane.dataProvider().addFeatures( [feature] )        
                if checkInvalidLonLat(self.leftLaneLong, self.leftLaneLat, old.leftLaneLong, old.leftLaneLat) == True:
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(old.leftLaneLong, old.leftLaneLat, oldZ), QgsPoint(self.leftLaneLong, self.leftLaneLat, z)]))
                    feature.setAttributes([QDateTime(self.commonHeader.logTime), 
                                           self.LeftQuality, self.LeftPosition, self.LeftLaneType, self.LeftLaneMarkColor])
                    newLayer_lane.dataProvider().addFeatures( [feature] )
                    
                if checkInvalidLonLat(self.rightLaneLong, self.rightLaneLat, old.rightLaneLong, old.rightLaneLat) == True:   
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(old.rightLaneLong, old.rightLaneLat, oldZ), QgsPoint(self.rightLaneLong, self.rightLaneLat, z)]))
                    feature.setAttributes([QDateTime(self.commonHeader.logTime), 
                                           self.RightQuality, self.RightPosition, self.RightLaneType, self.RightLaneMarkColor])
                    newLayer_lane.dataProvider().addFeatures( [feature] )
                    
                if checkInvalidLonLat(self.nextLeftLaneLong, self.nextLeftLaneLat, old.nextLeftLaneLong, old.nextLeftLaneLat) == True:
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(old.nextLeftLaneLong, old.nextLeftLaneLat, oldZ), QgsPoint(self.nextLeftLaneLong, self.nextLeftLaneLat, z)]))
                    feature.setAttributes([QDateTime(self.commonHeader.logTime), 
                                           self.NextLeftQuality, self.NextLeftPosition, self.NextLeftLaneType, -1])
                    newLayer_lane.dataProvider().addFeatures( [feature] )
                    
                if checkInvalidLonLat(self.nextRightLaneLong, self.nextRightLaneLat, old.nextRightLaneLong, old.nextRightLaneLat) == True:   
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(old.nextRightLaneLong, old.nextRightLaneLat, oldZ), QgsPoint(self.nextRightLaneLong, self.nextRightLaneLat, z)]))
                    feature.setAttributes([QDateTime(self.commonHeader.logTime), 
                                           self.NextRightQuality, self.NextRightPosition, self.NextRightLaneType, -1])
                    newLayer_lane.dataProvider().addFeatures( [feature] )  
                    
            
#-----------------------------------------------#
#----   Transfer To EyeQ for RSD            ----#
#-----------------------------------------------#
class TransferToEyeQforRSD(Message):
    TypeDic = {0:'Start(0)', 1:'ACK/CONT(1)', 2:'NACK/RESEND(2)', 3:'Abort(3)'}
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        readFunc(int,16) #reserved
        self.MEMTPheader = readFunc(bytes,64,endian='little') #ME-MTP header
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write(row, col+0, 'ME-MTP header', sheet.cellFormats('header'))
        sheet.write(row, col+1, 'MsgId', sheet.cellFormats('header'))
        sheet.write(row, col+2, 'Type', sheet.cellFormats('header'))
        sheet.write(row, col+3, 'pCount', sheet.cellFormats('header'))
        sheet.write(row, col+4, 'crc16', sheet.cellFormats('header'))
        sheet.write(row, col+5, 'msgType', sheet.cellFormats('header'))
        sheet.write(row, col+6, 'size', sheet.cellFormats('header'))
        col += 7
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return  [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [
            '0x' + ''.join(format(x,'02X') for x in self.MEMTPheader),
            int(self.MEMTPheader[7] & 0xF0) >> 4, # little endian
            TransferToEyeQforRSD.TypeDic.get(int(self.MEMTPheader[6] & 0x07), '[error]'),
            int(self.MEMTPheader[6] & 0xF0) >> 4,
            ''.join(format(x,'02x') for x in self.MEMTPheader[4:6]),
            'ANY(0)' if self.MEMTPheader[3] == 0 else chr(self.MEMTPheader[3]),
            int.from_bytes(self.MEMTPheader[0:3], byteorder='big')])
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
#-----------------------------------------------#
#----   Transfer From EyeQ for RSD          ----#
#-----------------------------------------------#
class TransferFromEyeQforRSD(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        readFunc(int,16) #reserved
        self.MEMTPheader = readFunc(bytes,64,endian='little') #ME-MTP header
        readFunc(bytes,840) #Payload
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write(row, col+0, 'ME-MTP header', sheet.cellFormats('header'))
        sheet.write(row, col+1, 'MsgId', sheet.cellFormats('header'))
        sheet.write(row, col+2, 'bFirst', sheet.cellFormats('header'))
        sheet.write(row, col+3, 'bLast', sheet.cellFormats('header'))
        sheet.write(row, col+4, 'bWait', sheet.cellFormats('header'))
        sheet.write(row, col+5, 'bSent', sheet.cellFormats('header'))
        sheet.write(row, col+6, 'pCount', sheet.cellFormats('header'))
        sheet.write(row, col+7, 'crc16', sheet.cellFormats('header'))
        sheet.write(row, col+8, 'msgType', sheet.cellFormats('header'))
        sheet.write(row, col+9, 'size', sheet.cellFormats('header'))
        col += 10
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return  [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        if self.MEMTPheader != '':
            if self.MEMTPheader != 0:
                sheet.write_row(row, col, [
                    '0x' + ''.join(format(x,'02X') for x in self.MEMTPheader),
                    int(self.MEMTPheader[7] & 0x0F), # little endian
                    int(self.MEMTPheader[6] & 0x01),
                    int(self.MEMTPheader[6] & 0x02) >> 1,
                    int(self.MEMTPheader[6] & 0x04) >> 2,
                    int(self.MEMTPheader[6] & 0x08) >> 3,
                    int(self.MEMTPheader[6] & 0xF0) >> 4,
                    ''.join(format(x,'02x') for x in self.MEMTPheader[4:6]),
                    chr(self.MEMTPheader[3]),
                    int.from_bytes(self.MEMTPheader[0:3], byteorder='big')])
            else:
                sheet.write_row(row, col, [
                    '0x0000000000000000',
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    '0000',
                    '0',
                    0])
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
#-----------------------------------------------#
#----   TTP Response Message                ----#
#-----------------------------------------------#
class TTPResponseMessage(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        readFunc(int,16) #reserved
        for _ in range(1,5):
            readFunc(bytes,64) #ME-MTP header
            readFunc(bytes,840) #Payload
            if self.commonHeader.length == self.data.seek():
                break
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return  [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
#-----------------------------------------------#
#----   TTP Error Aleart Message            ----#
#-----------------------------------------------#
class TTPErrorAleartMessage(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        readFunc(int,16) #reserved
        readFunc(bytes,64) #ME-MTP header
        readFunc(bytes,49*8) #Payload
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return  [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
#-----------------------------------------------#
#----   TTP Map Manifest Request Message    ----#
#-----------------------------------------------#
class TTPMapManifestRequestMessage(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        readFunc(int,16) #reserved
        readFunc(bytes,64) #ME-MTP header
        readFunc(bytes,26*8) #Payload
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return  [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)        

#-----------------------------------------------#
#----   TTP Tile Request Message            ----#
#-----------------------------------------------#
class TTPTileRequestMessage(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        readFunc(int,16) #reserved
        readFunc(bytes,64) #ME-MTP header
        readFunc(bytes,28*8) #Payload
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return  [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)  

#-----------------------------------------------#
#----   TTP Tile Drop Message               ----#
#-----------------------------------------------#
class TTPTileDropMessage(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        readFunc(int,16) #reserved
        readFunc(bytes,64) #ME-MTP header
        readFunc(bytes,27*8) #Payload
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return  [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows) 
        
#-----------------------------------------------#
#----   TTP EyeQ Error Alerts Message       ----#
#-----------------------------------------------#
class TTPEyeQErrorAlertsMessage(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        readFunc(int,16) #reserved
        readFunc(bytes,64) #ME-MTP header
        readFunc(bytes,27*8) #Payload
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return  [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows) 

#-----------------------------------------------#
#----   RequestLostMessage                  ----#
#-----------------------------------------------#
class RequestLostMessage(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        readFunc(int,32) #reserved
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return  [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)

#-----------------------------------------------#
#----   RequestInitialMessage               ----#
#-----------------------------------------------#
class RequestInitialMessage(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.type = readFunc(int,8)
        readFunc(int,24) #reserved
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write(row, col, 'type', sheet.cellFormats('header'))
        col += 1
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write(row, col, (hex(self.type)))
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    


#-----------------------------------------------#
#----   ReconstructorLaneList               ----#
#-----------------------------------------------#
class ReconstructorLaneList(Message, SegmentableMessage):
    lastParseMergedDataMessage = None
    
    @dataclass
    class LaneListInfo:
        pathID: int #32
        instanceID: int #32
        laneLinkID: int #64
        
        def printValue(self, sheet, row, col, _level):
            sheet.write_rich_string(row, col, *[
            sheet.cellFormats('blue'), '   *パスID: ', str(hex(self.pathID) + "\n"),
            sheet.cellFormats('blue'), '   *インスタンスID: ', str(hex(self.instanceID)) + "\n",
            sheet.cellFormats('blue'), '   *レーンリ: ', str(self.laneLinkID), sheet.cellFormats('wrap')])
#             sheet.set_row(row, 13.5*3)
            return [row+1, col, []]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.oldMessage = ReconstructorLaneList.lastParseMergedDataMessage
        self.segmentCount = readFunc(int,16)
        self.segmentIndex = readFunc(int,16)
        self.laneListID_MPU = readFunc(int,16)
        self.laneListID_RC = readFunc(int,16)
        self.classify = readFunc(int,8)
        readFunc(int,24) #reserved
        self.numberOfArray = 0
        self.dataArray = []
        self.mergeSegmentData(str(self.laneListID_MPU) + '-' + str(self.laneListID_RC), self.segmentIndex, self.segmentCount, self.data.getDataBuf()[self.data.seek():])
    
    def parseMergedData(self, data):
        readFunc = data.readValue
        self.numberOfArray = readFunc(int,32)
        self.dataArray = []
        for _ in range(self.numberOfArray):
            self.dataArray.append(self.LaneListInfo(
                pathID = readFunc(int,32),
                instanceID = readFunc(int,32),
                laneLinkID = readFunc(int,64)))
        ReconstructorLaneList.lastParseMergedDataMessage = self
        
    def printHeader(self, sheet, row, col, _level = 1):
        [_, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write_row(row, col, [
            '分割数', 
            '分割番号', 
            'レーンリストID(MPU)', 
            'レーンリストID(RC)', 
            '情報種別', 
            'Number of Array',
            'レーンリスト情報'], sheet.cellFormats('header'))
        col += 7
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
      
    def printValue(self, sheet, row, col, level = 1):
        newRow = row
        newCol = col
        [newRow, newCol, _] = self.commonHeader.printValue(sheet, newRow, newCol)
        sheet.write_row(newRow, newCol, [
            (self.segmentCount),
            (self.segmentIndex),
            (self.laneListID_MPU),
            (self.laneListID_RC),
            (self.classify),
            (self.numberOfArray)])
        newCol += 6
        valueLastCol = newCol

        groupResult = []
        if len(self.dataArray) > 0 and sheet.useMultiLine == True:
            for i in range(self.numberOfArray):
                [newRow, _, result] = rowGroupingPrint(
                    'レーンリスト情報(' + str(i+1) + ')', 
                    None, 
                    self.dataArray[i].printValue, 
                    sheet,
                    newRow, 
                    newCol, 
                    level)
                groupResult += result
            
            for c in range(col,valueLastCol):
                merge_rows(sheet, row, c, newRow-row)
        else:
            newRow += 1
            
        return [newRow, 0, groupResult]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    
    class LayerType(Enum):
        MainSubPath = 79
    
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.MainSubPath:
            symbolDic = {
                '"IVIpath" = 1 and "isIVISub" = 0':(QtGui.QColor.fromRgb(77,107,204),'Main-Path (IVI)', 0.4),
                '"IVIpath" = 1 and "isIVISub" = 1':(QtGui.QColor.fromRgb(204,107,77),'Sub-Path (IVI)', 0.4),
                '"MPUpath" = 1 and "isMPUSub" = 0':(QtGui.QColor.fromRgb(77,107,204),'Main-Path (MPU)', 0.4),
                '"MPUpath" = 1 and "isMPUSub" = 1':(QtGui.QColor.fromRgb(204,107,77),'Sub-Path (MPU)', 0.4),
                '"ADpath" = 1 and "isADSub" = 0':(QtGui.QColor.fromRgb(77,107,204),'Main-Path (AD)', 0.4),
                '"ADpath" = 1 and "isADSub" = 1':(QtGui.QColor.fromRgb(204,107,77),'Sub-Path (AD)', 0.4)}            
            layer = myQgsRendererRuleLayer(layer, symbolDic)
            return [layer, layerType.value]
        
        else:
            return None
    
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if (realTimeMode == DrawMode.QGIS_RealTimeDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw):
            return None
        
        newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=ln_id:string&field=IVIpath:int&field=MPUpath:int&field=ADpath:int&field=isIVISub:int&field=isMPUSub:int&field=isADSub:int&index=yes',name,'memory')
        newLayer = self.SetLayerStyle(self.LayerType.MainSubPath, newLayer)
        return [newLayer]
    
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        if (realTimeMode == DrawMode.QGIS_RealTimeDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw):
            return
        
        layer = None
        for layerListItem in layerList:
            if layerListItem[1] == ReconstructorLaneList.LayerType.MainSubPath.value:
                layer = layerListItem[0]
            
        if layer != None:
            if self.classify != 1: #classifyの時、１～５のメッセージをまとめて描画処理する。(各classifyの時[IVI/MPU/AD]毎に、PathIDは異なるが、敢えてまとめて処理するのは、laneLinkIDに対し、それぞれの[IVI/MPU/AD]情報を追加した上で、一つとして描画するため。)
                return 
            groupMessageList = []
            targetMessage = self.oldMessage
            while targetMessage != None:
                if targetMessage.classify == 1:
                    break
                if targetMessage.classify >= 3 or targetMessage.classify <= 5:
                    groupMessageList.append(targetMessage)
                targetMessage = targetMessage.oldMessage
            
            grouplaneLinkIDlist = {}
            laneLinkInfoDic = ProfileMessage.laneLinkInfoDic
            for message in groupMessageList:
                for item in message.dataArray:
                    pathID = item.pathID
                    if pathID in PathControlMessage.MainPathIDlist: isSub = 0
                    elif pathID in PathControlMessage.SubPathIDlist: isSub = 1
                    else: isSub = -1
                    for step in range(2):
                        laneLinkID = item.laneLinkID
                        while laneLinkID != 0: # base laneLinkIDしか通知されないため、左右レーンにも適用。
                            if laneLinkID in grouplaneLinkIDlist:
                                params = grouplaneLinkIDlist[laneLinkID]
                                isIVI = params[0]
                                isMPU = params[1]
                                isAD = params[2]
                                isIVISub = params[3]
                                isMPUSub = params[4]
                                isADSub = params[5]
                            else:
                                isIVI = 0
                                isMPU = 0
                                isAD = 0
                                isIVISub = 0
                                isMPUSub = 0
                                isADSub = 0
                            if message.classify == 3:
                                isIVI = 1
                                isIVISub = isSub
                            if message.classify == 4:
                                isMPU = 1
                                isMPUSub = isSub
                            if message.classify == 5:
                                isAD = 1
                                isADSub = isSub
                            grouplaneLinkIDlist[laneLinkID] = (isIVI, isMPU, isAD, isIVISub, isMPUSub, isADSub)
                            if step == 0:
                                if laneLinkID in laneLinkInfoDic:
                                    laneLinkID = laneLinkInfoDic[laneLinkID]['leftLaneID']
                                else:
                                    laneLinkID = 0
                            else:
                                if laneLinkID in laneLinkInfoDic:
                                    laneLinkID = laneLinkInfoDic[laneLinkID]['rightLaneID']
                                else:
                                    laneLinkID = 0
                            
            orderFeatures = []
            geometryDic = ProfileMessage.laneLinkGeometryDic
            for laneLinkID, params in grouplaneLinkIDlist.items():
                if laneLinkID in geometryDic:
                    pointList = geometryDic[laneLinkID]['geometry']
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(point[0], point[1]) for point in pointList]))
                    feature.setAttributes([QDateTime(self.commonHeader.logTime), str(laneLinkID), params[0], params[1], params[2], params[3], params[4], params[5]])
                    orderFeatures.append(feature)
            layer.dataProvider().addFeatures(orderFeatures)


#-----------------------------------------------#
#----   ADPositionMessage                   ----#
#-----------------------------------------------#
class ADPositionMessage(Message, AnalyzePositionError):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        AnalyzePositionError.__init__(self)     
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        ethernetSpecVersion = getEthernetSpecVer()
        if ethernetSpecVersion >= datetime(2020, 9, 30):
            self.offloadFlag = readFunc(int,16)
        else:
            self.offloadFlag = 0
        self.latitude = readFunc(int,32, True)
        self.longitude = readFunc(int,32, True)
        self.altitude = readFunc(int,32, True)
        self.direction = readFunc(int,32)
        self.laneLinkID = readFunc(int,64)
        self.offset = readFunc(int,32)
        self.assertMessageSize()
        
    def getAnalyzePositionErrorLonLat(self): #誤差評価対象となる経度緯度
        lat = self.latitude * 360.0 / (1<<32)
        lon = self.longitude * 360.0 / (1<<32)
        return [lon, lat]
        
    def getLonLat(self):
        lat = self.latitude * 360.0 / (1<<32)
        lon = self.longitude * 360.0 / (1<<32)
        return [lon, lat]
    
    def getLonLatZ(self, withBearing = False):
        lat = self.latitude * 360.0 / (1<<32)
        lon = self.longitude * 360.0 / (1<<32)
        z = self.altitude / 100.0 #cm -> m
        bearing = self.direction * 0.01
        if withBearing:
            return [lon, lat, z, bearing]
        else:
            return [lon, lat, z]

    def printHeader(self, sheet, row, col, _level = 1):
        sheet.set_row(0, 22.5)
        
        sheet.insert_button(row, 3, {'macro':   "'SmallFit \"A:" + getColumnName(self.commonHeader.columnCount() + 6) + "\"'",
                                    'caption': '-> 狭く表示 <-',
                                    'width':   100,
                                    'height':  30})
        
        sheet.insert_button(row, 6, {'macro':   "'AutoFit \"A:" + getColumnName(self.commonHeader.columnCount() + 6) + "\"'",
                                    'caption': '<- 広く表示 ->',
                                    'width':   100,
                                    'height':  30})
        
        sheet.insert_button(row, self.commonHeader.columnCount()+3, {'macro':   "'makePolyLineScript \"" + 
                                      getCellName(row+2, 1) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+2) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+1) + "\"'",
                                    'caption': '↓ 緯経度QGIS描画',
                                    'width':   120,
                                    'height':  30})
        
        row = row + 1
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write_row(row, col, [
            'オフロードフラグ',
            '緯度[deg]',
            '経度[deg]',
            '楕円体高度[cm]',
            '車両方位[deg]',
            'レーンリンクID',
            'Offset[m]'], sheet.cellFormats('header'))
        col += 7
        sheet.freeze_panes(2, 0)
        sheet.set_row(1, 20)
        sheet.autofilter(1, 0, 1, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [
            hex(self.offloadFlag),
            (self.latitude * 360.0 / (1<<32)),
            (self.longitude * 360.0 / (1<<32)),
            (self.altitude),
            (self.direction * 0.01),
            str(self.laneLinkID),
            (self.offset)])
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    
    class LayerType(Enum):
        ADPosition = 4
    
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == ADPositionMessage.LayerType.ADPosition:
            symbolDic = {
                0x0000:(QtGui.QColor.fromRgb(100,90,50),'highway', 0.6),
                0x8000:(QtGui.QColor.fromRgb(200,180,100),'offload')}            
            layer = myQgsRendererCategoryLayer(layer, symbolDic, 'offloadFlg')
            return [layer, layerType.value]
        
        else:
            return None
    
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if realTimeMode == DrawMode.FullDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw:
            newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&field=bearing:double&field=offloadFlg:int&index=yes',name,'memory')
        else:
            newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=offloadFlg:int',name,'memory')
        newLayer = self.SetLayerStyle(self.LayerType.ADPosition, newLayer)
        
        return [newLayer]
    
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        old = self.oldMessage
        for layerListItem in layerList:
            if layerListItem[1] == ADPositionMessage.LayerType.ADPosition.value:
                layer = layerListItem[0]
        
        if old != None:
            [lon, lat, z, bearing] = self.getLonLatZ(withBearing = True)
            [oldLon, oldLat, oldZ] = old.getLonLatZ()
            if checkInvalidLonLat(lon, lat, oldLon, oldLat, allowSamePoint = True) == True:
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPolyline(
                    [QgsPoint(oldLon, oldLat, oldZ), QgsPoint(lon, lat, z)] ))
                if realTimeMode == DrawMode.FullDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw:
                    feature.setAttributes([QDateTime(self.commonHeader.logTime), lon, lat, bearing, self.offloadFlag])
                else:
                    feature.setAttributes([self.offloadFlag])
                layer.dataProvider().addFeatures( [feature] )
        
#-----------------------------------------------#
#----   IVIPositionMessage                  ----#
#-----------------------------------------------#
class IVIPositionMessage(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.pathID = readFunc(int,32)
        self.offset = readFunc(int,32)
        self.laneLinkID = readFunc(int,64)
        self.latitude = readFunc(int,32,True)
        self.longitude = readFunc(int,32,True)
        self.altitude = readFunc(int,32,True)
        self.assertMessageSize()

    def printHeader(self, sheet, row, col, _level = 1):
        sheet.set_row(0, 22.5)
        
        sheet.insert_button(row, 3, {'macro':   "'SmallFit \"A:" + getColumnName(self.commonHeader.columnCount() + 5) + "\"'",
                                    'caption': '-> 狭く表示 <-',
                                    'width':   100,
                                    'height':  30})
        
        sheet.insert_button(row, 6, {'macro':   "'AutoFit \"A:" + getColumnName(self.commonHeader.columnCount() + 5) + "\"'",
                                    'caption': '<- 広く表示 ->',
                                    'width':   100,
                                    'height':  30})
        
        sheet.insert_button(row, self.commonHeader.columnCount()+3, {'macro':   "'makePolyLineScript \"" + 
                                      getCellName(row+2, 1) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+4) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+3) + "\"'",
                                    'caption': '↓ 緯経度QGIS描画',
                                    'width':   120,
                                    'height':  30})
        
        row = row + 1
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write_row(row, col, [
            'PathID',
            'Offset[m]',
            'レーンリンクID',
            '緯度[deg]',
            '経度[deg]',
            '楕円体高度[cm]'], sheet.cellFormats('header'))
        col += 6
        sheet.freeze_panes(2, 0)
        sheet.set_row(1, 20)
        sheet.autofilter(1, 0, 1, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [
            (hex(self.pathID)),
            (self.offset),
            str(self.laneLinkID),
            (self.latitude * 360.0 / (1<<32)),
            (self.longitude * 360.0 / (1<<32)),
            (self.altitude)])
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    
    class LayerType(Enum):
        IVIPosition = 7
    
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.IVIPosition:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(0,255,0))
            symbol.setWidth(1.2)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
        
        else:
            return None
            
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if (realTimeMode == DrawMode.QGIS_RealTimeDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw):
            # リアルタイム描画では、R-DRは描画しない
            return None
        
        newLayer_iviPos = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&index=yes',name,'memory')
        newLayer_iviPos = self.SetLayerStyle(self.LayerType.IVIPosition, newLayer_iviPos)
        
        return [newLayer_iviPos]
        
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        old = self.oldMessage
        if (realTimeMode == DrawMode.QGIS_RealTimeDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw):
            # リアルタイム描画では、IVI Position Messageは描画しない
            return
        
        for layerListItem in layerList:
            if layerListItem[1] == IVIPositionMessage.LayerType.IVIPosition.value:
                newLayer_iviPos = layerListItem[0]
        
        if old != None:
            lat = self.latitude * 360.0 / (1<<32)
            lon = self.longitude * 360.0 / (1<<32)
            oldLat = old.latitude * 360.0 / (1<<32)
            oldLon = old.longitude * 360.0 / (1<<32)
            if checkInvalidLonLat(lon, lat, oldLon, oldLat, allowSamePoint = True) == True:
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPolyline(
                    [QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)] ))
                feature.setAttributes([QDateTime(self.commonHeader.logTime), lon, lat])
                newLayer_iviPos.dataProvider().addFeatures( [feature] )
    
#-----------------------------------------------#
#----   ADASIS_GlobalDataMessage            ----#
#-----------------------------------------------#
class ADASIS_GlobalDataMessage(Message, SegmentableMessage):
    MPU_pos = [180, 180] #Lon, Lat
    AD_pos = [180, 180] #Lon, Lat

    class ProfileData: 
        profileType: int
        availability: int
        profileValue: ProfileType
        
        def printValue(self, sheet, row, col, level = 1):
            newRow = row
            newCol = col
            
            sheet.write_row(newRow, newCol, [
                (hex(self.profileType)),
                (self.availability)], sheet.cellFormats('default'))
            newCol += 2
            
            if self.profileType in profileIdDic:
                profileName = profileIdDic[self.profileType]['name']
            else:
                profileName = 'Unknown Profile'
                
            groupResult = []
            if sheet.useMultiLine == True:
                [newRow, _, result] = rowGroupingPrint(
                    profileName, 
                    None, 
                    self.profileValue.printValue, 
                    sheet,
                    newRow, 
                    newCol, 
                    level)
                groupResult += result
    
                for c in range(4):
                    merge_rows(sheet, row, col + c, newRow-row)
                    
            elif type(self.profileValue) == PROFILE_MPU_MAP_DATA_TRANSFER_STS:
                sheet.write(newRow, newCol, profileName, sheet.cellFormats('merge'))
                [_, newCol, groupResult] = self.profileValue.printValue(sheet, newRow, newCol + 1, level + 1)
                newCol = newCol + 2
                
            else:
                sheet.write(newRow, newCol, profileName, sheet.cellFormats('merge'))
                newCol = newCol + 1
             
            return [newRow, col, groupResult]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.segmentCount = readFunc(int,16)
        self.segmentIndex = readFunc(int,16)
        self.dataArrayCount = 0
        self.dataArray = []
        self.MPU_pos = ADASIS_GlobalDataMessage.MPU_pos 
        self.AD_pos = ADASIS_GlobalDataMessage.AD_pos
        self.mergeSegmentData(None, self.segmentIndex, self.segmentCount, self.data.getDataBuf()[self.data.seek():])
    
    def parseMergedData(self, data):
        readFunc = data.readValue
        self.dataArrayCount = readFunc(int,32)
        self.dataArray = []
        for _ in range(self.dataArrayCount):
            profileData = self.ProfileData()
            profileData.profileType = readFunc(int,32)
            profileData.availability = readFunc(int,32)
            profileData.profileValue = analyzeProfile(profileData.profileType, data, self)
            self.dataArray.append(profileData)
            
            if type(profileData.profileValue) == AbsoluteVehiclePositionProfile:
                if profileData.profileValue.classify == 0x00: #MPU
                    self.MPU_pos = [profileData.profileValue.longitude * 360.0 / (1<<32),
                                    profileData.profileValue.latitude * 360.0 / (1<<32)]
                    ADASIS_GlobalDataMessage.MPU_pos = self.MPU_pos
                elif profileData.profileValue.classify == 0x01: #AD
                    self.AD_pos = [profileData.profileValue.longitude * 360.0 / (1<<32),
                                    profileData.profileValue.latitude * 360.0 / (1<<32)]
                    ADASIS_GlobalDataMessage.AD_pos = self.AD_pos
            elif type(profileData.profileValue) == UnknownProfile:
                break #Cannot recognize profile data. so, read size not defined. no more read.
        
    def printHeader(self, sheet, row, col, _level = 1):
        sheet.set_row(0, 22.5)
        
        sheet.insert_button(row, 3, {'macro':   "'SmallFit \"A:" + getColumnName(self.commonHeader.columnCount() + 5) + "\"'",
                                    'caption': '-> 狭く表示 <-',
                                    'width':   100,
                                    'height':  30})
        
        sheet.insert_button(row, 6, {'macro':   "'AutoFit \"A:" + getColumnName(self.commonHeader.columnCount() + 5) + "\"'",
                                    'caption': '<- 広く表示 ->',
                                    'width':   100,
                                    'height':  30})
        
        sheet.insert_button(row, self.commonHeader.columnCount()+7, {'macro':   "'makePolyLineScript \"" + 
                                      getCellName(row+2, 1) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+8) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+7) + "\"'",
                                    'caption': '↓ 緯経度QGIS描画',
                                    'width':   120,
                                    'height':  30})
        
        [_, col, _] = self.commonHeader.printHeader(sheet, row+1, col)
        
        sheet.write_row(row+1, col, [
            '分割数', 
            '分割番号', 
            'Number of Array',
            'Profile Type',
            'Availability',
            'Profile Value'], sheet.cellFormats('header'))
        col += 6
        
        sheet.set_row(1, 20)
        sheet.autofilter(1, 0, 1, col+5) #include profile Value
        sheet.freeze_panes(2, 0)
        
        return [row+2, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        newRow = row
        newCol = col
        [_, newCol, _] = self.commonHeader.printValue(sheet, newRow, newCol)
        sheet.write_row(newRow, newCol, [
            (self.segmentCount),
            (self.segmentIndex),
            (self.dataArrayCount)], sheet.cellFormats('default'))
        newCol += 3
        valueLastCol = newCol
        
        if len(self.dataArray) > 0:
            if sheet.useMultiLine == True:
                for profileData in self.dataArray:
                    [newRow, _, _] = profileData.printValue(sheet, newRow, newCol)
                for c in range(col,valueLastCol):
                    merge_rows(sheet, row, c, newRow-row)
                    
            else:
                for profileData in self.dataArray:
                    [_, newCol, _] = profileData.printValue(sheet, newRow, newCol)
                newRow += 1
                
        else:
            newRow += 1
        
        return [newRow, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
    class LayerType(Enum):
        ADASIS_GlobalData_MPUPos = 86
        ADASIS_GlobalData_ADPos = 87
    
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.ADASIS_GlobalData_MPUPos or layerType == cls.LayerType.ADASIS_GlobalData_ADPos:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(0,0,0))
            symbol.setWidth(0.2)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
        
        else:
            return None
                
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if (realTimeMode == DrawMode.QGIS_RealTimeDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw): #リアルタイム描画時は描画しない
            return None
        
        newLayer_mpuPos = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&index=yes',name+'(MPUPos)','memory')
        newLayer_mpuPos = self.SetLayerStyle(self.LayerType.ADASIS_GlobalData_MPUPos, newLayer_mpuPos)
        
        newLayer_adPos = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&index=yes',name+'(ADPos)','memory')
        newLayer_adPos = self.SetLayerStyle(self.LayerType.ADASIS_GlobalData_ADPos, newLayer_adPos)
                
        return [newLayer_mpuPos, newLayer_adPos]
        
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        old = self.oldMessage
        if (realTimeMode == DrawMode.QGIS_RealTimeDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw): #リアルタイム描画時は描画しない
            return
        
        for layerListItem in layerList:
            if layerListItem[1] == ADASIS_GlobalDataMessage.LayerType.ADASIS_GlobalData_MPUPos.value:
                layer_mpuPos = layerListItem[0]
            elif layerListItem[1] == ADASIS_GlobalDataMessage.LayerType.ADASIS_GlobalData_ADPos.value:
                layer_adPos = layerListItem[0]
        
        if old == None:
            return
        
        if len(self.dataArray) > 0:
            for profileData in self.dataArray:
                if type(profileData.profileValue) == AbsoluteVehiclePositionProfile:

                    if profileData.profileValue.classify == 0x00: #MPU
                        if checkInvalidLonLat(self.MPU_pos[0], self.MPU_pos[1], old.MPU_pos[0], old.MPU_pos[1], allowSamePoint = True) == True:
                            feature = QgsFeature()
                            feature.setGeometry(QgsGeometry.fromPolyline(
                                [QgsPoint(old.MPU_pos[0], old.MPU_pos[1]), QgsPoint(self.MPU_pos[0], self.MPU_pos[1])]))
                            feature.setAttributes([QDateTime(self.commonHeader.logTime), self.MPU_pos[0], self.MPU_pos[1]])
                            layer_mpuPos.dataProvider().addFeatures( [feature] )

                    elif profileData.profileValue.classify == 0x01: #AD
                        if checkInvalidLonLat(self.AD_pos[0], self.AD_pos[1], old.AD_pos[0], old.AD_pos[1], allowSamePoint = True) == True:
                            feature = QgsFeature()
                            feature.setGeometry(QgsGeometry.fromPolyline(
                                [QgsPoint(old.AD_pos[0], old.AD_pos[1]), QgsPoint(self.AD_pos[0], self.AD_pos[1])]))
                            feature.setAttributes([QDateTime(self.commonHeader.logTime), self.AD_pos[0], self.AD_pos[1]])
                            layer_adPos.dataProvider().addFeatures( [feature] )

    
#-----------------------------------------------#
#----   SensorDataMessage                   ----#
#-----------------------------------------------#
class SensorDataMessage(Message):
    @dataclass
    class Data:
        timeStamp: int #48
        timeStamp_old: int #48
        invalidFlag: int #16
        xV: int #16S
        yV: int #16S
        zV: int #16S
        temprature: int #16S
        
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.gyroSensor = self.Data(
            timeStamp = readFunc(int,48),
            timeStamp_old = oldMessage.gyroSensor.timeStamp if oldMessage != None else 0,
            invalidFlag = readFunc(int,16),
            xV = readFunc(int,16,True),
            yV = readFunc(int,16,True),
            zV = readFunc(int,16,True),
            temprature = readFunc(int,16,True))
        self.IMUSensor = self.Data(
            timeStamp = readFunc(int,48),
            timeStamp_old = oldMessage.IMUSensor.timeStamp if oldMessage != None else 0,
            invalidFlag = readFunc(int,16),
            xV = readFunc(int,16,True),
            yV = readFunc(int,16,True),
            zV = readFunc(int,16,True),
            temprature = readFunc(int,16,True))
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        newCol = col
        sheet.write(row, newCol, 'Common Header', sheet.cellFormats('header'))
        merge_cols(sheet, row, newCol, self.commonHeader.columnCount(), True)
        newCol += self.commonHeader.columnCount()
        sheet.write(row, newCol, 'ジャイロセンサ', sheet.cellFormats('header'))
        merge_cols(sheet, row, newCol, 7, True)
        newCol += 7
        sheet.write(row, newCol, '加速度センサ', sheet.cellFormats('header'))
        merge_cols(sheet, row, newCol, 7, True)
        
        newCol = col
        [_, newCol, _] = self.commonHeader.printHeader(sheet, row+1, newCol)
        
        sheet.write_row(row+1, newCol, ['タイムスタンプ[μs]', '差分[ms]', '無効フラグ', 'x軸角速度[deg/s]', 'y軸角速度[deg/s]', 'z軸角速度[deg/s]', '温度[deg]'], sheet.cellFormats('header'))
        newCol += 7
        
        sheet.write_row(row+1, newCol, ['タイムスタンプ[μs]', '差分[ms]', '無効フラグ', 'x軸加速度[g]', 'y軸加速度[g]', 'z軸加速度[g]', '温度[deg]'], sheet.cellFormats('header'))
        newCol += 7
        
        sheet.freeze_panes(2, 0)
        sheet.set_row(0, 20)
        sheet.set_row(1, 20)
        sheet.autofilter(1, 0, 1, newCol-1)
        
        return [row+2, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [
            (self.gyroSensor.timeStamp),
            (self.gyroSensor.timeStamp - self.gyroSensor.timeStamp_old) / 1000,
            hex(self.gyroSensor.invalidFlag),
            (self.gyroSensor.xV / 262.14),
            (self.gyroSensor.yV / 262.14),
            (self.gyroSensor.zV / 262.14),
            (self.gyroSensor.temprature * 0.1),
            (self.IMUSensor.timeStamp),
            (self.IMUSensor.timeStamp - self.IMUSensor.timeStamp_old) / 1000,
            hex(self.IMUSensor.invalidFlag),
            (self.IMUSensor.xV / 1024.0),
            (self.IMUSensor.yV / 1024.0),
            (self.IMUSensor.zV / 1024.0),
            (self.IMUSensor.temprature * 0.1)])
        
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
        chart = book.add_chart({'type': 'line'})
        chart.set_title({
            'name': 'ジャイロセンサ タイムスタンプ[μs]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'values':     "='{0}'!$K$1:$K${1}".format(sheet.name, totalRows)})
        sheet.insert_chart('C18', chart)
        
        chart = book.add_chart({'type': 'scatter'})
        chart.set_title({
            'name': 'ジャイロセンサ タイムスタンプ 差分[ms]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'name': '間隔[ms]',
            'categories': "='{0}'!$A$1:$A${1}".format(sheet.name, totalRows),
            'values':     "='{0}'!$L$1:$L${1}".format(sheet.name, totalRows)})
        chart.set_y_axis({'min': 0, 'max': 40})
        sheet.insert_chart('J18', chart)
        
        chart = book.add_chart({'type': 'line'})
        chart.set_title({
            'name': '加速度センサ タイムスタンプ[μs]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'values':     "='{0}'!$R$1:$R${1}".format(sheet.name, totalRows)})
        sheet.insert_chart('C32', chart)
        
        chart = book.add_chart({'type': 'scatter'})
        chart.set_title({
            'name': '加速度センサ タイムスタンプ 差分[ms]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'name': '間隔[ms]',
            'categories': "='{0}'!$A$1:$A${1}".format(sheet.name, totalRows),
            'values':     "='{0}'!$S$1:$S${1}".format(sheet.name, totalRows)})
        chart.set_y_axis({'min': 0, 'max': 40})
        sheet.insert_chart('J32', chart)
    
    
#-----------------------------------------------#
#----   GNSSDataMessage                     ----#
#-----------------------------------------------#
class GNSSDataMessage(Message, AnalyzePositionError):
    FixTypeAugDic = {0x00: '[0x00]非測位', 0x02: '[0x02]単独測位(2D)', 0x04: '[0x04]単独測位', 0x06: '[0x06]無効値(入力飛び)', 0x07: '[0x07]CLAS(FLOAT)', 0x08: '[0x08]CLAS(FIX)', 0x09: '[0x09]RTX', 0xff: '[0xff]無効値'}
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        AnalyzePositionError.__init__(self)
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.timeStamp = readFunc(int,48)
        if oldMessage == None:
            self.timeStamp_old = 0
        else:
            self.timeStamp_old = oldMessage.timeStamp
            
        self.invalidFlag = readFunc(int,16)
        self.iTOW = readFunc(int,32)
        self.year = readFunc(int,16)
        self.month = readFunc(int,8)
        self.day = readFunc(int,8)
        self.hour = readFunc(int,8)
        self.min = readFunc(int,8)
        self.sec = readFunc(int,8)
        readFunc(int,8) #reserved
        self.tAcc = readFunc(int,32)
        self.fixType = readFunc(int,8)
        self.numSV = readFunc(int,8)
        readFunc(int,16) #reserved
        self.lon = readFunc(int,32,True)
        self.lat = readFunc(int,32,True)
        self.height = readFunc(int,32,True)
        self.hMSL = readFunc(int,32,True)
        self.hAcc = readFunc(int,32)
        self.vAcc = readFunc(int,32)
        self.velN = readFunc(int,32,True)
        self.velE = readFunc(int,32,True)
        self.velD = readFunc(int,32,True)
        self.gSpeed = readFunc(int,32,True)
        self.headMot = readFunc(int,32,True)
        self.sAcc = readFunc(int,32)
        self.headAcc = readFunc(int,32)
        self.pDOP = readFunc(int,16)
        readFunc(int,16) #reserved
        self.headVeh = readFunc(int,32,True)
        self.lon_JGD = readFunc(int,32,True)
        self.lat_JGD = readFunc(int,32,True)
        self.height_JGD = readFunc(int,32,True)
        
        ethernetSpecVersion = getEthernetSpecVer()
        if ethernetSpecVersion >= datetime(2020, 9, 4):
            self.lonAug = readFunc(int,32,True)
            self.latAug = readFunc(int,32,True)
            self.heightAug = readFunc(int,32,True)
            self.hMSLAug = readFunc(int,32,True)
            self.velNAug = readFunc(int,32,True)
            self.velEAug = readFunc(int,32,True)
            self.velDAug = readFunc(int,32,True)
            self.gSpeedAug = readFunc(int,32)
            self.headMotAug = readFunc(int,32)
            self.pDOPAug = readFunc(int,16)
            self.hDOPAug = readFunc(int,16)
            self.vDOPAug = readFunc(int,16)
            self.tDOPAug = readFunc(int,16)
            self.headVehAug = readFunc(int,32)
            self.lon_JGDAug = readFunc(int,32,True)
            self.lat_JGDAug = readFunc(int,32,True)
            self.height_JGDAug = readFunc(int,32,True)
            self.augumentedAcc = readFunc(int,16)
            self.ageAug = readFunc(int,16)
            self.fixTypeAug = readFunc(int,8)
            if self.fixTypeAug == 0xff and oldMessage != None: # 周期関係上、2回に１回は無効値
                self.fixTypeAugOld = oldMessage.fixTypeAugOld
            else:
                self.fixTypeAugOld = self.fixTypeAug
            self.numSVAug = readFunc(int,8)
            
        else:
            self.lonAug = 0
            self.latAug = 0
            self.heightAug = 0
            self.hMSLAug = 0
            self.velNAug = 0
            self.velEAug = 0
            self.velDAug = 0
            self.gSpeedAug = 0
            self.headMotAug = 0
            self.pDOPAug = 0
            self.hDOPAug = 0
            self.vDOPAug = 0
            self.tDOPAug = 0
            self.headVehAug = 0
            self.lon_JGDAug = 0
            self.lat_JGDAug = 0
            self.height_JGDAug = 0
            self.augumentedAcc = 0
            self.ageAug = 0
            self.fixTypeAug = 0
            self.fixTypeAugOld = 0
            self.numSVAug = 0

        self.assertMessageSize()
            
    def printHeader(self, sheet, row, col, _level = 1):
        sheet.set_row(0, 22.5)
        
        sheet.insert_button(row, 3, {'macro':   "'SmallFit \"A:" + getColumnName(self.commonHeader.columnCount() + 29) + "\"'",
                                    'caption': '-> 狭く表示 <-',
                                    'width':   100,
                                    'height':  30})
        
        sheet.insert_button(row, 6, {'macro':   "'AutoFit \"A:" + getColumnName(self.commonHeader.columnCount() + 29) + "\"'",
                                    'caption': '<- 広く表示 ->',
                                    'width':   100,
                                    'height':  30})
        
        sheet.insert_button(row, self.commonHeader.columnCount()+13, {'macro':   "'makePolyLineScript \"" + 
                                      getCellName(row+2, 1) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+13) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+14) + "\"'",
                                    'caption': '↓ 緯経度QGIS描画',
                                    'width':   120,
                                    'height':  30})
        
        sheet.insert_button(row, self.commonHeader.columnCount()+17, {'macro':   "'makeDistributionScript \"" + 
                                      getCellName(row+2, 1) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+13) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+14) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+17) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+18) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+27) + "\"'",
                                    'caption': '↓ 誤差QGIS描画',
                                    'width':   120,
                                    'height':  30})
        
        sheet.insert_button(row, self.commonHeader.columnCount()+19, {'macro':   "'makeVelocityVectorScript \"" + 
                                      getCellName(row+2, 1) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+13) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+14) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+19) + "\",\"" + 
                                      getCellName(row+2, self.commonHeader.columnCount()+20) + "\"'",
                                    'caption': '↓ 速度QGIS描画',
                                    'width':   120,
                                    'height':  30})
        
        [_, col, _] = self.commonHeader.printHeader(sheet, row+1, col)

        nameList = [
            'タイムスタンプ[μs]',
            '差分[μs]',
            '無効フラグ',
            '週の時間[ms]',
            'year',
            'month',
            'day',
            'hour',
            'min',
            'sec',
            '時刻精度',
            'ステータス',
            '衛星数',
            '経度[deg]',
            '緯度[deg]',
            '楕円体高[mm]',
            '平均海面上高度[mm]',
            '水平精度[mm]',
            '垂直精度[mm]',
            '北向き速度[mm/s]',
            '東向き速度[mm/s]',
            '下向き速度[mm/s]',
            '対地速度[mm/s]',
            'モーションの方位[deg]',
            '速度精度[mm/s]',
            'ヘディング精度[deg]',
            '精度低下率',
            '車両方位[deg]',
            '経度(JGD2011)[deg]',
            '緯度(JGD2011)[deg]',
            '楕円体高(JGD2011)[mm]',
            '経度(補強信号考慮)[deg]',
            '緯度(補強信号考慮)[deg]',
            '楕円体高（HEA）(補強信号考慮)[mm]',
            '平均海面上高度(補強信号考慮)[mm]',
            '北向き速度(補強信号考慮)[mm/s]',
            '東向き速度(補強信号考慮)[mm/s]',
            '下向き速度(補強信号考慮)[mm/s]',
            '対地速度(補強信号考慮)[mm/s]',
            'モーションの方位(補強信号考慮)[deg]',
            '精度低下率(補強信号補正演算)',
            '水平精度低下率(補強信号補正演算)',
            '垂直精度低下率(補強信号補正演算)',
            '時刻精度低下率(補強信号補正演算)',
            '車両方位(補強信号考慮)[deg]',
            '経度(JGD2011)-補強信号考慮[deg]',
            '緯度(JGD2011)-補強信号考慮[deg]',
            '楕円体高（HEA）(JGD2011)-補強信号考慮[mm]',
            '衛星測位信頼度(補強信号考慮)',
            '補正信号継続時間[s]',
            '2周波補強信号考慮測位ステータス',
            '2周波測位使用衛星数(補強信号補正演算)',
            '2周波補強信号考慮測位ステータス(引き継ぎ)']
        
        sheet.write_row(row+1, col, nameList, sheet.cellFormats('header'))
        col += len(nameList)

        sheet.set_row(1, 20)
        sheet.autofilter(1, 0, 1, col-1)
        sheet.freeze_panes(2, 0)
        
        return [row+2, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [
            (self.timeStamp),
            (self.timeStamp - self.timeStamp_old) / 1000,
            hex(self.invalidFlag),
            (self.iTOW),
            (self.year),
            (self.month),
            (self.day),
            (self.hour),
            (self.min),
            (self.sec),
            (self.tAcc),
            (self.fixType),
            (self.numSV),
            (self.lon * 360.0 / (1<<32)),
            (self.lat * 360.0 / (1<<32)),
            (self.height),
            (self.hMSL),
            (self.hAcc),
            (self.vAcc),
            (self.velN),
            (self.velE),
            (self.velD),
            (self.gSpeed),
            (self.headMot * 0.00001),
            (self.sAcc),
            (self.headAcc * 0.00001),
            (self.pDOP * 0.01),
            (self.headVeh * 0.00001),
            (self.lon_JGD * 360.0 / (1<<32)),
            (self.lat_JGD * 360.0 / (1<<32)),
            (self.height_JGD),
            (self.lonAug * 360.0 / (1<<32)),
            (self.latAug * 360.0 / (1<<32)),
            (self.heightAug),
            (self.hMSLAug),
            (self.velNAug),
            (self.velEAug),
            (self.velDAug),
            (self.gSpeedAug),
            (self.headMotAug * 0.00001),
            (self.pDOPAug * 0.01),
            (self.hDOPAug * 0.01),
            (self.vDOPAug * 0.01),
            (self.tDOPAug * 0.01),
            (self.headVehAug * 0.00001),
            (self.lon_JGDAug * 360.0 / (1<<32)),
            (self.lat_JGDAug * 360.0 / (1<<32)),
            (self.height_JGDAug),
            (self.augumentedAcc * 0.1),
            (self.ageAug * 0.2),
            GNSSDataMessage.FixTypeAugDic.get(self.fixTypeAug, '[error]'),
            (self.numSVAug),
            GNSSDataMessage.FixTypeAugDic.get(self.fixTypeAugOld, '[error]')
            ])
        
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
        chart = book.add_chart({'type': 'line'})
        chart.set_title({
            'name': 'センサ情報受信時タイムスタンプ[μs]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'values':     "='{0}'!$K$1:$K${1}".format(sheet.name, totalRows)})
        sheet.insert_chart('C18', chart)
        
        chart = book.add_chart({'type': 'scatter'})
        chart.set_title({
            'name': 'センサ情報受信時タイムスタンプ 差分[ms]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'name': '間隔[ms]',
            'categories': "='{0}'!$A$1:$A${1}".format(sheet.name, totalRows),
            'values':     "='{0}'!$L$1:$L${1}".format(sheet.name, totalRows)})
        chart.set_y_axis({'min': 180, 'max': 220})
        sheet.insert_chart('J18', chart)
                
        chart = book.add_chart({'type': 'line'})
        chart.set_title({
            'name': '衛星数'})
        chart.add_series({
            'name': '衛星数',
            'values':     "='{0}'!$W$1:$W${1}".format(sheet.name, totalRows)})
        chart.add_series({
            'name': 'CLAS衛星数',
            'values':     "='{0}'!$BJ$1:$BJ${1}".format(sheet.name, totalRows)})
        sheet.insert_chart('X4', chart)
    
    class LayerType(Enum):
        GNSS_Vehicle_Speed = 1
        GNSS_Location = 2
        GPS_Location = 9
        GPS_ErrProb = 16
        GNSS_AUGACC_ErrProb = 17
        GNSS_ErrDist = 18
    
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.GNSS_Location:
            symbolDic = {
                0:(QtGui.QColor.fromRgb(0,0,0),'None', 1.0),
                2:(QtGui.QColor.fromRgb(255,200,0),'Single(2D)', 0.5),
                4:(QtGui.QColor.fromRgb(255,200,0),'Single', 0.5),
                6:(QtGui.QColor.fromRgb(0,0,0),'Invalid', 0.5),
                7:(QtGui.QColor.fromRgb(255,111,111),'Float', 0.5),
                8:(QtGui.QColor.fromRgb(255,0,0),'Fix', 0.5),
                9:(QtGui.QColor.fromRgb(255,0,0),'RTX', 0.5),
                255:(QtGui.QColor.fromRgb(0,0,0),'Invalid', 0.5)}
            layer = myQgsRendererCategoryLayer(layer, symbolDic, 'fixTypeAug')
            return [layer, layerType.value]
            
        elif layerType == cls.LayerType.GNSS_Vehicle_Speed:
            #!!!！なぜか以下のコードで矢印を描くと、一部のPCではQgisがCrashする。!!!！
            #sl = QgsSymbolLayerRegistry().symbolLayerMetadata('ArrowLine').createSymbolLayer({ 'width' : '0.1', 'color' : '255,0,0' })     
            #symbollist = newLayer_v.renderer().symbols(QgsRenderContext())
            #symbol = symbollist[0]
            #symbol.appendSymbolLayer(sl)
            #以下のコードなら大丈夫だった
            symLyr = QgsArrowSymbolLayer()
            symLyr.setIsCurved(False)
            symLyr.setIsRepeated(False)
            symLyr.setColor(QtGui.QColor.fromRgb(255,0,0))
            layer.renderer().symbols(QgsRenderContext())[0].changeSymbolLayer(0, symLyr)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.GPS_ErrProb or layerType == cls.LayerType.GNSS_AUGACC_ErrProb or layerType == cls.LayerType.GNSS_ErrDist:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(255,100,100))
            symbol.setWidth(1)
            symbol.setOpacity(0.5)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.GPS_Location:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(0,0,0))
            symbol.setWidth(0.5)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
        
        else:
            return None
    
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        #realTime描画でない場合のみ、速度矢印を描く
        if realTimeMode == DrawMode.FullDraw:
            newLayer_v = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&field=North[km/h]:double&field=East[km/h]:double&index=yes',name+'(V)','memory')
            newLayer_v = self.SetLayerStyle(self.LayerType.GNSS_Vehicle_Speed, newLayer_v)
        elif realTimeMode == DrawMode.QGIS_RealTimeDraw:
            newLayer_v = iface_obj.addVectorLayer('LineString?crs=epsg:4612',name+'(V)','memory')
            newLayer_v = self.SetLayerStyle(self.LayerType.GNSS_Vehicle_Speed, newLayer_v)

        if realTimeMode == DrawMode.FullDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw:
            newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&field=bearing:double&field=fixTypeAug:int&field=numSVAug:int&index=yes',name,'memory')
        else:
            newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=fixTypeAug:int&field=numSVAug:int',name,'memory')
        newLayer = self.SetLayerStyle(self.LayerType.GNSS_Location, newLayer)
        
        if realTimeMode == DrawMode.FullDraw:
            newLayer_errProb = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&field=hAcc[mm]:double&field=vAcc[mm]:double&field=Theta[Deg]:double&index=yes',name+'(errProb)','memory')
            newLayer_errProb = self.SetLayerStyle(self.LayerType.GPS_ErrProb, newLayer_errProb)
            newLayer_accProb = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&field=acc:double&index=yes',name+'(accProb)','memory')
            newLayer_accProb = self.SetLayerStyle(self.LayerType.GNSS_AUGACC_ErrProb, newLayer_accProb)
                        
            newLayer_gpsPos = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&field=numSV:int&index=yes',name+'(GPS)','memory')
            newLayer_gpsPos = self.SetLayerStyle(self.LayerType.GPS_Location, newLayer_gpsPos)
            
            if self.positionError != None:
                newLayer_errDist = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=errorDistance[m]:double&index=yes',name+'(errDist)','memory')
                newLayer_errDist = self.SetLayerStyle(self.LayerType.GNSS_ErrDist, newLayer_errDist)
        
        GNSSDataMessage.oldVpoint = None
        
        if realTimeMode == DrawMode.FullDraw:
            if self.positionError != None:
                return [newLayer_v, newLayer, newLayer_gpsPos, newLayer_errProb, newLayer_accProb, newLayer_errDist]
            else:
                return [newLayer_v, newLayer, newLayer_gpsPos, newLayer_errProb, newLayer_accProb]
        elif realTimeMode == DrawMode.QGIS_RealTimeDraw:
            return [newLayer_v, newLayer]
        elif realTimeMode == DrawMode.OpenGL_RealTimeDraw:
            return [newLayer]
    
    def getAnalyzePositionErrorLonLat(self): #誤差評価対象となる経度緯度
        return self.getLonLat()
        
    def getLonLat(self, withNotAug = False):
        lat = self.lat_JGDAug * 360.0 / (1<<32)
        lon = self.lon_JGDAug * 360.0 / (1<<32)
        lat_notAug = self.lat_JGD * 360.0 / (1<<32)
        lon_notAug = self.lon_JGD * 360.0 / (1<<32)
        if checkInvalidLonLat(lon, lat) == False:
            lat = lat_notAug
            lon = lon_notAug
        if withNotAug:
            return [lon, lat, lon_notAug, lat_notAug]
        else:
            return [lon, lat]
    
    def getLonLatZ(self, withBearing = False, withNotAug = False):
        lat = self.lat_JGDAug * 360.0 / (1<<32)
        lon = self.lon_JGDAug * 360.0 / (1<<32)
        z = self.height_JGDAug / 1000.0 # mm -> m
        bearing = self.headVehAug * 0.00001
        lat_notAug = self.lat_JGD * 360.0 / (1<<32)
        lon_notAug = self.lon_JGD * 360.0 / (1<<32)
        z_notAug = self.height_JGD / 1000.0 # mm -> m
        bearing_notAug = self.headVeh * 0.00001
        if checkInvalidLonLat(lon, lat) == False:
            lat = lat_notAug
            lon = lon_notAug
            z = z_notAug
            bearing = bearing_notAug
        if withNotAug:
            if withBearing:
                return [lon, lat, z, bearing, lon_notAug, lat_notAug, z_notAug, bearing_notAug]
            else:
                return [lon, lat, z, lon_notAug, lat_notAug, z_notAug]
        else:
            if withBearing:
                return [lon, lat, z, bearing]
            else:
                return [lon, lat, z]
        
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        old = self.oldMessage
        layer_v = None
        layer_p = None
        layer_gpsPos = None
        layer_e = None
        layer_acc = None
        layer_ed = None
        for layerListItem in layerList:
            if layerListItem[1] == GNSSDataMessage.LayerType.GNSS_Vehicle_Speed.value:
                layer_v = layerListItem[0]
            elif layerListItem[1] == GNSSDataMessage.LayerType.GNSS_Location.value:
                layer_p = layerListItem[0]
            elif layerListItem[1] == GNSSDataMessage.LayerType.GPS_Location.value:
                layer_gpsPos = layerListItem[0]
            elif layerListItem[1] == GNSSDataMessage.LayerType.GPS_ErrProb.value:
                layer_e = layerListItem[0]
            elif layerListItem[1] == GNSSDataMessage.LayerType.GNSS_AUGACC_ErrProb.value:
                layer_acc = layerListItem[0]
            elif layerListItem[1] == GNSSDataMessage.LayerType.GNSS_ErrDist.value:
                layer_ed = layerListItem[0]
                
        if self.invalidFlag == 0x8000: #無効なGNSSメッセージ
            return
        
        [lon, lat, z, bearing, lon_notAug, lat_notAug, z_notAug, bearing_notAug] = self.getLonLatZ(withBearing = True, withNotAug = True)         
        if old != None:
            [oldLon, oldLat, oldZ, oldLon_notAug, oldLat_notAug, oldZ_notAug] = old.getLonLatZ(withNotAug = True)
        else:
            [oldLon, oldLat, oldZ, oldLon_notAug, oldLat_notAug, oldZ_notAug] = [180, 180, 0, 180, 180, 0]
        
        if checkInvalidLonLat(lon_notAug, lat_notAug) == True and (realTimeMode == DrawMode.FullDraw):
            scaleRate = 0.000000009
            eclipsePointList = []
            attrList = [
                QDateTime(self.commonHeader.logTime),
                lon_notAug,
                lat_notAug,
                self.hAcc,
                self.vAcc,
                -(self.headVeh * 0.00001) + 90] #北が0度、時計回りにしているため、XY座標に変換
            for t in range(0, 361, 20):
                w = math.radians(t)
                th = math.radians(attrList[5])
                eclipsePointList.append(QgsPoint(
                    attrList[1] + scaleRate*(attrList[3]*math.cos(w)*math.cos(th) - attrList[4]*math.sin(w)*math.sin(th)),
                    attrList[2] + scaleRate*(attrList[3]*math.cos(w)*math.sin(th) + attrList[4]*math.sin(w)*math.cos(th)),
                    z_notAug
                ))
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline(eclipsePointList))
            feature.setAttributes(attrList)
            layer_e.dataProvider().addFeatures( [feature] )
            
            if checkInvalidLonLat(lon_notAug, lat_notAug, oldLon_notAug, oldLat_notAug, allowSamePoint = True) == True:   
                fixTypeAug = self.fixTypeAugOld
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPolyline(
                    [QgsPoint(oldLon_notAug, oldLat_notAug, oldZ_notAug), QgsPoint(lon_notAug, lat_notAug, z_notAug)]))
                feature.setAttributes([QDateTime(self.commonHeader.logTime), lon_notAug, lat_notAug, self.numSV])
                layer_gpsPos.dataProvider().addFeatures( [feature] )
        
        if checkInvalidLonLat(lon, lat) == True:
            if layer_v != None:
                scaleRate = 0.000000005
                if self.velNAug != 0x7FFFFFFF and self.velEAug != 0x7FFFFFFF:
                    velNAug = self.velNAug
                    velEAug = self.velEAug
                else:
                    velNAug = self.velN
                    velEAug = self.velE
                if velNAug != 0x7FFFFFFF and velEAug != 0x7FFFFFFF:
                    if (GNSSDataMessage.oldVpoint == None) or ((GNSSDataMessage.oldVpoint[0]-lon) ** 2 + (GNSSDataMessage.oldVpoint[1]-lat) ** 2) >= 0.0000002:
                        feature = QgsFeature()
                        feature.setGeometry(QgsGeometry.fromPolyline(
                            [QgsPoint(lon, lat, z),
                            QgsPoint(lon + velEAug*scaleRate, lat + velNAug*scaleRate, z)]))
                        if realTimeMode == DrawMode.FullDraw:
                            feature.setAttributes([QDateTime(self.commonHeader.logTime), lon, lat, velNAug*36/10000, velEAug*36/10000])
                        layer_v.dataProvider().addFeatures( [feature] )
                        GNSSDataMessage.oldVpoint = (lon, lat)

            if layer_acc != None and self.augumentedAcc < 0xFFFF: # 0xFFFF is invalid value
                scaleRate = 0.0000064
                eclipsePointList = []
                attrList = [
                    QDateTime(self.commonHeader.logTime),
                    lon,
                    lat,
                    self.augumentedAcc * 0.1]
                if self.augumentedAcc < 0.1:
                    for t in range(0, 361, 20):
                        w = math.radians(t)
                        eclipsePointList.append(QgsPoint(
                            attrList[1] + scaleRate*(0.01*math.cos(w) - 0.01*math.sin(w)),
                            attrList[2] + scaleRate*(0.01*math.cos(w) + 0.01*math.sin(w)),
                            z_notAug
                        ))
                else:
                    for t in range(0, 361, 20):
                        w = math.radians(t)
                        eclipsePointList.append(QgsPoint(
                            attrList[1] + scaleRate*(attrList[3]*math.cos(w) - attrList[3]*math.sin(w)),
                            attrList[2] + scaleRate*(attrList[3]*math.cos(w) + attrList[3]*math.sin(w)),
                            z_notAug
                        ))
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPolyline(eclipsePointList))
                feature.setAttributes(attrList)
                layer_acc.dataProvider().addFeatures( [feature] )
            
            if layer_p != None and checkInvalidLonLat(lon, lat, oldLon, oldLat, allowSamePoint = True) == True:   
                fixTypeAug = self.fixTypeAugOld
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPolyline(
                    [QgsPoint(oldLon, oldLat, oldZ), QgsPoint(lon, lat, z)]))
                if realTimeMode == DrawMode.FullDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw:
                    feature.setAttributes([QDateTime(self.commonHeader.logTime), lon, lat, bearing, fixTypeAug, self.numSVAug])
                else:
                    feature.setAttributes([fixTypeAug])
                layer_p.dataProvider().addFeatures( [feature] )

            if layer_ed != None and self.positionError != None and self.positionError.distance > 0:
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromMultiPolylineXY([[QgsPointXY(self.positionError.foot[0], self.positionError.foot[1]), QgsPointXY(lon, lat)]]))
                feature.setAttributes([QDateTime(self.commonHeader.logTime), self.positionError.distance])
                layer_ed.dataProvider().addFeatures( [feature] )


#-----------------------------------------------#
#----   SensorCalibrationMessage            ----#
#-----------------------------------------------#
class SensorCalibrationMessage(Message):        
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.timeStamp = readFunc(int,48)
        self.timeStamp_old = oldMessage.timeStamp if oldMessage != None else 0
        self.invalidFlag = readFunc(int,16)
        self.currentPosLearningValue = readFunc(int,32)
        self.currentPosLearningLevel = readFunc(int,8)
        readFunc(int,24) #reserved
        self.unitEqLearningValue_roll = readFunc(int,32,True)
        self.unitEqLearningValue_pitch = readFunc(int,32,True)
        self.unitEqLearningValue_yaw = readFunc(int,32,True)
        self.unitEqLearningLevel = readFunc(int,8)
        readFunc(int,24) #reserved
        self.gyroLearningValue_roll = readFunc(int,16)
        self.gyroLearningValue_pitch = readFunc(int,16)
        self.gyroLearningValue_yaw = readFunc(int,16)
        self.gyroLearningLevel = readFunc(int,8)
        readFunc(int,8) #reserved
        self.gyroTempLearningValue_roll = readFunc(int,16,True)
        self.gyroTempLearningValue_pitch = readFunc(int,16,True)
        self.gyroTempLearningValue_yaw = readFunc(int,16,True)
        self.gyroTempLearningLevel = readFunc(int,8)
        readFunc(int,8) #reserved
        self.imuTempLearningValue_roll = readFunc(int,16,True)
        self.imuTempLearningValue_pitch = readFunc(int,16,True)
        self.imuTempLearningValue_yaw = readFunc(int,16,True)
        self.imuTempLearningLevel = readFunc(int,8)
        readFunc(int,8) #reserved
        self.assertMessageSize()

    def printHeader(self, sheet, row, col, _level = 1):
        newCol = col
        sheet.write(row, newCol, 'Common Header', sheet.cellFormats('header'))
        merge_cols(sheet, row, newCol, self.commonHeader.columnCount(), True)
        newCol += self.commonHeader.columnCount()
        newCol += 3
        sheet.write(row, newCol, '現在測位度域における車速感度誤差学習値', sheet.cellFormats('header'))
        merge_cols(sheet, row, newCol, 2, True)
        newCol += 2
        sheet.write(row, newCol, 'ユニット設置角度学習値', sheet.cellFormats('header'))
        merge_cols(sheet, row, newCol, 4, True)
        newCol += 4
        sheet.write(row, newCol, 'ジャイロセンサ感度学習値', sheet.cellFormats('header'))
        merge_cols(sheet, row, newCol, 4, True)
        newCol += 4
        sheet.write(row, newCol, '現在温度におけるジャイロセンサ温度学習値', sheet.cellFormats('header'))
        merge_cols(sheet, row, newCol, 4, True)
        newCol += 4
        sheet.write(row, newCol, '現在温度における加速度センサ温度学習値', sheet.cellFormats('header'))
        merge_cols(sheet, row, newCol, 4, True)
        
        newCol = col
        [_, newCol, _] = self.commonHeader.printHeader(sheet, row+1, newCol)
        
        sheet.write_row(row+1, newCol, ['タイムスタンプ[μs]', '差分[ms]', '無効フラグ'], sheet.cellFormats('header'))
        newCol += 3
        
        sheet.write_row(row+1, newCol, ['学習値', '学習レベル'], sheet.cellFormats('header'))
        newCol += 2
        
        sheet.write_row(row+1, newCol, ['ロール角(x軸)[deg]', 'ピッチ角(y軸)[deg]', 'ヨー角(z軸)[deg]', '学習レベル'], sheet.cellFormats('header'))
        newCol += 4
        
        sheet.write_row(row+1, newCol, ['ロール角(x軸)[deg]', 'ピッチ角(y軸)[deg]', 'ヨー角(z軸)[deg]', '学習レベル'], sheet.cellFormats('header'))
        newCol += 4
        
        sheet.write_row(row+1, newCol, ['ロール角(x軸)[deg]', 'ピッチ角(y軸)[deg]', 'ヨー角(z軸)[deg]', '学習レベル'], sheet.cellFormats('header'))
        newCol += 4
        
        sheet.write_row(row+1, newCol, ['x軸[g]', 'y軸[g]', 'z軸[g]', '学習レベル'], sheet.cellFormats('header'))
        newCol += 4
        
        sheet.freeze_panes(2, 0)
        sheet.set_row(0, 20)
        sheet.set_row(1, 20)
        sheet.autofilter(1, 0, 1, newCol-1)
        
        return [row+2, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [
            (self.timeStamp),
            (self.timeStamp - self.timeStamp_old) / 1000,
            hex(self.invalidFlag),
            (self.currentPosLearningValue / 1000000.0),
            (self.currentPosLearningLevel),
            (self.unitEqLearningValue_roll / 1000000.0),
            (self.unitEqLearningValue_pitch / 1000000.0),
            (self.unitEqLearningValue_yaw / 1000000.0),
            (self.unitEqLearningLevel),
            (self.gyroLearningValue_roll / 10000.0),
            (self.gyroLearningValue_pitch / 10000.0),
            (self.gyroLearningValue_yaw / 10000.0),
            (self.gyroLearningLevel),
            (self.gyroTempLearningValue_roll / 262.14),
            (self.gyroTempLearningValue_pitch / 262.14),
            (self.gyroTempLearningValue_yaw / 262.14),
            (self.gyroTempLearningLevel),
            (self.imuTempLearningValue_roll / 1024.0),
            (self.imuTempLearningValue_pitch / 1024.0),
            (self.imuTempLearningValue_yaw / 1024.0),
            (self.imuTempLearningLevel)])
        
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
        chart = book.add_chart({'type': 'line'})
        chart.set_title({
            'name': 'センサタイムスタンプ[μs]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'values':     "='{0}'!$K$1:$K${1}".format(sheet.name, totalRows)})
        sheet.insert_chart('C18', chart)
        
        chart = book.add_chart({'type': 'scatter'})
        chart.set_title({
            'name': 'センサタイムスタンプ 差分[ms]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'name': '間隔[ms]',
            'categories': "='{0}'!$A$1:$A${1}".format(sheet.name, totalRows),
            'values':     "='{0}'!$L$1:$L${1}".format(sheet.name, totalRows)})
        chart.set_y_axis({'min': 480, 'max': 520})
        sheet.insert_chart('J18', chart)
    

#-----------------------------------------------#
#----   AligmentRequest                     ----#
#-----------------------------------------------#
class AligmentRequest(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.tileID = readFunc(int,64)
        readFunc(int,32) #reserved
        self.assertMessageSize()
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        sheet.write(row, col, 'Tile ID', sheet.cellFormats('header'))
        col += 1
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write(row, col, (self.tileID))
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    

#-----------------------------------------------#
#----   AligmentResponse                    ----#
#-----------------------------------------------#
class AligmentResponse(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.TileID = readFunc(int,64)
        self.ResultCode = readFunc(int,8)
        self.SplitMax = readFunc(int,16)
        self.SplitNo = readFunc(int,16)
        readFunc(int,24) #Reserved
        self.AligmentData = self.data.getDataBuf()[self.data.seek():]
        #可変サイズメッセージ

    def printHeader(self, sheet, row, col, _level = 1):
        [_, col, _] = self.commonHeader.printHeader(sheet, row, col)
        
        sheet.write_row(row, col, [
            'Tile ID',
            'Result Code',
            'Split Max',
            'Split No',
            'Aligment Data'], sheet.cellFormats('header'))
        col += 5
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        
        sheet.write_row(row, col, [
            (self.TileID),
            (self.ResultCode),
            (self.SplitMax),
            (self.SplitNo),
            str([hex(x) for x in self.AligmentData])])
        
        return  [row+1, 0, []]  
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    
    
#-----------------------------------------------#
#----   VehicleInfo                         ----#
#-----------------------------------------------#
class VehicleInfo(Message):
    HeadStrList = [
        'VehicleSpeedBody:double',
        'VehicleSpeed:double',
        'WheelSpeedRL:double',
        'WheelSpeedRR:double',
        'WheelSpeedFR:double',
        'WheelSpeedFL:double',
        'WheelTopFL:double',
        'WheelTopFR:double',
        'WheelTopRL:double',
        'WheelTopRR:double',
        'LongitudinalAccelCorrected:double',
        'TransversalAccelCorrected:double',
        'TransversalAccelRaw:double',
        'YawRateCorrected:double',
        'YawRateRaw:double',
        'SteeringWheelAngleCorrected:double',
        'SwaSensorInternalStatus:string',
        'TransmRangeEngaged_Current:string',
        'VehicleStates:string',
        'BatteryVoltage:double',
        'SteeringWheelAngleRaw:double',
        'NeutralContact:string',
        'RearGearEngaged:string',
        'GearLeverPosition_v2:string',
        'ATCVT_RangeIndicationExtended:string',
        'BrakePedalPressedByDriver:string',
        'BrakingPressure[bar]:double',
        'WheelDirectionRL:string',
        'WheelDirectionRR:string',
        'ABSinRegulation:double',
        'ASRinRegulation:double',
        'MSRinRegulation:double',
        'AYCinRegulation:double',
        'ABSMalfunction:double',
        'ASRMalfunction:double',
        'AYCMalfunction:double',
        'DistanceTotalizer[km]:double',
        'ExternalTemperature[°C]:double',
        'IgnitionSupplyConfirmation:double',
        'SensorPathChange_Request:string',
        'GADE_v2:string',
        'SubAD_ADmodeStatus:string',
        'GlobalTimeStamp[us]:double',
        'GlobalTimeStamp差分[us]:double',
        'SteeringWheelRotationSpeed[°/s](+:Left, -:Right):double',
        'FrontWiperStatus_BCM:string',
        'BrakeInfoStatus:string',
        'WheelDirectionFL:string',
        'WheelDirectionFR:string',
        'DeliveryModeInformation_v2:string',
        'IVI_SDmapVersion:double',
        'LiDAR_3:double',
        'LiDAR_4:double',
        'LiDAR_5:double',
        'LiDAR_6:double',
        'LiDAR_7:double',
        'LiDAR_8:double',
        'LiDAR_9:double',
        'LiDAR_10:double',
        'HDMAP_1:double',
        'HDMAP_2:double',
        'HDMAP_3:double',
        'HDMAP_4:double',
        'HDMAP_5:double',
        'HDMAP_6:double',
        'HDMAP_7:double',
        'HDMAP_8:double',
        'HDMAP_9:double',
        'HDMAP_10:double',
        'RADAR_1:double',
        'RADAR_2:double',
        'RADAR_3:double',
        'RADAR_4:double',
        'RADAR_5:double',
        'RADAR_6:double',
        'RADAR_7:double',
        'RADAR_8:double',
        'RADAR_9:double',
        'RADAR_10:double',
        'AVM_1:double',
        'AVM_2:double',
        'AVM_3:double',
        'AVM_4:double',
        'AVM_5:double',
        'AVM_6:double',
        'AVM_7:double',
        'AVM_8:double',
        'AVM_9:double',
        'AVM_10:double',
        'FlashingIndicatorCommandPosition:string',
        'FrontWipingRequest:string',
        'FlashingIndicatorStatus:string',
        'RawSensor[%]:double',
        'Type:string',
        'CRC:double',
        'TimeDomain:double',
        'SequenceCounter:double',
        'SGW:string',
        'OVS:double',
        'SyncTime:double',
        'SyncTimeUnit:string',]
     
    SwaSensorInternalStatusDic = {
        0: '(0)Not calibrated, not indexed',
        1: '(1)Not calibrated, indexed',
        2: '(2)Fault',
        3: '(3)Reserved',
        4: '(4)Calibrated, not initialised',
        5: '(5)Calibrated, initialised',
        6: '(6)Reserved',
        7: '(7)Reserved',}
    
    TransmRangeEngagedCurrentDic = {
        0: '(0)declutched at rest',
        1: '(1)1st range',
        2: '(2)2nd range',
        3: '(3)3rd range',
        4: '(4)4th range',
        5: '(5)5th range',
        6: '(6)6th range',
        7: '(7)7th range',
        8: '(8)8th range',
        9: '(9)Reverse',
        10: '(10)Neutral or parking',
        11: '(11)CVT in continuous mode',
        12: '(12)9th range',
        13: '(13)10th range',
        14: '(14)Not used',
        15: '(15)AT in limphome',}
    
    VehicleStatesDic = {
        0: '(0)Sleeping',
        1: '(1)Not used',
        2: '(2)CutoffPending',
        3: '(3)AutoACC  - BatTempoLevel',
        4: '(4)Not used',
        5: '(5)IgnitionLevel',
        6: '(6)StartingInProgress',
        7: '(7)PowertrainRunning',
        8: '(8)AutoStart',
        9: '(9)EngineSystemStop',
        15: '(15)Unavailable',}
    
    NeutralContactDic = {
        0: '(0)Not used',
        1: '(1)Neutral contact not reached',
        2: '(2)Neutral contact reached',
        3: '(3)Unavailable',}
    
    RearGearEngagedDic = {
        0: '(0)Not used',
        1: '(1)Rear Gear not Engaged',
        2: '(2)Rear Gear Engaged',
        3: '(3)Unavailable',}
    
    GearLeverPositionV2Dic = {
        0: '(0)Parking - P',
        1: '(1)Reverse - R',
        2: '(2)Neutral - N',
        3: '(3)Drive - D',
        4: '(4)Manual mode - M',
        5: '(5)L',
        6: '(6)Ds',
        7: '(7)Confirmed lever position (no switch signal)',
        8: '(8)B (Brake)',
        15:'(15)Unavailable',}
    
    ATCVTRangeIndicationExtendedDic = {
        0: '(0)OFF',
        1: '(1)P range',
        2: '(2)R range',
        3: '(3)N range',
        4: '(4)D range',
        5: '(5)S range',
        6: '(6)L range',
        7: '(7)B range',
        8: '(8)1st range',
        9: '(9)2nd range',
        10: '(10)3rd range',
        11: '(11)4th range',
        12: '(12)5th range',
        13: '(13)6th range',
        14: '(14)7th range',
        15: '(15)8th range',
        16: '(16)9th range',
        17: '(17)10th range',
        18: '(18)Not used',
        19: '(19)Not used',
        20: '(20)M1st',
        21: '(21)M2nd',
        22: '(22)M3rd',
        23: '(23)M4th',
        24: '(24)M5th',
        25: '(25)M6th',
        26: '(26)M7th',
        27: '(27)M8th',
        28: '(28)M9th',
        29: '(29)M10th',
        30: '(30)Not used',
        31: '(31)Not used',
        32: '(32)Auto 1st',
        33: '(33)Auto 2nd',
        34: '(34)Auto 3rd',
        35: '(35)Auto 4th',
        36: '(36)Auto 5th',
        37: '(37)Auto 6th',
        38: '(38)Auto 7th',
        39: '(39)Auto 8th',
        40: '(40)Auto 9th',
        41: '(41)Auto 10th',}
    
    BrakePedalPressedByDriverDic = {
        0: '(0)Not used',
        1: '(1)Brake Pedal Not Pressed',
        2: '(2)Brake Pedal Pressed',
        3: '(3)Unavailable',}
    
    WheelDirectionRLDic = {
        0: '(0)No movement detected yet',
        1: '(1)Wheel Front Direction',
        2: '(2)Wheel Rear Direction',
        3: '(3)Unavailable',}
    
    WheelDirectionRRDic = {
        0: '(0)No movement detected yet',
        1: '(1)Wheel Front Direction',
        2: '(2)Wheel Rear Direction',
        3: '(3)Unavailable',}
    
    SensorPathChangeRequestDic = {
        0: '(0)PathChange Available,SubPathChange not requested,MainPathChange not requested',
        1: '(1)PathChange Available,SubPathChange not requested,MainPathChange1 requested',
        2: '(2)PathChange Available,SubPathChange not requested,MainPathChange2 requested',
        3: '(3)PathChange Available,SubPathChange not requested,Not used',
        4: '(4)PathChange Available,SubPathChange1 requested ,MainPathChange not requested',
        5: '(5)PathChange Available,SubPathChange1 requested ,MainPathChange1 requested',
        6: '(6)PathChange Available,SubPathChange1 requested ,MainPathChange2 requested',
        7: '(7)PathChange Available,SubPathChange1 requested ,Not used',
        8: '(8)PathChange Available,SubPathChange2 requested,MainPathChange not requested',
        9: '(9)PathChange Available,SubPathChange2 requested,MainPathChange1 requested',
        10: '(10)PathChange Available,SubPathChange2 requested,MainPathChange2 requested',
        11: '(11)PathChange Available,SubPathChange2 requested,Not used',
        12: '(12)PathChange Available,Not used,MainPathChange not requested',
        13: '(13)PathChange Available,Not used,MainPathChange1 requested',
        14: '(14)PathChange Available,Not used,MainPathChange2 requested',
        15: '(15)PathChange Available,Not used,Not used',
        16: '(16)PathChange Unavailable,SubPathChange not requested,MainPathChange not requested',
        17: '(17)PathChange Unavailable,SubPathChange not requested,MainPathChange1 requested',
        18: '(18)PathChange Unavailable,SubPathChange not requested,MainPathChange2 requested',
        19: '(19)PathChange Unavailable,SubPathChange not requested,Not used',
        20: '(20)PathChange Unavailable,SubPathChange1 requested ,MainPathChange not requested',
        21: '(21)PathChange Unavailable,SubPathChange1 requested ,MainPathChange1 requested',
        22: '(22)PathChange Unavailable,SubPathChange1 requested ,MainPathChange2 requested',
        23: '(23)PathChange Unavailable,SubPathChange1 requested ,Not used',
        24: '(24)PathChange Unavailable,SubPathChange2 requested,MainPathChange not requested',
        25: '(25)PathChange Unavailable,SubPathChange2 requested,MainPathChange1 requested',
        26: '(26)PathChange Unavailable,SubPathChange2 requested,MainPathChange2 requested',
        27: '(27)PathChange Unavailable,SubPathChange2 requested,Not used',
        28: '(28)PathChange Unavailable,Not used,MainPathChange not requested',
        29: '(29)PathChange Unavailable,Not used,MainPathChange1 requested',
        30: '(30)PathChange Unavailable,Not used,MainPathChange2 requested',
        31: '(31)PathChange Unavailable,Not used,Not used',}
    
    GADEV2Dic = {
        0: '(0)Sleep or Crank fault, Disable DiagMuxDTC',
        1: '(1)AutoACC fault, Disable DiagMuxDTC',
        2: '(2)ALL fault, Disable DiagMuxDTC',
        3: '(3)ALL fault, Enable DiagMuxDTC',
        4: '(4)FOTA switch fault, Disable DiagMuxDTC',
        7: '(7)Unavailable',}
    
    SubADADmodeStatusDic = {
        0: '(0)AD/RPK OFF',
        1: '(1)AD2 L2 regulation',
        2: '(2)AD1 L3 regulation',
        3: '(3)RPK regulation',
        4: '(4)AD/RPK OFF + TD or MRM in regulation',
        5: '(5)AD2 L2 regulation + TD or MRM in regulation',
        6: '(6)AD1 L3 regulation + TD or MRM in regulation',
        7: '(7)RPK regulation + TD or MRM in regulation',}
    
    FrontWiperStatusBCMDic = {
        0: '(0)front wiper stopped',
        1: '(1)low speed active',
        2: '(2)high speed active',
        3: '(3)Unavailable',}
    
    BrakeInfoStatusDic = {
        0: '(0)Not used',
        1: '(1)Brake pedal not pressed',
        2: '(2)Brake pedal pressed',
        3: '(3)Not used',
        4: '(4)Brake pedal confirmed pressed',
        7: '(7)Unavailable',}
    
    WheelDirectionFLDic = {
        0: '(0)No movement detected yet',
        1: '(1)Wheel Front Direction',
        2: '(2)Wheel Rear Direction',
        3: '(3)Unavailable',}
    
    WheelDirectionFRDic = {
        0: '(0)No movement detected yet',
        1: '(1)Wheel Front Direction',
        2: '(2)Wheel Rear Direction',
        3: '(3)Unavailable',}
    
    DeliveryModeInformationV2Dic = {
        0: '(0)customer mode',
        1: '(1)delivery mode level 1',
        2: '(2)delivery mode level 2',}
    
    FlashingIndicatorCommandPositionDic = {
        0: '(0)No direction indicator request',
        1: '(1)Left Flashing Indicators command ON',
        2: '(2)Right Flashing Indicators command ON',}
    
    FrontWipingRequestDic = {
        0: '(0)front wiper in stop position',
        1: '(1)front wiper forced to stop',
        2: '(2)Not used',
        3: '(3)Not used',
        4: '(4)Unavailable',
        5: '(5)Not used',
        6: '(6)low speed wiping requested',
        7: '(7)high speed wiping requested',}
    
    FlashingIndicatorStatusDic = {
        0: '(0)left and right flashing indicators OFF',
        1: '(1)left flashing indicator ON and right flashing indicator OFF',
        2: '(2)left flashing indicator OFF and right flashing indicator ON',
        3: '(3)left flashing indicator ON and right flashing indicator ON',
        7: '(7)Unavailable',}
    
    TypeDic = {
        0x20: '(0x20)MUX value for SYNC',
        0x28: '(0x28)MUX value for FUP layout',}
    
    SGWDic = {
        0: '(0)SyncToGTM',
        1: '(1)SyncToSubDomain',}
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.VehicleSpeedBody = readFunc(int,32) * 0.01
        self.VehicleSpeed = readFunc(int,32) * 0.01
        self.WheelSpeedRL = readFunc(int,32) * 0.0416666667
        self.WheelSpeedRR = readFunc(int,32) * 0.0416666667
        self.WheelSpeedFR = readFunc(int,32) * 0.0416666667
        self.WheelSpeedFL = readFunc(int,32) * 0.0416666667
        self.WheelTopFL = readFunc(int,8)
        self.WheelTopFR = readFunc(int,8)
        self.WheelTopRL = readFunc(int,8)
        self.WheelTopRR = readFunc(int,8)
        self.LongitudinalAccelCorrected = readFunc(int,16) * 0.001 - 2
        self.TransversalAccelCorrected = readFunc(int,16) * 0.001 - 2
        self.TransversalAccelRaw = readFunc(int,16) * 0.001 - 2
        self.YawRateCorrected = readFunc(int,16) * 0.1 - 100
        self.YawRateRaw = readFunc(int,16) * 0.1 - 100
        self.SteeringWheelAngleCorrected = readFunc(int,16) * 0.1 - 1080
        self.SwaSensorInternalStatus = readFunc(int,8)
        self.TransmRangeEngaged_Current = readFunc(int,8)
        self.VehicleStates = readFunc(int,8)
        self.BatteryVoltage = readFunc(int,8) * 0.06 + 6
        self.SteeringWheelAngleRaw = readFunc(int,16) * 0.1 - 1080
        self.NeutralContact = readFunc(int,8)
        self.RearGearEngaged = readFunc(int,8)
        self.GearLeverPosition_v2 = readFunc(int,8)
        self.ATCVT_RangeIndicationExtended = readFunc(int,8)
        self.BrakePedalPressedByDriver = readFunc(int,8)
        self.BrakingPressure = readFunc(int,8) * 0.5
        self.WheelDirectionRL = readFunc(int,8)
        self.WheelDirectionRR = readFunc(int,8)
        self.ABSinRegulation = readFunc(int,8)
        self.ASRinRegulation = readFunc(int,8)
        self.MSRinRegulation = readFunc(int,8)
        self.AYCinRegulation = readFunc(int,8)
        self.ABSMalfunction = readFunc(int,8)
        self.ASRMalfunction = readFunc(int,8)
        self.AYCMalfunction = readFunc(int,8)
        self.DistanceTotalizer = readFunc(int,32) * 0.01
        self.ExternalTemperature = readFunc(int,16) * 0.25 - 50
        self.IgnitionSupplyConfirmation = readFunc(int,8)
        self.SensorPathChange_Request = readFunc(int,8)
        self.GADE_v2 = readFunc(int,8)
        self.SubAD_ADmodeStatus = readFunc(int,8)
        self.GlobalTimeStamp = readFunc(int,32) * 2
        self.GlobalTimeStamp_old = oldMessage.GlobalTimeStamp if oldMessage != None else 0
        self.SteeringWheelRotationSpeed = readFunc(int,32) * 0.1 - 3276.7
        self.FrontWiperStatus_BCM = readFunc(int,8)
        self.BrakeInfoStatus = readFunc(int,8)
        self.WheelDirectionFL = readFunc(int,8)
        self.WheelDirectionFR = readFunc(int,8)
        self.DeliveryModeInformation_v2 = readFunc(int,8)
        self.IVI_SDmapVersion = readFunc(int,8)
        self.LiDAR_3 = readFunc(int,8)
        self.LiDAR_4 = readFunc(int,8)
        self.LiDAR_5 = readFunc(float,32)
        self.LiDAR_6 = readFunc(float,32)
        self.LiDAR_7 = readFunc(float,32)
        self.LiDAR_8 = readFunc(float,32)
        self.LiDAR_9 = readFunc(float,32)
        self.LiDAR_10 = readFunc(float,32)
        self.HDMAP_1 = readFunc(int,8)
        self.HDMAP_2 = readFunc(int,8)
        self.HDMAP_3 = readFunc(int,8)
        self.HDMAP_4 = readFunc(int,8)
        self.HDMAP_5 = readFunc(float,32)
        self.HDMAP_6 = readFunc(float,32)
        self.HDMAP_7 = readFunc(float,32)
        self.HDMAP_8 = readFunc(float,32)
        self.HDMAP_9 = readFunc(float,32)
        self.HDMAP_10 = readFunc(float,32)
        self.RADAR_1 = readFunc(int,8)
        self.RADAR_2 = readFunc(int,8)
        self.RADAR_3 = readFunc(int,8)
        self.RADAR_4 = readFunc(int,8)
        self.RADAR_5 = readFunc(float,32)
        self.RADAR_6 = readFunc(float,32)
        self.RADAR_7 = readFunc(float,32)
        self.RADAR_8 = readFunc(float,32)
        self.RADAR_9 = readFunc(float,32)
        self.RADAR_10 = readFunc(float,32)
        self.AVM_1 = readFunc(int,8)
        self.AVM_2 = readFunc(int,8)
        self.AVM_3 = readFunc(int,8)
        self.AVM_4 = readFunc(int,8)
        self.AVM_5 = readFunc(float,32)
        self.AVM_6 = readFunc(float,32)
        self.AVM_7 = readFunc(float,32)
        self.AVM_8 = readFunc(float,32)
        self.AVM_9 = readFunc(float,32)
        self.AVM_10 = readFunc(float,32)
        self.FlashingIndicatorCommandPosition = readFunc(int,8)
        self.FrontWipingRequest = readFunc(int,8)
        self.FlashingIndicatorStatus = readFunc(int,8)
        self.RawSensor = readFunc(int,16) * 0.125
        self.Type = readFunc(int,8)
        self.CRC = readFunc(int,8)
        self.TimeDomain = readFunc(int,8)
        self.SequenceCounter = readFunc(int,8)
        self.SGW = readFunc(int,8)
        self.OVS = readFunc(int,8)
        self.SyncTime = readFunc(int,32)
        self.assertMessageSize()
        
    def getValList(self):
        return [
            (self.VehicleSpeedBody),
            (self.VehicleSpeed),
            (self.WheelSpeedRL),
            (self.WheelSpeedRR),
            (self.WheelSpeedFR),
            (self.WheelSpeedFL),
            (self.WheelTopFL),
            (self.WheelTopFR),
            (self.WheelTopRL),
            (self.WheelTopRR),
            (self.LongitudinalAccelCorrected),
            (self.TransversalAccelCorrected),
            (self.TransversalAccelRaw),
            (self.YawRateCorrected),
            (self.YawRateRaw),
            (self.SteeringWheelAngleCorrected),
            (VehicleInfo.SwaSensorInternalStatusDic.get(self.SwaSensorInternalStatus, '({})Not used'.format(self.SwaSensorInternalStatus))),
            (VehicleInfo.TransmRangeEngagedCurrentDic.get(self.TransmRangeEngaged_Current, '({})Not used'.format(self.TransmRangeEngaged_Current))),
            (VehicleInfo.VehicleStatesDic.get(self.VehicleStates, '({})Not used'.format(self.VehicleStates))),
            (self.BatteryVoltage),
            (self.SteeringWheelAngleRaw),
            (VehicleInfo.NeutralContactDic.get(self.NeutralContact, '({})Not used'.format(self.NeutralContact))),
            (VehicleInfo.RearGearEngagedDic.get(self.RearGearEngaged, '({})Not used'.format(self.RearGearEngaged))),
            (VehicleInfo.GearLeverPositionV2Dic.get(self.GearLeverPosition_v2, '({})Not used'.format(self.GearLeverPosition_v2))),
            (VehicleInfo.ATCVTRangeIndicationExtendedDic.get(self.ATCVT_RangeIndicationExtended, '({})Not used'.format(self.ATCVT_RangeIndicationExtended))),
            (VehicleInfo.BrakePedalPressedByDriverDic.get(self.BrakePedalPressedByDriver, '({})Not used'.format(self.BrakePedalPressedByDriver))),
            (self.BrakingPressure),
            (VehicleInfo.WheelDirectionRLDic.get(self.WheelDirectionRL, '({})Not used'.format(self.WheelDirectionRL))),
            (VehicleInfo.WheelDirectionRRDic.get(self.WheelDirectionRR, '({})Not used'.format(self.WheelDirectionRR))),
            (self.ABSinRegulation),
            (self.ASRinRegulation),
            (self.MSRinRegulation),
            (self.AYCinRegulation),
            (self.ABSMalfunction),
            (self.ASRMalfunction),
            (self.AYCMalfunction),
            (self.DistanceTotalizer),
            (self.ExternalTemperature),
            (self.IgnitionSupplyConfirmation),
            (VehicleInfo.SensorPathChangeRequestDic.get(self.SensorPathChange_Request, '({})Not used'.format(self.SensorPathChange_Request))),
            (VehicleInfo.GADEV2Dic.get(self.GADE_v2, '({})Not used'.format(self.GADE_v2))),
            (VehicleInfo.SubADADmodeStatusDic.get(self.SubAD_ADmodeStatus, '({})Not used'.format(self.SubAD_ADmodeStatus))),
            (self.GlobalTimeStamp),
            (self.GlobalTimeStamp - self.GlobalTimeStamp_old) / 1000,
            (self.SteeringWheelRotationSpeed),
            (VehicleInfo.FrontWiperStatusBCMDic.get(self.FrontWiperStatus_BCM, '({})Not used'.format(self.FrontWiperStatus_BCM))),
            (VehicleInfo.BrakeInfoStatusDic.get(self.BrakeInfoStatus, '({})Not used'.format(self.BrakeInfoStatus))),
            (VehicleInfo.WheelDirectionFLDic.get(self.WheelDirectionFL, '({})Not used'.format(self.WheelDirectionFL))),
            (VehicleInfo.WheelDirectionFRDic.get(self.WheelDirectionFR, '({})Not used'.format(self.WheelDirectionFR))),
            (VehicleInfo.DeliveryModeInformationV2Dic.get(self.DeliveryModeInformation_v2, '({})Not used'.format(self.DeliveryModeInformation_v2))),
            (self.IVI_SDmapVersion),
            (self.LiDAR_3),
            (self.LiDAR_4),
            (self.LiDAR_5),
            (self.LiDAR_6),
            (self.LiDAR_7),
            (self.LiDAR_8),
            (self.LiDAR_9),
            (self.LiDAR_10),
            (self.HDMAP_1),
            (self.HDMAP_2),
            (self.HDMAP_3),
            (self.HDMAP_4),
            (self.HDMAP_5),
            (self.HDMAP_6),
            (self.HDMAP_7),
            (self.HDMAP_8),
            (self.HDMAP_9),
            (self.HDMAP_10),
            (self.RADAR_1),
            (self.RADAR_2),
            (self.RADAR_3),
            (self.RADAR_4),
            (self.RADAR_5),
            (self.RADAR_6),
            (self.RADAR_7),
            (self.RADAR_8),
            (self.RADAR_9),
            (self.RADAR_10),
            (self.AVM_1),
            (self.AVM_2),
            (self.AVM_3),
            (self.AVM_4),
            (self.AVM_5),
            (self.AVM_6),
            (self.AVM_7),
            (self.AVM_8),
            (self.AVM_9),
            (self.AVM_10),
            (VehicleInfo.FlashingIndicatorCommandPositionDic.get(self.FlashingIndicatorCommandPosition, '({})Not used'.format(self.FlashingIndicatorCommandPosition))),
            (VehicleInfo.FrontWipingRequestDic.get(self.FrontWipingRequest, '({})Not used'.format(self.FrontWipingRequest))),
            (VehicleInfo.FlashingIndicatorStatusDic.get(self.FlashingIndicatorStatus, '({})Not used'.format(self.FlashingIndicatorStatus))),
            (self.RawSensor),
            (VehicleInfo.TypeDic.get(self.Type, '({})Not used'.format(self.Type))),
            (self.CRC),
            (self.TimeDomain),
            (self.SequenceCounter),
            (VehicleInfo.SGWDic.get(self.SGW, '({})Not used'.format(self.SGW))),
            (self.OVS),
            (self.SyncTime),
            '[s]' if self.Type == 0x20 else '[ns]']
        
    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        strList = VehicleInfo.HeadStrList
        for i in range(len(strList)):
            strList[i] = strList[i].split(':')[0]
            
        sheet.write_row(row, col, strList, sheet.cellFormats('header'))
        col += len(strList)
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        valList = self.getValList()
        sheet.write_row(row, col, valList)
        return [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
        chart = book.add_chart({'type': 'line'})
        chart.set_title({
            'name': 'GlobalTimeStamp[μs]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'values':     "='{0}'!$BA$1:$BA${1}".format(sheet.name, totalRows)})
        sheet.insert_chart('C18', chart)
        
        chart = book.add_chart({'type': 'scatter'})
        chart.set_title({
            'name': 'GlobalTimeStamp 差分[ms]',
            'name_font': {'size': 16, 'bold': False}})
        chart.add_series({
            'name': '間隔[ms]',
            'categories': "='{0}'!$A$1:$A${1}".format(sheet.name, totalRows),
            'values':     "='{0}'!$BB$1:$BB${1}".format(sheet.name, totalRows)})
        chart.set_y_axis({'min': 0, 'max': 20})
        sheet.insert_chart('J18', chart)
        
    class LayerType(Enum):
        VehicleInfoLayer = 70

    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.VehicleInfoLayer:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(0,255,255))
            symbol.setWidth(0.2)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
        
        return None

    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        fieldStr = ''
        for field in VehicleInfo.HeadStrList:
            fieldStr += '&field=' + field

        if (realTimeMode == DrawMode.OpenGL_RealTimeDraw or realTimeMode == DrawMode.FullDraw):
            newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime' + fieldStr + '&index=yes',name,'memory')
            newLayer = self.SetLayerStyle(self.LayerType.VehicleInfoLayer, newLayer)
            return [newLayer]
        
        else: return None

    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        old = self.oldMessage
        layer = None
        for layerListItem in layerList:
            if layerListItem[1] == VehicleInfo.LayerType.VehicleInfoLayer.value:
                layer = layerListItem[0]

        if old == None:
            return

        [lon, lat] = self.getRelatedPositionDefault()
        [oldLon, oldLat] = old.getRelatedPositionDefault()
        checkInvalidLonLatResult = checkInvalidLonLat(lon, lat, oldLon, oldLat, allowSamePoint = True)
            
        if layer != None:
            feature = QgsFeature()
            if checkInvalidLonLatResult == False:
                feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(0, 0), QgsPoint(0, 0)])) # OpenGL描画などのために、位置情報がなくてもとりあえず現在の情報は流れるように
            else:
                feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)]))
            attributeList = [QDateTime(self.commonHeader.logTime)]
            for attr in self.getValList():
                attributeList.append(attr)
            feature.setAttributes(attributeList)
            layer.dataProvider().addFeatures( [feature] )    
        
        
#-----------------------------------------------#
#----   SendADstatus                        ----#
#-----------------------------------------------#
class SendADstatus(Message):
    Summery_TotalRecordCount = 0
    Summery_TotalRecordLength = 0
    Summery_ADStatusGroup = {}
    Summery_ND2Code = {}
    Summery_CancelCode = {}
    Summery_HandOffProhibit = {}
    firstDrawRDRinfo = []
    lastDrawRDRinfo = None
    
    if getLocal() == 'ja_JP':
        MPUerror_symbolDic = {
            8:(QtGui.QColor.fromRgb(8,8,0),'(0x08)[CPU間通信] or [6軸センサ] or [EtherSwitch] or [時間管理]'),
            10:(QtGui.QColor.fromRgb(10,10,0),'(0x0A)[ROM] V-CPU ROM異常 or GNSS ROM異常 or eMMC異常'),
            13:(QtGui.QColor.fromRgb(13,13,0),'(0x0D)[温度] ECU内部温度異常(高温)'),
            16:(QtGui.QColor.fromRgb(16,16,0),'(0x10)[電源] バッテリー電源電圧異常(高圧)　電源電圧＞18.0V'),
            17:(QtGui.QColor.fromRgb(17,17,0),'(0x11)[電源] 1次電源電圧異常 or 2次電源電圧異常'),
            24:(QtGui.QColor.fromRgb(24,24,0),'(0x18)[USB電源] USB電源異常'),
            32:(QtGui.QColor.fromRgb(32,32,0),'(0x20)[GNSSアンテナ] GNSSアンテナ異常(オープン)'),
            33:(QtGui.QColor.fromRgb(33,33,0),'(0x21)[GNSSアンテナ] GNSSアンテナ異常(ショート)'),
            40:(QtGui.QColor.fromRgb(40,40,0),'(0x28)[地図] HDmapデータ異常 or SDmapデータ異常'),
            48:(QtGui.QColor.fromRgb(48,48,0),'(0x30)[地図] RBデータ/アライメントデータ異常'),
            88:(QtGui.QColor.fromRgb(88,88,0),'(0x58)[6軸センサ] ユニットキャリブレーション未実施'),
            112:(QtGui.QColor.fromRgb(112,112,0),'(0x70)[Ether] Ether通信異常'),
            113:(QtGui.QColor.fromRgb(113,113,0),'(0x71)[Ether] Ether受信データ異常'),
            128:(QtGui.QColor.fromRgb(128,128,0),'(0x80)[GNSS] GNSS通信異常'),
            129:(QtGui.QColor.fromRgb(129,129,0),'(0x81)[GNSS] GNSSデータ異常'),
            152:(QtGui.QColor.fromRgb(152,152,0),'(0x98)[その他] VINデータ不一致'),
            176:(QtGui.QColor.fromRgb(176,176,0),'(0xB0)[GNSSアンテナ] Lバンドアンテナ異常(オープン)'),
            177:(QtGui.QColor.fromRgb(177,177,0),'(0xB1)[GNSSアンテナ] Lバンドンテナ異常(ショート)')}
        
    else:
        MPUerror_symbolDic = {
            8:(QtGui.QColor.fromRgb(8,8,0),'(0x08)[Inter CPU com] or [6-axis sensor] or [EtherSwitch] or [Timestamp]'),
            10:(QtGui.QColor.fromRgb(10,10,0),'(0x0A)[ROM defect] V-CPU ROM or GNSS ROM or eMMC'),
            13:(QtGui.QColor.fromRgb(13,13,0),'(0x0D)[Temperature] ECU inner temperature high'),
            16:(QtGui.QColor.fromRgb(16,16,0),'(0x10)[Power defect] Voltage high　over 18.0V'),
            17:(QtGui.QColor.fromRgb(17,17,0),'(0x11)[Power defect] first power or secondary power'),
            24:(QtGui.QColor.fromRgb(24,24,0),'(0x18)[USB Power] USB Power defect'),
            32:(QtGui.QColor.fromRgb(32,32,0),'(0x20)[GNSS antenna] GNSS antenna circuit open'),
            33:(QtGui.QColor.fromRgb(33,33,0),'(0x21)[GNSS antenna] GNSS antenna circuit short'),
            40:(QtGui.QColor.fromRgb(40,40,0),'(0x28)[Map] HDmap data fail or SDmap data fail'),
            48:(QtGui.QColor.fromRgb(48,48,0),'(0x30)[Map] RB data/alignment data fail'),
            88:(QtGui.QColor.fromRgb(88,88,0),'(0x58)[6-axis sensor] None callibration'),
            112:(QtGui.QColor.fromRgb(112,112,0),'(0x70)[Ether] Ether Com fail'),
            113:(QtGui.QColor.fromRgb(113,113,0),'(0x71)[Ether] Ether receive data abnormal'),
            128:(QtGui.QColor.fromRgb(128,128,0),'(0x80)[GNSS] GNSS receive fail'),
            129:(QtGui.QColor.fromRgb(129,129,0),'(0x81)[GNSS] GNSS data fail'),
            152:(QtGui.QColor.fromRgb(152,152,0),'(0x98)[Other] VIN number mismatch'),
            176:(QtGui.QColor.fromRgb(176,176,0),'(0xB0)[GNSS antenna] L-band antenna circuit open'),
            177:(QtGui.QColor.fromRgb(177,177,0),'(0xB1)[GNSS antenna] L-band antenna circuit short')}
        
    if getLocal() == 'ja_JP':    
        Hands_off_prohibit_symbolDic = {
            66:(QtGui.QColor.fromRgb(4,104,115),'(66)バッテリー高電圧異常'),
            68:(QtGui.QColor.fromRgb(4,138,165),'(68)バッテリー低電圧異常'),
            72:(QtGui.QColor.fromRgb(4,207,9),'(72)IGN電圧診断'),
            74:(QtGui.QColor.fromRgb(4,241,59),'(74)IGN異常'),
            76:(QtGui.QColor.fromRgb(5,19,109),'(76)内部電源回路診断'),
            80:(QtGui.QColor.fromRgb(5,87,209),'(80)RAM異常'),
            84:(QtGui.QColor.fromRgb(5,156,53),'(84)Flash ROM異常'),
            88:(QtGui.QColor.fromRgb(5,224,153),'(88)ECM Error'),
            92:(QtGui.QColor.fromRgb(6,36,253),'(92)SPIDER診断'),
            96:(QtGui.QColor.fromRgb(6,105,97),'(96)CANコントローラ診断'),
            100:(QtGui.QColor.fromRgb(6,173,197),'(100)イーサネット診断'),
            104:(QtGui.QColor.fromRgb(6,242,42),'(104)リレー出力診断'),
            105:(QtGui.QColor.fromRgb(7,3,67),'(105)SPI通信CRC診断'),
            106:(QtGui.QColor.fromRgb(7,20,92),'(106)SPI通信Clock診断'),
            107:(QtGui.QColor.fromRgb(7,37,117),'(107)SPI通信未受信診断'),
            108:(QtGui.QColor.fromRgb(7,54,142),'(108)ITS電源回路診断'),
            112:(QtGui.QColor.fromRgb(7,122,242),'(112)SPI診断'),
            116:(QtGui.QColor.fromRgb(7,191,86),'(116)LIN診断'),
            120:(QtGui.QColor.fromRgb(8,3,186),'(120)温度センサ異常'),
            124:(QtGui.QColor.fromRgb(8,72,30),'(124)CAN通信遮断診断'),
            128:(QtGui.QColor.fromRgb(8,140,130),'(128)LED回路異常'),
            132:(QtGui.QColor.fromRgb(8,208,230),'(132)MAIN_CPU内部電圧異常'),
            136:(QtGui.QColor.fromRgb(9,21,74),'(136)SUB_CPU内部電圧異常'),
            140:(QtGui.QColor.fromRgb(9,89,174),'(140)CPU間通信（GPIO）診断'),
            144:(QtGui.QColor.fromRgb(9,158,18),'(144)シャットダウン正常終了判定'),
            148:(QtGui.QColor.fromRgb(9,226,118),'(148)IPD異常'),
            152:(QtGui.QColor.fromRgb(10,38,218),'(152)M3N外部RAM異常'),
            156:(QtGui.QColor.fromRgb(10,107,63),'(156)M3N外部ROM異常'),
            160:(QtGui.QColor.fromRgb(10,175,163),'(160)AutoACC診断'),
            164:(QtGui.QColor.fromRgb(10,244,7),'(164)EEPROM異常'),
            184:(QtGui.QColor.fromRgb(12,73,251),'(184)SPIヘッダバージョン診断'),
            188:(QtGui.QColor.fromRgb(12,142,95),'(188)バリアントコード異常'),
            192:(QtGui.QColor.fromRgb(12,210,195),'(192)バスオフ(ITS1-FD JT2)'),
            193:(QtGui.QColor.fromRgb(12,227,220),'(193)バスオフ(ITS2-FD JT2)'),
            194:(QtGui.QColor.fromRgb(12,244,245),'(194)バスオフ(ITS3-FD JT2)'),
            195:(QtGui.QColor.fromRgb(13,6,14),'(195)バスオフ(ITS4-FD JT2)'),
            196:(QtGui.QColor.fromRgb(13,23,39),'(196)バスオフ(ITS5-FD JT2)'),
            197:(QtGui.QColor.fromRgb(13,40,64),'(197)バスオフ(CH2-CAN JT2)'),
            200:(QtGui.QColor.fromRgb(13,91,139),'(200)CAN未受信異常(ITS4-FD IDM:JT2)(MAC)'),
            200:(QtGui.QColor.fromRgb(13,91,139),'(200)CAN未受信異常(ITS4-FD EPS:JT2)(MAC)'),
            201:(QtGui.QColor.fromRgb(13,108,164),'(201)CAN未受信異常(ITS1-FD IDM:JT2)(MAC)'),
            201:(QtGui.QColor.fromRgb(13,108,164),'(201)CAN未受信異常(ITS1-FD ePKB:JT2)(MAC)'),
            201:(QtGui.QColor.fromRgb(13,108,164),'(201)CAN未受信異常(ITS1-FD EPS:JT2)(MAC)'),
            202:(QtGui.QColor.fromRgb(13,125,189),'(202)CAN未受信異常(ITS1-FD METER:JT2)(MAC)'),
            202:(QtGui.QColor.fromRgb(13,125,189),'(202)CAN未受信異常(ITS1-FD BCM:JT2)(MAC)'),
            202:(QtGui.QColor.fromRgb(13,125,189),'(202)CAN未受信異常(ITS4-FD USM:JT2)(MAC)'),
            203:(QtGui.QColor.fromRgb(13,142,214),'(203)CAN未受信異常(ITS4-FD METER:JT2)(MAC)'),
            203:(QtGui.QColor.fromRgb(13,142,214),'(203)CAN未受信異常(ITS4-FD BCM:JT2)(MAC)'),
            204:(QtGui.QColor.fromRgb(13,159,239),'(204)CAN未受信異常(ITS1-FD HEVC:JT2)(MAC)'),
            205:(QtGui.QColor.fromRgb(13,177,8),'(205)CAN未受信異常(ITS4-FD HEVC:JT2)(MAC)'),
            206:(QtGui.QColor.fromRgb(13,194,33),'(206)CAN未受信異常(ITS1-FD AVM:JT2)(MAC)'),
            207:(QtGui.QColor.fromRgb(13,211,59),'(207)CAN未受信異常(ITS4-FD AVM:JT2)(MAC)'),
            208:(QtGui.QColor.fromRgb(13,228,84),'(208)CAN未受信異常(ITS4-FD SONAR:JT2)(MAC)'),
            216:(QtGui.QColor.fromRgb(14,109,28),'(216)CAN未受信異常(ITS1-FD IDM:JT1)'),
            216:(QtGui.QColor.fromRgb(14,109,28),'(216)CAN未受信異常(ITS1-FD IDM:JT2)'),
            218:(QtGui.QColor.fromRgb(14,143,78),'(218)メッセージカウンタ診断(ITS1-FD CDM)'),
            219:(QtGui.QColor.fromRgb(14,160,103),'(219)チェックサム診断(ITS1-FD CDM)'),
            220:(QtGui.QColor.fromRgb(14,177,128),'(220)CAN未受信異常(ITS4-FD IDM:JT2)'),
            221:(QtGui.QColor.fromRgb(14,194,153),'(221)CAN未受信異常(ITS4-FD IDM:JT1)'),
            222:(QtGui.QColor.fromRgb(14,211,178),'(222)メッセージカウンタ診断(ITS4-FD CDM)'),
            223:(QtGui.QColor.fromRgb(14,228,203),'(223)チェックサム診断(ITS4-FD CDM)'),
            224:(QtGui.QColor.fromRgb(14,245,228),'(224)CAN未受信異常(ITS1-FD VDC:JT2)'),
            224:(QtGui.QColor.fromRgb(14,245,228),'(224)CAN未受信異常(ITS1-FD VDC:JT2)(MAC)'),
            225:(QtGui.QColor.fromRgb(15,6,253),'(225)CAN未受信異常(ITS1-FD VDC:JT1)'),
            226:(QtGui.QColor.fromRgb(15,24,22),'(226)メッセージカウンタ診断(ITS1-FD VDC)'),
            227:(QtGui.QColor.fromRgb(15,41,47),'(227)チェックサム診断(ITS1-FD VDC)'),
            228:(QtGui.QColor.fromRgb(15,58,72),'(228)CAN未受信異常(ITS4-FD VDC:JT2)'),
            228:(QtGui.QColor.fromRgb(15,58,72),'(228)CAN未受信異常(ITS4-FD VDC:JT2)(MAC)'),
            228:(QtGui.QColor.fromRgb(15,58,72),'(228)CAN未受信異常(ITS4-FD VDC via CH2:JT2)'),
            229:(QtGui.QColor.fromRgb(15,75,97),'(229)CAN未受信異常(ITS4-FD VDC:JT1)'),
            229:(QtGui.QColor.fromRgb(15,75,97),'(229)CAN未受信異常(ITS4-FD VDC via CH2:JT1)'),
            230:(QtGui.QColor.fromRgb(15,92,122),'(230)メッセージカウンタ診断(ITS4-FD VDC)'),
            231:(QtGui.QColor.fromRgb(15,109,147),'(231)チェックサム診断(ITS4-FD VDC)'),
            232:(QtGui.QColor.fromRgb(15,126,172),'(232)CAN未受信異常(CH2-CAN VDC:JT2)'),
            234:(QtGui.QColor.fromRgb(15,160,222),'(234)メッセージカウンタ診断(CH2-CAN VDC)'),
            235:(QtGui.QColor.fromRgb(15,177,247),'(235)チェックサム診断(CH2-CAN VDC)'),
            236:(QtGui.QColor.fromRgb(15,195,16),'(236)CAN未受信異常(ITS1-FD ePKB:JT2)'),
            237:(QtGui.QColor.fromRgb(15,212,41),'(237)CAN未受信異常(ITS1-FD ePKB:JT1)'),
            238:(QtGui.QColor.fromRgb(15,229,66),'(238)メッセージカウンタ診断(ITS4-FD ePKB)'),
            239:(QtGui.QColor.fromRgb(15,246,91),'(239)チェックサム診断(ITS4-FD ePKB)'),
            242:(QtGui.QColor.fromRgb(16,41,166),'(242)メッセージカウンタ診断(CH2-CAN ePKB)'),
            243:(QtGui.QColor.fromRgb(16,58,191),'(243)チェックサム診断(CH2-CAN ePKB)'),
            244:(QtGui.QColor.fromRgb(16,75,216),'(244)CAN未受信異常(ITS1-FD EBA:JT2)'),
            248:(QtGui.QColor.fromRgb(16,144,60),'(248)CAN未受信異常(CH2-CAN EBA:JT2)'),
            250:(QtGui.QColor.fromRgb(16,178,110),'(250)Clockフェール(CH2-CAN EBA)'),
            251:(QtGui.QColor.fromRgb(16,195,135),'(251)CRCフェール(CH2-CAN EBA)'),
            252:(QtGui.QColor.fromRgb(16,212,160),'(252)CAN未受信異常(ITS1-FD EPS:JT2)'),
            253:(QtGui.QColor.fromRgb(16,229,185),'(253)CAN未受信異常(ITS1-FD EPS:JT1)'),
            254:(QtGui.QColor.fromRgb(16,246,210),'(254)メッセージカウンタ診断(ITS1-FD EPS)'),
            255:(QtGui.QColor.fromRgb(17,7,235),'(255)チェックサム診断(ITS1-FD EPS)'),
            256:(QtGui.QColor.fromRgb(17,25,4),'(256)CAN未受信異常(ITS4-FD EPS:JT2)'),
            257:(QtGui.QColor.fromRgb(17,42,29),'(257)CAN未受信異常(ITS4-FD EPS:JT1)'),
            258:(QtGui.QColor.fromRgb(17,59,55),'(258)メッセージカウンタ診断(ITS4-FD EPS)'),
            259:(QtGui.QColor.fromRgb(17,76,80),'(259)チェックサム診断(ITS4-FD EPS)'),
            260:(QtGui.QColor.fromRgb(17,93,105),'(260)CAN未受信異常(CH2-CAN EPSsub:JT2)'),
            262:(QtGui.QColor.fromRgb(17,127,155),'(262)Clockフェール(CH2-CAN EPSsub)'),
            263:(QtGui.QColor.fromRgb(17,144,180),'(263)CRCフェール(CH2-CAN EPSsub)'),
            264:(QtGui.QColor.fromRgb(17,161,205),'(264)CAN未受信異常(ITS1-FD BCM:JT2)'),
            265:(QtGui.QColor.fromRgb(17,178,230),'(265)CAN未受信異常(ITS1-FD BCM:JT1)'),
            266:(QtGui.QColor.fromRgb(17,195,255),'(266)メッセージカウンタ診断(ITS1-FD BCM)'),
            267:(QtGui.QColor.fromRgb(17,213,24),'(267)チェックサム診断(ITS1-FD BCM)'),
            268:(QtGui.QColor.fromRgb(17,230,49),'(268)CAN未受信異常(ITS4-FD BCM:JT2)'),
            269:(QtGui.QColor.fromRgb(17,247,74),'(269)CAN未受信異常(ITS4-FD BCM:JT1)'),
            270:(QtGui.QColor.fromRgb(18,8,99),'(270)メッセージカウンタ診断(ITS4-FD BCM)'),
            271:(QtGui.QColor.fromRgb(18,25,124),'(271)チェックサム診断(ITS4-FD BCM)'),
            272:(QtGui.QColor.fromRgb(18,42,149),'(272)CAN未受信異常(ITS1-FD METER:JT2)'),
            276:(QtGui.QColor.fromRgb(18,110,249),'(276)CAN未受信異常(ITS4-FD METER:JT2)'),
            277:(QtGui.QColor.fromRgb(18,128,18),'(277)CAN未受信異常(ITS4-FD METER:JT1)'),
            278:(QtGui.QColor.fromRgb(18,145,43),'(278)メッセージカウンタ診断(ITS4-FD METER)'),
            279:(QtGui.QColor.fromRgb(18,162,68),'(279)チェックサム診断(ITS4-FD METER)'),
            280:(QtGui.QColor.fromRgb(18,179,93),'(280)CAN未受信異常(ITS4-FD STR:JT2)'),
            280:(QtGui.QColor.fromRgb(18,179,93),'(280)CAN未受信異常(ITS4-FD STR:JT2)(MAC)'),
            281:(QtGui.QColor.fromRgb(18,196,118),'(281)CAN未受信異常(ITS4-FD STR:JT1)'),
            282:(QtGui.QColor.fromRgb(18,213,143),'(282)メッセージカウンタ診断(ITS4-FD STR)'),
            283:(QtGui.QColor.fromRgb(18,230,168),'(283)チェックサム診断(ITS4-FD STR)'),
            284:(QtGui.QColor.fromRgb(18,247,193),'(284)CAN未受信異常(ITS1-FD HEVC:JT2)'),
            285:(QtGui.QColor.fromRgb(19,8,218),'(285)CAN未受信異常(ITS1-FD HEVC:JT1)'),
            286:(QtGui.QColor.fromRgb(19,25,243),'(286)メッセージカウンタ診断(ITS1-FD HEVC)'),
            287:(QtGui.QColor.fromRgb(19,43,12),'(287)チェックサム診断(ITS1-FD HEVC)'),
            288:(QtGui.QColor.fromRgb(19,60,37),'(288)CAN未受信異常(ITS4-FD HEVC:JT2)'),
            289:(QtGui.QColor.fromRgb(19,77,62),'(289)CAN未受信異常(ITS4-FD HEVC:JT1)'),
            290:(QtGui.QColor.fromRgb(19,94,87),'(290)メッセージカウンタ診断(ITS4-FD HEVC)'),
            291:(QtGui.QColor.fromRgb(19,111,112),'(291)チェックサム診断(ITS4-FD HEVC)'),
            292:(QtGui.QColor.fromRgb(19,128,137),'(292)メッセージカウンタ診断(ITS4-FD HCM)'),
            293:(QtGui.QColor.fromRgb(19,145,162),'(293)チェックサム診断(ITS4-FD HCM)'),
            294:(QtGui.QColor.fromRgb(19,162,187),'(294)メッセージカウンタ診断(ITS4-FD ATCU)'),
            295:(QtGui.QColor.fromRgb(19,179,212),'(295)チェックサム診断(ITS4-FD ATCU)'),
            296:(QtGui.QColor.fromRgb(19,196,237),'(296)Ethernet link down(Radar:JT2)'),
            297:(QtGui.QColor.fromRgb(19,214,6),'(297)Ethernet link down_2(Radar:JT2)'),
            298:(QtGui.QColor.fromRgb(19,231,31),'(298)Ethernet 未受信(Radar:JT2)'),
            299:(QtGui.QColor.fromRgb(19,248,56),'(299)Ethernet 未受信_2(Radar:JT2)'),
            300:(QtGui.QColor.fromRgb(20,9,81),'(300)Ethernet 未受信(Radar:JT1)'),
            301:(QtGui.QColor.fromRgb(20,26,106),'(301)Ethernet 未受信_2(Radar:JT1)'),
            302:(QtGui.QColor.fromRgb(20,43,131),'(302)Ethernet Clockフェール(Radar)'),
            303:(QtGui.QColor.fromRgb(20,60,156),'(303)Ethernet Clockフェール_2(Radar)'),
            304:(QtGui.QColor.fromRgb(20,77,181),'(304)Ethernet CRCフェール(Radar)'),
            305:(QtGui.QColor.fromRgb(20,94,206),'(305)Ethernet CRCフェール_2(Radar)'),
            306:(QtGui.QColor.fromRgb(20,111,231),'(306)CAN未受信異常(ITS2-FD CAM:JT2)'),
            307:(QtGui.QColor.fromRgb(20,129,0),'(307)CAN未受信異常(ITS2-FD CAM:JT1)'),
            308:(QtGui.QColor.fromRgb(20,146,25),'(308)Clockフェール(ITS2-FD Camera)'),
            309:(QtGui.QColor.fromRgb(20,163,50),'(309)CRCフェール(ITS2-FD FrCamera)'),
            310:(QtGui.QColor.fromRgb(20,180,76),'(310)Ethernet link down(FrCamera:JT2)'),
            311:(QtGui.QColor.fromRgb(20,197,101),'(311)Ethernet link down_2(FrCamera:JT2)'),
            312:(QtGui.QColor.fromRgb(20,214,126),'(312)Ethernet 未受信(FrCamera2:JT2)'),
            313:(QtGui.QColor.fromRgb(20,231,151),'(313)Ethernet 未受信_2(FrCamera2:JT2)'),
            314:(QtGui.QColor.fromRgb(20,248,176),'(314)Ethernet 未受信(FrCamera2:JT1)'),
            315:(QtGui.QColor.fromRgb(21,9,201),'(315)Ethernet 未受信_2(FrCamera2:JT1)'),
            316:(QtGui.QColor.fromRgb(21,26,226),'(316)Ethernet Clockフェール(FrCamera2)'),
            317:(QtGui.QColor.fromRgb(21,43,251),'(317)Ethernet Clockフェール_2(FrCamera2)'),
            318:(QtGui.QColor.fromRgb(21,61,20),'(318)Ethernet CRCフェール(FrCamera2)'),
            319:(QtGui.QColor.fromRgb(21,78,45),'(319)Ethernet CRCフェール_2(FrCamera2)'),
            320:(QtGui.QColor.fromRgb(21,95,70),'(320)CAN未受信異常(ITS1-FD AVM:JT2)'),
            321:(QtGui.QColor.fromRgb(21,112,95),'(321)CAN未受信異常(ITS1-FD AVM:JT1)'),
            322:(QtGui.QColor.fromRgb(21,129,120),'(322)メッセージカウンタ診断(ITS1-FD AVM)'),
            323:(QtGui.QColor.fromRgb(21,146,145),'(323)チェックサム診断(ITS1-FD AVM)'),
            324:(QtGui.QColor.fromRgb(21,163,170),'(324)CAN未受信異常(ITS3-FD AVM:JT2)'),
            326:(QtGui.QColor.fromRgb(21,197,220),'(326)メッセージカウンタ診断(ITS3-FD AVM)'),
            327:(QtGui.QColor.fromRgb(21,214,245),'(327)チェックサム診断(ITS3-FD AVM)'),
            328:(QtGui.QColor.fromRgb(21,232,14),'(328)CAN未受信異常(ITS4-FD AVM:JT2)'),
            329:(QtGui.QColor.fromRgb(21,249,39),'(329)CAN未受信異常(ITS4-FD AVM:JT1)'),
            330:(QtGui.QColor.fromRgb(22,10,64),'(330)メッセージカウンタ診断(ITS4-FD AVM)'),
            331:(QtGui.QColor.fromRgb(22,27,89),'(331)チェックサム診断(ITS4-FD AVM)'),
            332:(QtGui.QColor.fromRgb(22,44,114),'(332)Ethernet link down(AVM:JT2)'),
            333:(QtGui.QColor.fromRgb(22,61,139),'(333)Ethernet link down_2(AVM:JT2)'),
            334:(QtGui.QColor.fromRgb(22,78,164),'(334)Ethernet 未受信(AVM:JT2)'),
            335:(QtGui.QColor.fromRgb(22,95,189),'(335)Ethernet 未受信_2(AVM:JT2)'),
            336:(QtGui.QColor.fromRgb(22,112,214),'(336)Ethernet 未受信(AVM:JT1)'),
            337:(QtGui.QColor.fromRgb(22,129,239),'(337)Ethernet 未受信_2(AVM:JT1)'),
            338:(QtGui.QColor.fromRgb(22,147,8),'(338)Ethernet Clockフェール(AVM)'),
            339:(QtGui.QColor.fromRgb(22,164,33),'(339)Ethernet Clockフェール_2(AVM)'),
            340:(QtGui.QColor.fromRgb(22,181,58),'(340)Ethernet CRCフェール(AVM)'),
            341:(QtGui.QColor.fromRgb(22,198,83),'(341)Ethernet CRCフェール_2(AVM)'),
            342:(QtGui.QColor.fromRgb(22,215,108),'(342)Ethernet link down_2(HDMap:JT2)'),
            343:(QtGui.QColor.fromRgb(22,232,133),'(343)Ethernet 未受信_2(HDMap:JT2)'),
            344:(QtGui.QColor.fromRgb(22,249,158),'(344)Ethernet 未受信_2(HDMap:JT1)'),
            345:(QtGui.QColor.fromRgb(23,10,183),'(345)CAN未受信異常(ITS3-FD SOW-RL:JT2)'),
            346:(QtGui.QColor.fromRgb(23,27,208),'(346)CAN未受信異常(ITS3-FD SOW-RL:JT1)'),
            347:(QtGui.QColor.fromRgb(23,44,233),'(347)メッセージカウンタ診断(ITS3-FD SR:RL)'),
            348:(QtGui.QColor.fromRgb(23,62,2),'(348)チェックサム診断(ITS3-FD SR:RL)'),
            349:(QtGui.QColor.fromRgb(23,79,27),'(349)CAN未受信異常(ITS3-FD SOW-RR:JT2)'),
            350:(QtGui.QColor.fromRgb(23,96,52),'(350)CAN未受信異常(ITS3-FD SOW-RR:JT1)'),
            351:(QtGui.QColor.fromRgb(23,113,77),'(351)メッセージカウンタ診断(ITS3-FD SR:RR)'),
            352:(QtGui.QColor.fromRgb(23,130,102),'(352)チェックサム診断(ITS3-FD SR:RR)'),
            353:(QtGui.QColor.fromRgb(23,147,127),'(353)CAN未受信異常(ITS5-FD SRad_FL:JT2)'),
            354:(QtGui.QColor.fromRgb(23,164,152),'(354)CAN未受信異常(ITS5-FD SRad_FL:JT1)'),
            355:(QtGui.QColor.fromRgb(23,181,177),'(355)メッセージカウンタ診断(ITS5-FD SR:FL)'),
            356:(QtGui.QColor.fromRgb(23,198,202),'(356)チェックサム診断(ITS5-FD SR:FL)'),
            357:(QtGui.QColor.fromRgb(23,215,227),'(357)CAN未受信異常(ITS5-FD SRad_FR:JT2)'),
            358:(QtGui.QColor.fromRgb(23,232,252),'(358)CAN未受信異常(ITS5-FD SRad_FR:JT1)'),
            359:(QtGui.QColor.fromRgb(23,250,21),'(359)メッセージカウンタ診断(ITS5-FD SR:FR)'),
            360:(QtGui.QColor.fromRgb(24,11,46),'(360)チェックサム診断(ITS5-FD SR:FR)'),
            361:(QtGui.QColor.fromRgb(24,28,71),'(361)CAN未受信異常(ITS4-FD SONAR:JT2)'),
            362:(QtGui.QColor.fromRgb(24,45,97),'(362)メッセージカウンタ診断(ITS4-FD SONAR)'),
            363:(QtGui.QColor.fromRgb(24,62,122),'(363)チェックサム診断(ITS4-FD SONAR)'),
            364:(QtGui.QColor.fromRgb(24,79,147),'(364)CAN未受信異常(CH2-CAN HUD:JT2)'),
            366:(QtGui.QColor.fromRgb(24,113,197),'(366)Clockフェール(CH2-CAN HUD)'),
            367:(QtGui.QColor.fromRgb(24,130,222),'(367)CRCフェール(CH2-CAN HUD)'),
            368:(QtGui.QColor.fromRgb(24,147,247),'(368)CAN未受信異常(ITS2-FD DMC:JT2)'),
            370:(QtGui.QColor.fromRgb(24,182,41),'(370)Clockフェール(ITS2-FD DMC)'),
            371:(QtGui.QColor.fromRgb(24,199,66),'(371)CRCフェール(ITS2-FD DMC)'),
            372:(QtGui.QColor.fromRgb(24,216,91),'(372)CAN未受信異常(ITS4-FD USM:JT2)'),
            373:(QtGui.QColor.fromRgb(24,233,116),'(373)CAN未受信異常(ITS4-FD USM:JT1)'),
            374:(QtGui.QColor.fromRgb(24,250,141),'(374)メッセージカウンタ診断(ITS4-FD USM)'),
            375:(QtGui.QColor.fromRgb(25,11,166),'(375)チェックサム診断(ITS4-FD USM)'),
            400:(QtGui.QColor.fromRgb(26,183,23),'(400)LIN バスオフ'),
            404:(QtGui.QColor.fromRgb(26,251,123),'(404)LIN未受信(HOD:JT2)'),
            406:(QtGui.QColor.fromRgb(27,29,173),'(406)LIN Clockフェール(HOD)'),
            407:(QtGui.QColor.fromRgb(27,46,198),'(407)LIN CRCフェール(HOD)'),
            416:(QtGui.QColor.fromRgb(27,200,168),'(416)CDM判断によるPath使用不可通知'),
            420:(QtGui.QColor.fromRgb(28,13,12),'(420)ICC異常(VDC)'),
            424:(QtGui.QColor.fromRgb(28,81,112),'(424)AEB異常(VDC)'),
            428:(QtGui.QColor.fromRgb(28,149,212),'(428)Steering異常(EPSmain)'),
            432:(QtGui.QColor.fromRgb(28,218,56),'(432)ICC異常(EBA)'),
            436:(QtGui.QColor.fromRgb(29,30,156),'(436)AEB異常(EBA)'),
            440:(QtGui.QColor.fromRgb(29,99,0),'(440)Steering異常(EPSsub)'),
            444:(QtGui.QColor.fromRgb(29,167,100),'(444)CDMからのADAS_sub(AVM)異常通知'),
            448:(QtGui.QColor.fromRgb(29,235,200),'(448)Path1 ICC NG'),
            452:(QtGui.QColor.fromRgb(30,48,44),'(452)Path1 AEB NG'),
            456:(QtGui.QColor.fromRgb(30,116,144),'(456)AEB（VDC ECU）機能故障診断(Type C)'),
            460:(QtGui.QColor.fromRgb(30,184,244),'(460)ICC（VDC ECU）機能故障診断(Type C)'),
            464:(QtGui.QColor.fromRgb(30,253,88),'(464)ECD(VDC ECU) 電源電圧異常(Type C)'),
            468:(QtGui.QColor.fromRgb(31,65,189),'(468)EPSフェール'),
            472:(QtGui.QColor.fromRgb(31,134,33),'(472)IDM CAN異常診断結果(Type C)'),
            476:(QtGui.QColor.fromRgb(31,202,133),'(476)IDM異常判定'),
            480:(QtGui.QColor.fromRgb(32,14,233),'(480)IDMトルク指令値異常'),
            484:(QtGui.QColor.fromRgb(32,83,77),'(484)ACC_ALIVE_OFFフェール'),
            488:(QtGui.QColor.fromRgb(32,151,177),'(488)ACC_ALIVE_OFFフェール(IDM)'),
            492:(QtGui.QColor.fromRgb(32,220,21),'(492)VDCシステム故障診断結果(Type C)'),
            496:(QtGui.QColor.fromRgb(33,32,121),'(496)ABSシステム故障診断結果(Type C)'),
            500:(QtGui.QColor.fromRgb(33,100,221),'(500)TCSｼｽﾃﾑ故障診断結果(Type C)'),
            504:(QtGui.QColor.fromRgb(33,169,65),'(504)VDC内LDP機能異常診断結果(Type C)'),
            508:(QtGui.QColor.fromRgb(33,237,165),'(508)VDC ECU診断中判定'),
            512:(QtGui.QColor.fromRgb(34,50,9),'(512)前輪車輪速センサ不整合故障診断結果(Right)'),
            513:(QtGui.QColor.fromRgb(34,67,34),'(513)前輪車輪速センサ不整合故障診断結果(Left)'),
            514:(QtGui.QColor.fromRgb(34,84,59),'(514)後輪車輪速センサ不整合故障診断結果(Right)'),
            515:(QtGui.QColor.fromRgb(34,101,84),'(515)後輪車輪速センサ不整合故障診断結果(Left)'),
            516:(QtGui.QColor.fromRgb(34,118,110),'(516)車速センサ不整合故障'),
            520:(QtGui.QColor.fromRgb(34,186,210),'(520)車輪速ｾﾝｻUnavailableValue'),
            524:(QtGui.QColor.fromRgb(34,255,54),'(524)車輪速パルス信号異常判断(Left)'),
            525:(QtGui.QColor.fromRgb(35,16,79),'(525)車輪速パルス信号異常判断(Right)'),
            528:(QtGui.QColor.fromRgb(35,67,154),'(528)ブレーキSW故障診断結果'),
            532:(QtGui.QColor.fromRgb(35,135,254),'(532)ストップランプリレーOFF固着診断結果'),
            536:(QtGui.QColor.fromRgb(35,204,98),'(536)ストップランプリレー診断(CDMによるランプ制御)'),
            540:(QtGui.QColor.fromRgb(36,16,198),'(540)ストップランプリレーON固着診断'),
            544:(QtGui.QColor.fromRgb(36,85,42),'(544)ePKB パーキングブレーキ異常表示フェール'),
            548:(QtGui.QColor.fromRgb(36,153,142),'(548)ePKB SSAフェールフラグ フェール'),
            552:(QtGui.QColor.fromRgb(36,221,242),'(552)ｱｸｾﾙﾍﾟﾀﾞﾙﾌｪｰﾙﾌﾗｸﾞ検出診断結果'),
            556:(QtGui.QColor.fromRgb(37,34,86),'(556)ETCフェールフラグ検出診断結果'),
            560:(QtGui.QColor.fromRgb(37,102,186),'(560)ECMCANFAILフラグ診断結果'),
            564:(QtGui.QColor.fromRgb(37,171,30),'(564)ACC指令値異常検出診断結果'),
            568:(QtGui.QColor.fromRgb(37,239,131),'(568)HCMｼｽﾃﾑ異常'),
            572:(QtGui.QColor.fromRgb(38,51,231),'(572)ECMASCDﾌｪｰﾙﾌﾗｸﾞ検出'),
            574:(QtGui.QColor.fromRgb(38,86,25),'(574)レーン情報喪失(Eth及びCAN)'),
            575:(QtGui.QColor.fromRgb(38,103,50),'(575)レーン情報受信異常'),
            576:(QtGui.QColor.fromRgb(38,120,75),'(576)ECMACCINHﾌﾗｸﾞ診断'),
            580:(QtGui.QColor.fromRgb(38,188,175),'(580)ギヤ位置不整合検出(AT)'),
            584:(QtGui.QColor.fromRgb(39,1,19),'(584)ギヤ位置不整合検出(CVT)'),
            588:(QtGui.QColor.fromRgb(39,69,119),'(588)CVTシステム異常'),
            592:(QtGui.QColor.fromRgb(39,137,219),'(592)舵角センサ異常診断結果'),
            596:(QtGui.QColor.fromRgb(39,206,63),'(596)ステアリングSW溶着診断（C1N）'),
            600:(QtGui.QColor.fromRgb(40,18,163),'(600)ｽﾃｱﾘﾝｸﾞ SW 論理異常フェール （C1N）'),
            604:(QtGui.QColor.fromRgb(40,87,7),'(604)ICCﾒｲﾝ SW溶着故障 （C1N）'),
            608:(QtGui.QColor.fromRgb(40,155,107),'(608)ステアリングSW溶着診断（C1A)'),
            612:(QtGui.QColor.fromRgb(40,223,207),'(612)ICCﾒｲﾝ SW溶着故障(C1A)'),
            616:(QtGui.QColor.fromRgb(41,36,51),'(616)ｽﾃｱﾘﾝｸﾞ SW 論理異常フェール(C1A)'),
            620:(QtGui.QColor.fromRgb(41,104,152),'(620)METER故障診断'),
            624:(QtGui.QColor.fromRgb(41,172,252),'(624)ADAS_METER通信故障診断'),
            628:(QtGui.QColor.fromRgb(41,241,96),'(628)ﾐﾘ波ﾚｰﾀﾞ故障診断結果'),
            632:(QtGui.QColor.fromRgb(42,53,196),'(632)ﾐﾘ波ﾚｰﾀﾞｰCAN通信異常診断結果'),
            636:(QtGui.QColor.fromRgb(42,122,40),'(636)ﾐﾘ波ﾚｰﾀﾞ高温異常診断結果'),
            640:(QtGui.QColor.fromRgb(42,190,140),'(640)ﾐﾘ波ﾚｰﾀﾞｰ低電圧異常診断結果'),
            644:(QtGui.QColor.fromRgb(43,2,240),'(644)ﾐﾘ波ﾚｰﾀﾞｰ軸ずれ異常診断結果'),
            648:(QtGui.QColor.fromRgb(43,71,84),'(648)ADAS->FrontRadar通信フェール'),
            652:(QtGui.QColor.fromRgb(43,139,184),'(652)FrontRadar BackUp Modeフェール'),
            656:(QtGui.QColor.fromRgb(43,208,28),'(656)FrontRadar故障フェール'),
            660:(QtGui.QColor.fromRgb(44,20,128),'(660)カメラ異常判断診断結果'),
            664:(QtGui.QColor.fromRgb(44,88,228),'(664)カメラエーミング未実施診断結果'),
            668:(QtGui.QColor.fromRgb(44,157,72),'(668)カメラ高温検知1診断結果'),
            672:(QtGui.QColor.fromRgb(44,225,173),'(672)ADAS->FrontCamera通信フェール'),
            674:(QtGui.QColor.fromRgb(45,3,223),'(674)TSR信号通信異常診断'),
            676:(QtGui.QColor.fromRgb(45,38,17),'(676)ADAS sub->FrontCamera通信フェール'),
            680:(QtGui.QColor.fromRgb(45,106,117),'(680)FrontCamera BackUp Modeフェール'),
            684:(QtGui.QColor.fromRgb(45,174,217),'(684)FrontCamera故障フェール'),
            688:(QtGui.QColor.fromRgb(45,243,61),'(688)ハンズオフ判定しきい値未キャリブ'),
            692:(QtGui.QColor.fromRgb(46,55,161),'(692)ADASmainによるADASsub故障診断'),
            696:(QtGui.QColor.fromRgb(46,124,5),'(696)AD2 Sub系統フェール(LK禁止)'),
            696:(QtGui.QColor.fromRgb(46,124,5),'(696)AD2 Sub系統フェール(AD2禁止)'),
            697:(QtGui.QColor.fromRgb(46,141,30),'(697)AVM認識状態異常'),
            700:(QtGui.QColor.fromRgb(46,192,105),'(700)AVMステータスフェール'),
            708:(QtGui.QColor.fromRgb(47,73,49),'(708)SOWセンサLEFT 異常判断診断結果'),
            712:(QtGui.QColor.fromRgb(47,141,149),'(712)SOWセンサRIGHT 異常判断診断結果'),
            716:(QtGui.QColor.fromRgb(47,209,249),'(716)SOWセンサLEFT CAN未受信診断結果'),
            720:(QtGui.QColor.fromRgb(48,22,93),'(720)SOWセンサRIGHT CAN未受信診断結果'),
            724:(QtGui.QColor.fromRgb(48,90,194),'(724)SOWセンサLEFT 異常判断2'),
            728:(QtGui.QColor.fromRgb(48,159,38),'(728)SOWセンサRIGHT 異常判断2'),
            732:(QtGui.QColor.fromRgb(48,227,138),'(732)SOWセンサFL異常判断(AD2)'),
            736:(QtGui.QColor.fromRgb(49,39,238),'(736)SOWセンサFR異常判断(AD2)'),
            740:(QtGui.QColor.fromRgb(49,108,82),'(740)SOWセンサRL異常判断(AD2)'),
            744:(QtGui.QColor.fromRgb(49,176,182),'(744)SOWセンサRR異常判断(AD2)'),
            748:(QtGui.QColor.fromRgb(49,245,26),'(748)SOWセンサLEFT 異常判断3'),
            752:(QtGui.QColor.fromRgb(50,57,126),'(752)SOWセンサRIGHT 異常判断3'),
            756:(QtGui.QColor.fromRgb(50,125,226),'(756)ソナー異常判断(EAP)'),
            760:(QtGui.QColor.fromRgb(50,194,70),'(760)ソナーシステム故障'),
            764:(QtGui.QColor.fromRgb(51,6,170),'(764)HD-MAPエラーメッセージフェール'),
            768:(QtGui.QColor.fromRgb(51,75,14),'(768)HUD故障診断'),
            772:(QtGui.QColor.fromRgb(51,143,114),'(772)ADAS_HUD通信故障診断'),
            776:(QtGui.QColor.fromRgb(51,211,215),'(776)DMS故障'),
            780:(QtGui.QColor.fromRgb(52,24,59),'(780)DMSエーミング未実施'),
            784:(QtGui.QColor.fromRgb(52,92,159),'(784)EEM故障'),
            788:(QtGui.QColor.fromRgb(52,161,3),'(788)空気圧異常'),
            796:(QtGui.QColor.fromRgb(53,41,203),'(796)HOD異常診断'),
            800:(QtGui.QColor.fromRgb(53,110,47),'(800)HOD HW異常'),
            802:(QtGui.QColor.fromRgb(53,144,97),'(802)HOD HW異常'),
            803:(QtGui.QColor.fromRgb(53,161,122),'(803)HOD HW異常'),
            804:(QtGui.QColor.fromRgb(53,178,147),'(804)HOD HW異常'),
            807:(QtGui.QColor.fromRgb(53,229,222),'(807)HOD バス異常'),
            808:(QtGui.QColor.fromRgb(53,246,247),'(808)EPSモーター角度値無効'),
            812:(QtGui.QColor.fromRgb(54,59,91),'(812)EPSsubモーター角度値無効'),
            816:(QtGui.QColor.fromRgb(54,127,191),'(816)EPSステアリングトルク値無効'),
            820:(QtGui.QColor.fromRgb(54,196,35),'(820)EPSubステアリングトルク値無効'),
            824:(QtGui.QColor.fromRgb(55,8,135),'(824)ブレーキペダル信号異常'),
            828:(QtGui.QColor.fromRgb(55,76,236),'(828)ブレーキペダル信号2異常'),
            832:(QtGui.QColor.fromRgb(55,145,80),'(832)ブレーキ圧力センサ信号異常'),
            836:(QtGui.QColor.fromRgb(55,213,180),'(836)車速センサ信号異常'),
            840:(QtGui.QColor.fromRgb(56,26,24),'(840)車輪速パルス信号異常(FL)'),
            841:(QtGui.QColor.fromRgb(56,43,49),'(841)車輪速パルス信号異常(FR)'),
            844:(QtGui.QColor.fromRgb(56,94,124),'(844)車輪回転方向信号異常(RL)'),
            845:(QtGui.QColor.fromRgb(56,111,149),'(845)車輪回転方向信号異常(RR)'),
            848:(QtGui.QColor.fromRgb(56,162,224),'(848)ヨーレートセンサ信号異常'),
            852:(QtGui.QColor.fromRgb(56,231,68),'(852)補正横加速度信号異常'),
            856:(QtGui.QColor.fromRgb(57,43,168),'(856)補正縦加速度信号異常'),
            860:(QtGui.QColor.fromRgb(57,112,12),'(860)ステアリングホイール角信号異常'),
            864:(QtGui.QColor.fromRgb(57,180,112),'(864)ギヤ位置信号異常'),
            868:(QtGui.QColor.fromRgb(57,248,212),'(868)アクセルセンサ信号異常'),
            872:(QtGui.QColor.fromRgb(58,61,56),'(872)ワイパー信号異常'),
            876:(QtGui.QColor.fromRgb(58,129,156),'(876)外気温センサ信号異常'),
            880:(QtGui.QColor.fromRgb(58,198,1),'(880)車輪回転方向信号異常(FL)'),
            884:(QtGui.QColor.fromRgb(59,10,101),'(884)車輪回転方向信号異常(FR)'),
            896:(QtGui.QColor.fromRgb(59,215,145),'(896)横加速度信号異常'),
            900:(QtGui.QColor.fromRgb(60,27,245),'(900)車両速度信号異常'),
            904:(QtGui.QColor.fromRgb(60,96,89),'(904)SW1溶着故障診断結果'),
            908:(QtGui.QColor.fromRgb(60,164,189),'(908)SW3溶着故障診断結果'),
            912:(QtGui.QColor.fromRgb(60,233,33),'(912)FEB(FCA)連続作動回数上限診断結果'),
            916:(QtGui.QColor.fromRgb(61,45,133),'(916)Gセンサ信号異常'),
            920:(QtGui.QColor.fromRgb(61,113,233),'(920)SW2溶着故障診断結果'),
            924:(QtGui.QColor.fromRgb(61,182,77),'(924)舵角速度信号異常'),
            928:(QtGui.QColor.fromRgb(61,250,177),'(928)車輪回転方向信号異常(EBA)'),
            932:(QtGui.QColor.fromRgb(62,63,22),'(932)車輪速パルス信号異常(EBA)'),
            936:(QtGui.QColor.fromRgb(62,131,122),'(936)車輪速センサ信号異常(EBA)'),
            940:(QtGui.QColor.fromRgb(62,199,222),'(940)車速信号異常(EBA)'),
            944:(QtGui.QColor.fromRgb(63,12,66),'(944)ブレーキ情報信号異常'),
            1088:(QtGui.QColor.fromRgb(72,170,85),'(1088)低電圧時ｷｬﾝｾﾙ診断結果'),
            1092:(QtGui.QColor.fromRgb(72,238,185),'(1092)R-Car低優先度監視'),
            1104:(QtGui.QColor.fromRgb(73,187,229),'(1104)CAN未受信異常(ITS4-FD SONAR:JT1)'),
            1108:(QtGui.QColor.fromRgb(74,0,73),'(1108)CAN未受信異常(ITS1-FD IVI:JT2)'),
            1112:(QtGui.QColor.fromRgb(74,68,173),'(1112)CAN未受信異常(ITS4-FD IVI:JT2)'),
            1120:(QtGui.QColor.fromRgb(74,205,117),'(1120)IDM CAN異常診断結果(Type A)'),
            1124:(QtGui.QColor.fromRgb(75,17,217),'(1124)Path1(&bis) Steering NG'),
            1128:(QtGui.QColor.fromRgb(75,86,61),'(1128)Path4 Steering NG'),
            1132:(QtGui.QColor.fromRgb(75,154,161),'(1132)AEB（VDC ECU）機能故障診断(Type A)'),
            1136:(QtGui.QColor.fromRgb(75,223,6),'(1136)ICC（VDC ECU）機能故障診断(Type A)'),
            1140:(QtGui.QColor.fromRgb(76,35,106),'(1140)ECD(VDC ECU) 電源電圧異常(Type A)'),
            1144:(QtGui.QColor.fromRgb(76,103,206),'(1144)VDCシステム故障診断結果(Type A)'),
            1148:(QtGui.QColor.fromRgb(76,172,50),'(1148)ABSシステム故障診断結果(Type A)'),
            1152:(QtGui.QColor.fromRgb(76,240,150),'(1152)TCSｼｽﾃﾑ故障診断結果(Type A)'),
            1156:(QtGui.QColor.fromRgb(77,52,250),'(1156)VDC内LDP機能異常診断結果(Type A)'),
            1160:(QtGui.QColor.fromRgb(77,121,94),'(1160)車速センサ不整合故障(キャンセル：異常判断時)'),
            1164:(QtGui.QColor.fromRgb(77,189,194),'(1164)車輪速ｾﾝｻ不整合(ｷｬﾝｾﾙ)'),
            1168:(QtGui.QColor.fromRgb(78,2,38),'(1168)ACC_ENABLE_OFFキャンセル'),
            1172:(QtGui.QColor.fromRgb(78,70,138),'(1172)AD2_BRK_ACTR_STATUSキャンセル'),
            1176:(QtGui.QColor.fromRgb(78,138,238),'(1176)ePKB SSA作動可能状態フラグ キャンセル'),
            1180:(QtGui.QColor.fromRgb(78,207,82),'(1180)ePKB ePKB非作動'),
            1182:(QtGui.QColor.fromRgb(78,241,132),'(1182)ePKB系統(ﾊﾟｰｷﾝｸﾞ break異常表示)(ｷｬﾝｾﾙ)'),
            1184:(QtGui.QColor.fromRgb(79,19,182),'(1184)ePKB SSAフェールフラグ キャンセル'),
            1188:(QtGui.QColor.fromRgb(79,88,27),'(1188) break液圧指令値異常出力'),
            1192:(QtGui.QColor.fromRgb(79,156,127),'(1192)ECM ASCDｷｬﾝｾﾙ'),
            1196:(QtGui.QColor.fromRgb(79,224,227),'(1196)ｽﾃｱﾘﾝｸﾞ SW 論理異常キャンセル（C1N）'),
            1200:(QtGui.QColor.fromRgb(80,37,71),'(1200)ｽﾃｱﾘﾝｸﾞ SW 論理異常キャンセル(C1A）'),
            1204:(QtGui.QColor.fromRgb(80,105,171),'(1204)GセンサーUnavailableValue'),
            1208:(QtGui.QColor.fromRgb(80,174,15),'(1208)ﾚｰﾀﾞｰ初期化判定'),
            1212:(QtGui.QColor.fromRgb(80,242,115),'(1212)カメラリセットキャンセル'),
            1216:(QtGui.QColor.fromRgb(81,54,215),'(1216)ミリ波レーダーカメラ fusion異常'),
            1220:(QtGui.QColor.fromRgb(81,123,59),'(1220)SR Alignment未調整'),
            1224:(QtGui.QColor.fromRgb(81,191,159),'(1224)SideRadar電圧低下'),
            1228:(QtGui.QColor.fromRgb(82,4,3),'(1228)初期化未了'),
            1232:(QtGui.QColor.fromRgb(82,72,103),'(1232)HD-MAPライセンス切れ'),
            1236:(QtGui.QColor.fromRgb(82,140,203),'(1236)HD-MAPエラーメッセージキャンセル'),
            1244:(QtGui.QColor.fromRgb(83,21,148),'(1244)EPSキャンセル'),
            1248:(QtGui.QColor.fromRgb(83,89,248),'(1248)AVM認識状態キャンセル'),
            1252:(QtGui.QColor.fromRgb(83,158,92),'(1252)ｸﾗｯﾁ不整合'),
            1256:(QtGui.QColor.fromRgb(83,226,192),'(1256)CDM判断によるPath使用不可通知(キャンセル)'),
            1260:(QtGui.QColor.fromRgb(84,39,36),'(1260)CDMからのADAS_sub(AVM)異常通知(キャンセル)'),
            1345:(QtGui.QColor.fromRgb(89,212,115),'(1345)HD MAPが無効'),
            1346:(QtGui.QColor.fromRgb(89,229,140),'(1346)高速道路上ではない'),
            1347:(QtGui.QColor.fromRgb(89,246,165),'(1347)AD2が無効なエリア'),
            1348:(QtGui.QColor.fromRgb(90,7,190),'(1348)HDMap情報がない'),
            1349:(QtGui.QColor.fromRgb(90,24,215),'(1349)中央分離帯がない'),
            1350:(QtGui.QColor.fromRgb(90,41,240),'(1350)トンネル内'),
            1351:(QtGui.QColor.fromRgb(90,59,9),'(1351)制限速度50km/h(or 40 mph)以下'),
            1352:(QtGui.QColor.fromRgb(90,76,34),'(1352)合流点が連続で存在する'),
            1353:(QtGui.QColor.fromRgb(90,93,59),'(1353)HDMap上のレーン幅が狭い'),
            1354:(QtGui.QColor.fromRgb(90,110,84),'(1354)信頼度フラグ区間（地図鮮度or道路形状orSWバージョン）'),
            1355:(QtGui.QColor.fromRgb(90,127,109),'(1355)Reserved'),
            1356:(QtGui.QColor.fromRgb(90,144,134),'(1356)急カーブ（R90以下）'),
            1357:(QtGui.QColor.fromRgb(90,161,159),'(1357)急カーブ（RCarの判定）'),
            1358:(QtGui.QColor.fromRgb(90,178,184),'(1358)カメラ苦手区間'),
            1359:(QtGui.QColor.fromRgb(90,195,209),'(1359)MAP情報で定義するカメラ苦手エリア'),
            1360:(QtGui.QColor.fromRgb(90,212,234),'(1360)本線が残り1.3km未満かつ分岐までの距離が本線よりも短い'),
            1361:(QtGui.QColor.fromRgb(90,230,3),'(1361)自己位置推定できていない'),
            1362:(QtGui.QColor.fromRgb(90,247,28),'(1362)合流地点まで50m以上の距離がない'),
            1363:(QtGui.QColor.fromRgb(91,8,53),'(1363)本線でない、またはランプ道'),
            1364:(QtGui.QColor.fromRgb(91,25,78),'(1364)分岐地点を通り過ぎてから30m以上の地点にいる'),
            1365:(QtGui.QColor.fromRgb(91,42,103),'(1365)出口、合流付近（TD要求：50m手前）'),
            1366:(QtGui.QColor.fromRgb(91,59,128),'(1366)料金所付近（TD要求：50m手前）'),
            1367:(QtGui.QColor.fromRgb(91,76,153),'(1367)Reserved'),
            1368:(QtGui.QColor.fromRgb(91,93,178),'(1368)Reserved'),
            1369:(QtGui.QColor.fromRgb(91,110,203),'(1369)Reserved'),
            1370:(QtGui.QColor.fromRgb(91,127,228),'(1370)出口、合流付近（Standby：150m手前）'),
            1371:(QtGui.QColor.fromRgb(91,144,253),'(1371)出口、合流付近（SteerReq：150m手前）'),
            1372:(QtGui.QColor.fromRgb(91,162,22),'(1372)料金所付近（Standby：150m手前）'),
            1373:(QtGui.QColor.fromRgb(91,179,47),'(1373)料金所付近（SteerReq：150m手前）'),
            1374:(QtGui.QColor.fromRgb(91,196,72),'(1374)Reserved'),
            1375:(QtGui.QColor.fromRgb(91,213,97),'(1375)Reserved'),
            1376:(QtGui.QColor.fromRgb(91,230,122),'(1376)出口、合流付近（HandsOnReq：800m手前）'),
            1377:(QtGui.QColor.fromRgb(91,247,147),'(1377)料金所付近（HandsOnReq：800m手前）'),
            1378:(QtGui.QColor.fromRgb(92,8,172),'(1378)Reserved'),
            1379:(QtGui.QColor.fromRgb(92,25,197),'(1379)FailSafeによるSteer要求発生'),
            1380:(QtGui.QColor.fromRgb(92,42,222),'(1380)工事エリア付近'),
            1381:(QtGui.QColor.fromRgb(92,59,247),'(1381)横制御入って、すぐAD2入れない状況のとき'),
            1536:(QtGui.QColor.fromRgb(102,150,29),'(1536)ABS作動ｷｬﾝｾﾙ(w/o ACC) 診断結果'),
            1537:(QtGui.QColor.fromRgb(102,167,54),'(1537)ABS作動ｷｬﾝｾﾙ'),
            1540:(QtGui.QColor.fromRgb(102,218,129),'(1540)VDC作動ｷｬﾝｾﾙ(w/o ACC) 診断結果'),
            1541:(QtGui.QColor.fromRgb(102,235,154),'(1541)VDC作動ｷｬﾝｾﾙ'),
            1542:(QtGui.QColor.fromRgb(102,252,179),'(1542)VDC作動ｷｬﾝｾﾙ'),
            1544:(QtGui.QColor.fromRgb(103,30,229),'(1544)TCS作動ｷｬﾝｾﾙ'),
            1545:(QtGui.QColor.fromRgb(103,47,254),'(1545)TCS作動ｷｬﾝｾﾙ'),
            1548:(QtGui.QColor.fromRgb(103,99,74),'(1548)ABSﾗﾝﾌﾟ点灯'),
            1552:(QtGui.QColor.fromRgb(103,167,174),'(1552)ECM ACCキャンセル'),
            1556:(QtGui.QColor.fromRgb(103,236,18),'(1556)ACC禁止信号ON(ECMACCINHﾌﾗｸﾞ診断)'),
            1560:(QtGui.QColor.fromRgb(104,48,118),'(1560)FCA本制動作動'),
            1564:(QtGui.QColor.fromRgb(104,116,218),'(1564)FCA予備制動作動'),
            1568:(QtGui.QColor.fromRgb(104,185,62),'(1568)車間連動DBA作動ｷｬﾝｾﾙ'),
            1573:(QtGui.QColor.fromRgb(105,14,187),'(1573)EAP作動キャンセル'),
            1576:(QtGui.QColor.fromRgb(105,66,6),'(1576)CBA作動ｷｬﾝｾﾙ'),
            1580:(QtGui.QColor.fromRgb(105,134,106),'(1580)FAP作動キャンセル'),
            1581:(QtGui.QColor.fromRgb(105,151,131),'(1581)IPA作動'),
            2048:(QtGui.QColor.fromRgb(136,200,39),'(2048)ﾐﾘ波ﾚｰﾀﾞ block診断結果'),
            2048:(QtGui.QColor.fromRgb(136,200,39),'(2048)ﾐﾘ波ﾚｰﾀﾞ block診断結果(ICC)'),
            2052:(QtGui.QColor.fromRgb(137,12,139),'(2052)ﾐﾘ波ﾚｰﾀﾞ電波干渉診断結果'),
            2056:(QtGui.QColor.fromRgb(137,80,239),'(2056)SCAM3　ﾌﾙ block(Full blockage)判定診断結果'),
            2060:(QtGui.QColor.fromRgb(137,149,83),'(2060)SCAM3　部分 block(Partial blockage)判定診断結果'),
            2064:(QtGui.QColor.fromRgb(137,217,184),'(2064)カメラYaw方向 misalignment判定診断結果'),
            2068:(QtGui.QColor.fromRgb(138,30,28),'(2068)カメラPitch方向 misalignment判定診断結果'),
            2072:(QtGui.QColor.fromRgb(138,98,128),'(2072)カメラﾌｫｰｶｽ misalignment判定診断結果'),
            2076:(QtGui.QColor.fromRgb(138,166,228),'(2076)カメラ自動補正Yaw方向閾値外判定診断結果'),
            2080:(QtGui.QColor.fromRgb(138,235,72),'(2080)カメラ自動補正Pitch方向閾値外判定診断結果'),
            2084:(QtGui.QColor.fromRgb(139,47,172),'(2084)カメラ太陽光判定診断結果'),
            2088:(QtGui.QColor.fromRgb(139,116,16),'(2088)カメラ悪天候判定(SCAM3)診断結果'),
            2092:(QtGui.QColor.fromRgb(139,184,116),'(2092)TJPｶﾒﾗ　不鮮明判定（ICC）'),
            2096:(QtGui.QColor.fromRgb(139,252,216),'(2096)TJPｶﾒﾗ　悪天候判定（ICC）'),
            2100:(QtGui.QColor.fromRgb(140,65,60),'(2100)TJPｶﾒﾗ　ｽﾌﾟﾗｯｼｭ判定（ICC）'),
            2104:(QtGui.QColor.fromRgb(140,133,160),'(2104)TJPｶﾒﾗ　太陽光縦線判定（ICC）'),
            2108:(QtGui.QColor.fromRgb(140,202,4),'(2108)TJPｶﾒﾗ　夜間霧判定（ICC）'),
            2112:(QtGui.QColor.fromRgb(141,14,104),'(2112)短時間太陽光判定'),
            2116:(QtGui.QColor.fromRgb(141,82,205),'(2116)雨判定'),
            2120:(QtGui.QColor.fromRgb(141,151,49),'(2120)カメラ不鮮明判定診断結果'),
            2124:(QtGui.QColor.fromRgb(141,219,149),'(2124)カメラスプラッシュ判定診断結果'),
            2128:(QtGui.QColor.fromRgb(142,31,249),'(2128)カメラ太陽光縦線判定診断結果'),
            2132:(QtGui.QColor.fromRgb(142,100,93),'(2132)カメラ夜間霧判定診断結果'),
            2136:(QtGui.QColor.fromRgb(142,168,193),'(2136)カメラ夜間雨判定診断結果'),
            2140:(QtGui.QColor.fromRgb(142,237,37),'(2140)カメラウィンドウ氷結判定診断結果'),
            2144:(QtGui.QColor.fromRgb(143,49,137),'(2144)カメラ夜間雨_M判定診断結果'),
            2148:(QtGui.QColor.fromRgb(143,117,237),'(2148)ｶﾒﾗﾒｯｾｰｼﾞ出力判定'),
            2152:(QtGui.QColor.fromRgb(143,186,81),'(2152)SideRadar電波干渉'),
            2156:(QtGui.QColor.fromRgb(143,254,181),'(2156)閉塞状態'),
            2160:(QtGui.QColor.fromRgb(144,67,25),'(2160)距離推定信頼度低下'),
            2164:(QtGui.QColor.fromRgb(144,135,125),'(2164)距離推定不可'),
            2168:(QtGui.QColor.fromRgb(144,203,226),'(2168)EEMキャンセル'),
            2172:(QtGui.QColor.fromRgb(145,16,70),'(2172)車線形状比較診断'),
            2176:(QtGui.QColor.fromRgb(145,84,170),'(2176)AVM性能低下キャンセル'),
            2180:(QtGui.QColor.fromRgb(145,153,14),'(2180)センサステータスキャンセル'),
            2184:(QtGui.QColor.fromRgb(145,221,114),'(2184)ASILD対応操舵補正作動'),
            2208:(QtGui.QColor.fromRgb(147,119,202),'(2208)MAP制御点が正常でない'),
            2209:(QtGui.QColor.fromRgb(147,136,227),'(2209)悪天候'),
            2210:(QtGui.QColor.fromRgb(147,153,252),'(2210)車線形状診断が成立（2sec継続）'),
            2211:(QtGui.QColor.fromRgb(147,171,21),'(2211)車線形状診断が成立'),
            2212:(QtGui.QColor.fromRgb(147,188,46),'(2212)DMS異常 （遮蔽、輝度飽和、複数人検知、汚れ）'),
            2213:(QtGui.QColor.fromRgb(147,205,71),'(2213)LKの制御でMAPを使用'),
            2214:(QtGui.QColor.fromRgb(147,222,96),'(2214)サーボGain値が0.95未満'),
            2215:(QtGui.QColor.fromRgb(147,239,121),'(2215)LKA->TJA遷移時に車線中央の±30cm以内のポジションを1秒以上継続して走行していない'),
            2216:(QtGui.QColor.fromRgb(148,0,146),'(2216)接近警報'),
            2217:(QtGui.QColor.fromRgb(148,17,171),'FailSafeによるHandsOn要求発生'),
            2218:(QtGui.QColor.fromRgb(148,34,196),'(2218)LDP作動した'),
            2560:(QtGui.QColor.fromRgb(170,250,49),'(2560)車輪速ｾﾝｻ電磁ﾉｲｽﾞ'),
            2564:(QtGui.QColor.fromRgb(171,62,149),'(2564)車輪ｽﾘｯﾌﾟｷｬﾝｾﾙ'),
            2565:(QtGui.QColor.fromRgb(171,79,174),'(2565)車輪ｽﾘｯﾌﾟｷｬﾝｾﾙ'),
            2568:(QtGui.QColor.fromRgb(171,130,249),'(2568)急坂路判定'),
            2572:(QtGui.QColor.fromRgb(171,199,93),'(2572)ｲﾝﾁﾝｸﾞﾛｽﾄｷｬﾝｾﾙ　(クルーズ中)'),
            2576:(QtGui.QColor.fromRgb(172,11,193),'(2576)ｲﾝﾁﾝｸﾞﾛｽﾄｷｬﾝｾﾙ'),
            2580:(QtGui.QColor.fromRgb(172,80,38),'(2580)車速低下'),
            2584:(QtGui.QColor.fromRgb(172,148,138),'(2584)ASCD車速異常'),
            2588:(QtGui.QColor.fromRgb(172,216,238),'(2588)停止制御ｷｬﾝｾﾙ ロスト（ACC)'),
            2592:(QtGui.QColor.fromRgb(173,29,82),'(2592)停止保持制御3分経過'),
            2596:(QtGui.QColor.fromRgb(173,97,182),'(2596)動的ePKBｷｬﾝｾﾙ'),
            2600:(QtGui.QColor.fromRgb(173,166,26),'(2600)ePKB系統(ePKB制動状態)'),
            2604:(QtGui.QColor.fromRgb(173,234,126),'(2604)System Ready OFF ｷｬﾝｾﾙ'),
            2608:(QtGui.QColor.fromRgb(174,46,226),'(2608)ｴﾝｽﾄ時ｷｬﾝｾﾙ'),
            3072:(QtGui.QColor.fromRgb(205,44,59),'(3072)降車判断（TJP)'),
            3073:(QtGui.QColor.fromRgb(205,61,84),'(3073)降車判断（ACC+LKA)'),
            3076:(QtGui.QColor.fromRgb(205,112,159),'(3076)運転席以外のドア開時アクセル発進操作'),
            3080:(QtGui.QColor.fromRgb(205,181,3),'(3080)実ｷﾞﾔ・ｼﾌﾄ位置ｷｬﾝｾﾙ'),
            3084:(QtGui.QColor.fromRgb(205,249,103),'(3084)PKB SW ONｷｬﾝｾﾙ'),
            3088:(QtGui.QColor.fromRgb(206,61,203),'(3088)操作SWのﾀﾞﾌﾞﾙ押し'),
            3092:(QtGui.QColor.fromRgb(206,130,47),'(3092)操作,解除SW同時押し'),
            3096:(QtGui.QColor.fromRgb(206,198,148),'(3096)HDCONｷｬﾝｾﾙ'),
            3100:(QtGui.QColor.fromRgb(207,10,248),'(3100)DCTDowngradeModeキャンセル'),
            3104:(QtGui.QColor.fromRgb(207,79,92),'(3104)TCS(VDC) OFF SW 操作ｷｬﾝｾﾙ(ACC以外)診断結果'),
            3105:(QtGui.QColor.fromRgb(207,96,117),'(3105)TCS(VDC) OFF SW 操作キャンセル(ACC)診断結果'),
            3108:(QtGui.QColor.fromRgb(207,147,192),'(3108)FEB MAIN SW OFF診断結果'),
            3112:(QtGui.QColor.fromRgb(207,216,36),'(3112)ATｼﾌﾄ位置がD以外ｷｬﾝｾﾙ'),
            3116:(QtGui.QColor.fromRgb(208,28,136),'(3116)ETSﾓｰﾄﾞｷｬﾝｾﾙ'),
            3120:(QtGui.QColor.fromRgb(208,96,236),'(3120)ｵﾌﾛｰﾄﾞSWｷｬﾝｾﾙ'),
            3124:(QtGui.QColor.fromRgb(208,165,80),'(3124)ｽﾉｰﾓｰﾄﾞSW ONｷｬﾝｾﾙ'),
            3128:(QtGui.QColor.fromRgb(208,233,180),'(3128)ﾄﾞﾗｲﾊﾞｸﾗｯﾁ操作ｷｬﾝｾﾙ'),
            3132:(QtGui.QColor.fromRgb(209,46,24),'(3132)ブレーキ/アクセル同時操作'),
            3136:(QtGui.QColor.fromRgb(209,114,124),'(3136)ドライバ操舵キャンセル'),
            3140:(QtGui.QColor.fromRgb(209,182,224),'(3140)ﾜｲﾊﾟｰｷｬﾝｾﾙ'),
            3144:(QtGui.QColor.fromRgb(209,251,68),'(3144)ワイパーLo作動キャンセル'),
            3148:(QtGui.QColor.fromRgb(210,63,169),'(3148)ドライバ離席判断'),
            3584:(QtGui.QColor.fromRgb(239,94,69),'(3584)ACC MAIN SW OFFキャンセル'),
            3588:(QtGui.QColor.fromRgb(239,162,169),'(3588)キャンセルSW ONキャンセル'),
            3592:(QtGui.QColor.fromRgb(239,231,13),'(3592)ﾄﾞﾗｲﾊﾞ break操作（TJP)'),
            3648:(QtGui.QColor.fromRgb(243,164,134),'(3648)Meter車速が制限速度130km/h(or 85mph)超オーバー'),
            3649:(QtGui.QColor.fromRgb(243,181,159),'(3649)ドライバーが前を向いていない'),
            3650:(QtGui.QColor.fromRgb(243,198,184),'(3650)HandsOnしていない'),
            3651:(QtGui.QColor.fromRgb(243,215,209),'(3651)アクセルオーバライドしている'),
            3652:(QtGui.QColor.fromRgb(243,232,234),'(3652)ターンランプ出している'),
            3653:(QtGui.QColor.fromRgb(243,250,3),'(3653)ドライバトリガLCをしていない'),
            3712:(QtGui.QColor.fromRgb(247,234,199),'(3712)LC提案を通知中'),
            3713:(QtGui.QColor.fromRgb(247,251,224),'(3713)Reserved'),
            3714:(QtGui.QColor.fromRgb(248,12,250),'(3714)LC制御中')}
    
    else:
        Hands_off_prohibit_symbolDic = {
            66:(QtGui.QColor.fromRgb(4,104,115),'(66)battery voltage high'),
            68:(QtGui.QColor.fromRgb(4,138,165),'(68)battery voltage low'),
            72:(QtGui.QColor.fromRgb(4,207,9),'(72)IGN voltage defect'),
            74:(QtGui.QColor.fromRgb(4,241,59),'(74)IGN fail'),
            76:(QtGui.QColor.fromRgb(5,19,109),'(76)Inner power circuit defect'),
            80:(QtGui.QColor.fromRgb(5,87,209),'(80)RAM defect'),
            84:(QtGui.QColor.fromRgb(5,156,53),'(84)Flash ROM defect'),
            88:(QtGui.QColor.fromRgb(5,224,153),'(88)ECM Error'),
            92:(QtGui.QColor.fromRgb(6,36,253),'(92)SPIDER defect'),
            96:(QtGui.QColor.fromRgb(6,105,97),'(96)CAN controller defect'),
            100:(QtGui.QColor.fromRgb(6,173,197),'(100)Ethernet defect'),
            104:(QtGui.QColor.fromRgb(6,242,42),'(104)relay output defect'),
            105:(QtGui.QColor.fromRgb(7,3,67),'(105)SPI Com CRC defect'),
            106:(QtGui.QColor.fromRgb(7,20,92),'(106)SPI Com Clock defect'),
            107:(QtGui.QColor.fromRgb(7,37,117),'(107)SPI Com receive defect'),
            108:(QtGui.QColor.fromRgb(7,54,142),'(108)ITS power circuit defect'),
            112:(QtGui.QColor.fromRgb(7,122,242),'(112)SPI defect'),
            116:(QtGui.QColor.fromRgb(7,191,86),'(116)LIN defect'),
            120:(QtGui.QColor.fromRgb(8,3,186),'(120)temperature sensor defect'),
            124:(QtGui.QColor.fromRgb(8,72,30),'(124)CAN Com cut off defect'),
            128:(QtGui.QColor.fromRgb(8,140,130),'(128)LED circuit defect'),
            132:(QtGui.QColor.fromRgb(8,208,230),'(132)MAIN_CPU inner voltage defect'),
            136:(QtGui.QColor.fromRgb(9,21,74),'(136)SUB_CPU inner voltage defect'),
            140:(QtGui.QColor.fromRgb(9,89,174),'(140)CPU Com(GPIO) defect'),
            144:(QtGui.QColor.fromRgb(9,158,18),'(144)Shutdown normal complete judgement'),
            148:(QtGui.QColor.fromRgb(9,226,118),'(148)IPD defect'),
            152:(QtGui.QColor.fromRgb(10,38,218),'(152)M3N outter RAM defect'),
            156:(QtGui.QColor.fromRgb(10,107,63),'(156)M3N outter ROM defect'),
            160:(QtGui.QColor.fromRgb(10,175,163),'(160)AutoACC defect'),
            164:(QtGui.QColor.fromRgb(10,244,7),'(164)EEPROM defect'),
            184:(QtGui.QColor.fromRgb(12,73,251),'(184)SPI head version defect'),
            188:(QtGui.QColor.fromRgb(12,142,95),'(188)variant code defect'),
            192:(QtGui.QColor.fromRgb(12,210,195),'(192)bus off(ITS1-FD JT2)'),
            193:(QtGui.QColor.fromRgb(12,227,220),'(193)bus off(ITS2-FD JT2)'),
            194:(QtGui.QColor.fromRgb(12,244,245),'(194)bus off(ITS3-FD JT2)'),
            195:(QtGui.QColor.fromRgb(13,6,14),'(195)bus off(ITS4-FD JT2)'),
            196:(QtGui.QColor.fromRgb(13,23,39),'(196)bus off(ITS5-FD JT2)'),
            197:(QtGui.QColor.fromRgb(13,40,64),'(197)bus off(CH2-CAN JT2)'),
            200:(QtGui.QColor.fromRgb(13,91,139),'(200)CAN receive failure(ITS4-FD IDM:JT2)(MAC)'),
            200:(QtGui.QColor.fromRgb(13,91,139),'(200)CAN receive failure(ITS4-FD EPS:JT2)(MAC)'),
            201:(QtGui.QColor.fromRgb(13,108,164),'(201)CAN receive failure(ITS1-FD IDM:JT2)(MAC)'),
            201:(QtGui.QColor.fromRgb(13,108,164),'(201)CAN receive failure(ITS1-FD ePKB:JT2)(MAC)'),
            201:(QtGui.QColor.fromRgb(13,108,164),'(201)CAN receive failure(ITS1-FD EPS:JT2)(MAC)'),
            202:(QtGui.QColor.fromRgb(13,125,189),'(202)CAN receive failure(ITS1-FD METER:JT2)(MAC)'),
            202:(QtGui.QColor.fromRgb(13,125,189),'(202)CAN receive failure(ITS1-FD BCM:JT2)(MAC)'),
            202:(QtGui.QColor.fromRgb(13,125,189),'(202)CAN receive failure(ITS4-FD USM:JT2)(MAC)'),
            203:(QtGui.QColor.fromRgb(13,142,214),'(203)CAN receive failure(ITS4-FD METER:JT2)(MAC)'),
            203:(QtGui.QColor.fromRgb(13,142,214),'(203)CAN receive failure(ITS4-FD BCM:JT2)(MAC)'),
            204:(QtGui.QColor.fromRgb(13,159,239),'(204)CAN receive failure(ITS1-FD HEVC:JT2)(MAC)'),
            205:(QtGui.QColor.fromRgb(13,177,8),'(205)CAN receive failure(ITS4-FD HEVC:JT2)(MAC)'),
            206:(QtGui.QColor.fromRgb(13,194,33),'(206)CAN receive failure(ITS1-FD AVM:JT2)(MAC)'),
            207:(QtGui.QColor.fromRgb(13,211,59),'(207)CAN receive failure(ITS4-FD AVM:JT2)(MAC)'),
            208:(QtGui.QColor.fromRgb(13,228,84),'(208)CAN receive failure(ITS4-FD SONAR:JT2)(MAC)'),
            216:(QtGui.QColor.fromRgb(14,109,28),'(216)CAN receive failure(ITS1-FD IDM:JT1)'),
            216:(QtGui.QColor.fromRgb(14,109,28),'(216)CAN receive failure(ITS1-FD IDM:JT2)'),
            218:(QtGui.QColor.fromRgb(14,143,78),'(218)Message counter defect(ITS1-FD CDM)'),
            219:(QtGui.QColor.fromRgb(14,160,103),'(219)Checksum defect(ITS1-FD CDM)'),
            220:(QtGui.QColor.fromRgb(14,177,128),'(220)CAN receive failure(ITS4-FD IDM:JT2)'),
            221:(QtGui.QColor.fromRgb(14,194,153),'(221)CAN receive failure(ITS4-FD IDM:JT1)'),
            222:(QtGui.QColor.fromRgb(14,211,178),'(222)Message counter defect(ITS4-FD CDM)'),
            223:(QtGui.QColor.fromRgb(14,228,203),'(223)Checksum defect(ITS4-FD CDM)'),
            224:(QtGui.QColor.fromRgb(14,245,228),'(224)CAN receive failure(ITS1-FD VDC:JT2)'),
            224:(QtGui.QColor.fromRgb(14,245,228),'(224)CAN receive failure(ITS1-FD VDC:JT2)(MAC)'),
            225:(QtGui.QColor.fromRgb(15,6,253),'(225)CAN receive failure(ITS1-FD VDC:JT1)'),
            226:(QtGui.QColor.fromRgb(15,24,22),'(226)Message counter defect(ITS1-FD VDC)'),
            227:(QtGui.QColor.fromRgb(15,41,47),'(227)Checksum defect(ITS1-FD VDC)'),
            228:(QtGui.QColor.fromRgb(15,58,72),'(228)CAN receive failure(ITS4-FD VDC:JT2)'),
            228:(QtGui.QColor.fromRgb(15,58,72),'(228)CAN receive failure(ITS4-FD VDC:JT2)(MAC)'),
            228:(QtGui.QColor.fromRgb(15,58,72),'(228)CAN receive failure(ITS4-FD VDC via CH2:JT2)'),
            229:(QtGui.QColor.fromRgb(15,75,97),'(229)CAN receive failure(ITS4-FD VDC:JT1)'),
            229:(QtGui.QColor.fromRgb(15,75,97),'(229)CAN receive failure(ITS4-FD VDC via CH2:JT1)'),
            230:(QtGui.QColor.fromRgb(15,92,122),'(230)Message counter defect(ITS4-FD VDC)'),
            231:(QtGui.QColor.fromRgb(15,109,147),'(231)Checksum defect(ITS4-FD VDC)'),
            232:(QtGui.QColor.fromRgb(15,126,172),'(232)CAN receive failure(CH2-CAN VDC:JT2)'),
            234:(QtGui.QColor.fromRgb(15,160,222),'(234)Message counter defect(CH2-CAN VDC)'),
            235:(QtGui.QColor.fromRgb(15,177,247),'(235)Checksum defect(CH2-CAN VDC)'),
            236:(QtGui.QColor.fromRgb(15,195,16),'(236)CAN receive failure(ITS1-FD ePKB:JT2)'),
            237:(QtGui.QColor.fromRgb(15,212,41),'(237)CAN receive failure(ITS1-FD ePKB:JT1)'),
            238:(QtGui.QColor.fromRgb(15,229,66),'(238)Message counter defect(ITS4-FD ePKB)'),
            239:(QtGui.QColor.fromRgb(15,246,91),'(239)Checksum defect(ITS4-FD ePKB)'),
            242:(QtGui.QColor.fromRgb(16,41,166),'(242)Message counter defect(CH2-CAN ePKB)'),
            243:(QtGui.QColor.fromRgb(16,58,191),'(243)Checksum defect(CH2-CAN ePKB)'),
            244:(QtGui.QColor.fromRgb(16,75,216),'(244)CAN receive failure(ITS1-FD EBA:JT2)'),
            248:(QtGui.QColor.fromRgb(16,144,60),'(248)CAN receive failure(CH2-CAN EBA:JT2)'),
            250:(QtGui.QColor.fromRgb(16,178,110),'(250)Clock fail(CH2-CAN EBA)'),
            251:(QtGui.QColor.fromRgb(16,195,135),'(251)CRC fail(CH2-CAN EBA)'),
            252:(QtGui.QColor.fromRgb(16,212,160),'(252)CAN receive failure(ITS1-FD EPS:JT2)'),
            253:(QtGui.QColor.fromRgb(16,229,185),'(253)CAN receive failure(ITS1-FD EPS:JT1)'),
            254:(QtGui.QColor.fromRgb(16,246,210),'(254)Message counter defect(ITS1-FD EPS)'),
            255:(QtGui.QColor.fromRgb(17,7,235),'(255)Checksum defect(ITS1-FD EPS)'),
            256:(QtGui.QColor.fromRgb(17,25,4),'(256)CAN receive failure(ITS4-FD EPS:JT2)'),
            257:(QtGui.QColor.fromRgb(17,42,29),'(257)CAN receive failure(ITS4-FD EPS:JT1)'),
            258:(QtGui.QColor.fromRgb(17,59,55),'(258)Message counter defect(ITS4-FD EPS)'),
            259:(QtGui.QColor.fromRgb(17,76,80),'(259)Checksum defect(ITS4-FD EPS)'),
            260:(QtGui.QColor.fromRgb(17,93,105),'(260)CAN receive failure(CH2-CAN EPSsub:JT2)'),
            262:(QtGui.QColor.fromRgb(17,127,155),'(262)Clock fail(CH2-CAN EPSsub)'),
            263:(QtGui.QColor.fromRgb(17,144,180),'(263)CRC fail(CH2-CAN EPSsub)'),
            264:(QtGui.QColor.fromRgb(17,161,205),'(264)CAN receive failure(ITS1-FD BCM:JT2)'),
            265:(QtGui.QColor.fromRgb(17,178,230),'(265)CAN receive failure(ITS1-FD BCM:JT1)'),
            266:(QtGui.QColor.fromRgb(17,195,255),'(266)Message counter defect(ITS1-FD BCM)'),
            267:(QtGui.QColor.fromRgb(17,213,24),'(267)Checksum defect(ITS1-FD BCM)'),
            268:(QtGui.QColor.fromRgb(17,230,49),'(268)CAN receive failure(ITS4-FD BCM:JT2)'),
            269:(QtGui.QColor.fromRgb(17,247,74),'(269)CAN receive failure(ITS4-FD BCM:JT1)'),
            270:(QtGui.QColor.fromRgb(18,8,99),'(270)Message counter defect(ITS4-FD BCM)'),
            271:(QtGui.QColor.fromRgb(18,25,124),'(271)Checksum defect(ITS4-FD BCM)'),
            272:(QtGui.QColor.fromRgb(18,42,149),'(272)CAN receive failure(ITS1-FD METER:JT2)'),
            276:(QtGui.QColor.fromRgb(18,110,249),'(276)CAN receive failure(ITS4-FD METER:JT2)'),
            277:(QtGui.QColor.fromRgb(18,128,18),'(277)CAN receive failure(ITS4-FD METER:JT1)'),
            278:(QtGui.QColor.fromRgb(18,145,43),'(278)Message counter defect(ITS4-FD METER)'),
            279:(QtGui.QColor.fromRgb(18,162,68),'(279)Checksum defect(ITS4-FD METER)'),
            280:(QtGui.QColor.fromRgb(18,179,93),'(280)CAN receive failure(ITS4-FD STR:JT2)'),
            280:(QtGui.QColor.fromRgb(18,179,93),'(280)CAN receive failure(ITS4-FD STR:JT2)(MAC)'),
            281:(QtGui.QColor.fromRgb(18,196,118),'(281)CAN receive failure(ITS4-FD STR:JT1)'),
            282:(QtGui.QColor.fromRgb(18,213,143),'(282)Message counter defect(ITS4-FD STR)'),
            283:(QtGui.QColor.fromRgb(18,230,168),'(283)Checksum defect(ITS4-FD STR)'),
            284:(QtGui.QColor.fromRgb(18,247,193),'(284)CAN receive failure(ITS1-FD HEVC:JT2)'),
            285:(QtGui.QColor.fromRgb(19,8,218),'(285)CAN receive failure(ITS1-FD HEVC:JT1)'),
            286:(QtGui.QColor.fromRgb(19,25,243),'(286)Message counter defect(ITS1-FD HEVC)'),
            287:(QtGui.QColor.fromRgb(19,43,12),'(287)Checksum defect(ITS1-FD HEVC)'),
            288:(QtGui.QColor.fromRgb(19,60,37),'(288)CAN receive failure(ITS4-FD HEVC:JT2)'),
            289:(QtGui.QColor.fromRgb(19,77,62),'(289)CAN receive failure(ITS4-FD HEVC:JT1)'),
            290:(QtGui.QColor.fromRgb(19,94,87),'(290)Message counter defect(ITS4-FD HEVC)'),
            291:(QtGui.QColor.fromRgb(19,111,112),'(291)Checksum defect(ITS4-FD HEVC)'),
            292:(QtGui.QColor.fromRgb(19,128,137),'(292)Message counter defect(ITS4-FD HCM)'),
            293:(QtGui.QColor.fromRgb(19,145,162),'(293)Checksum defect(ITS4-FD HCM)'),
            294:(QtGui.QColor.fromRgb(19,162,187),'(294)Message counter defect(ITS4-FD ATCU)'),
            295:(QtGui.QColor.fromRgb(19,179,212),'(295)Checksum defect(ITS4-FD ATCU)'),
            296:(QtGui.QColor.fromRgb(19,196,237),'(296)Ethernet link down(Radar:JT2)'),
            297:(QtGui.QColor.fromRgb(19,214,6),'(297)Ethernet link down_2(Radar:JT2)'),
            298:(QtGui.QColor.fromRgb(19,231,31),'(298)Ethernet receive failure(Radar:JT2)'),
            299:(QtGui.QColor.fromRgb(19,248,56),'(299)Ethernet receive failure_2(Radar:JT2)'),
            300:(QtGui.QColor.fromRgb(20,9,81),'(300)Ethernet receive failure(Radar:JT1)'),
            301:(QtGui.QColor.fromRgb(20,26,106),'(301)Ethernet receive failure_2(Radar:JT1)'),
            302:(QtGui.QColor.fromRgb(20,43,131),'(302)Ethernet Clock fail(Radar)'),
            303:(QtGui.QColor.fromRgb(20,60,156),'(303)Ethernet Clock fail_2(Radar)'),
            304:(QtGui.QColor.fromRgb(20,77,181),'(304)Ethernet CRC fail(Radar)'),
            305:(QtGui.QColor.fromRgb(20,94,206),'(305)Ethernet CRC fail_2(Radar)'),
            306:(QtGui.QColor.fromRgb(20,111,231),'(306)CAN receive failure(ITS2-FD CAM:JT2)'),
            307:(QtGui.QColor.fromRgb(20,129,0),'(307)CAN receive failure(ITS2-FD CAM:JT1)'),
            308:(QtGui.QColor.fromRgb(20,146,25),'(308)Clock fail(ITS2-FD Camera)'),
            309:(QtGui.QColor.fromRgb(20,163,50),'(309)CRC fail(ITS2-FD FrCamera)'),
            310:(QtGui.QColor.fromRgb(20,180,76),'(310)Ethernet link down(FrCamera:JT2)'),
            311:(QtGui.QColor.fromRgb(20,197,101),'(311)Ethernet link down_2(FrCamera:JT2)'),
            312:(QtGui.QColor.fromRgb(20,214,126),'(312)Ethernet receive failure(FrCamera2:JT2)'),
            313:(QtGui.QColor.fromRgb(20,231,151),'(313)Ethernet receive failure_2(FrCamera2:JT2)'),
            314:(QtGui.QColor.fromRgb(20,248,176),'(314)Ethernet receive failure(FrCamera2:JT1)'),
            315:(QtGui.QColor.fromRgb(21,9,201),'(315)Ethernet receive failure_2(FrCamera2:JT1)'),
            316:(QtGui.QColor.fromRgb(21,26,226),'(316)Ethernet Clock fail(FrCamera2)'),
            317:(QtGui.QColor.fromRgb(21,43,251),'(317)Ethernet Clock fail_2(FrCamera2)'),
            318:(QtGui.QColor.fromRgb(21,61,20),'(318)Ethernet CRC fail(FrCamera2)'),
            319:(QtGui.QColor.fromRgb(21,78,45),'(319)Ethernet CRC fail_2(FrCamera2)'),
            320:(QtGui.QColor.fromRgb(21,95,70),'(320)CAN receive failure(ITS1-FD AVM:JT2)'),
            321:(QtGui.QColor.fromRgb(21,112,95),'(321)CAN receive failure(ITS1-FD AVM:JT1)'),
            322:(QtGui.QColor.fromRgb(21,129,120),'(322)Message counter defect(ITS1-FD AVM)'),
            323:(QtGui.QColor.fromRgb(21,146,145),'(323)Checksum defect(ITS1-FD AVM)'),
            324:(QtGui.QColor.fromRgb(21,163,170),'(324)CAN receive failure(ITS3-FD AVM:JT2)'),
            326:(QtGui.QColor.fromRgb(21,197,220),'(326)Message counter defect(ITS3-FD AVM)'),
            327:(QtGui.QColor.fromRgb(21,214,245),'(327)Checksum defect(ITS3-FD AVM)'),
            328:(QtGui.QColor.fromRgb(21,232,14),'(328)CAN receive failure(ITS4-FD AVM:JT2)'),
            329:(QtGui.QColor.fromRgb(21,249,39),'(329)CAN receive failure(ITS4-FD AVM:JT1)'),
            330:(QtGui.QColor.fromRgb(22,10,64),'(330)Message counter defect(ITS4-FD AVM)'),
            331:(QtGui.QColor.fromRgb(22,27,89),'(331)Checksum defect(ITS4-FD AVM)'),
            332:(QtGui.QColor.fromRgb(22,44,114),'(332)Ethernet link down(AVM:JT2)'),
            333:(QtGui.QColor.fromRgb(22,61,139),'(333)Ethernet link down_2(AVM:JT2)'),
            334:(QtGui.QColor.fromRgb(22,78,164),'(334)Ethernet receive failure(AVM:JT2)'),
            335:(QtGui.QColor.fromRgb(22,95,189),'(335)Ethernet receive failure_2(AVM:JT2)'),
            336:(QtGui.QColor.fromRgb(22,112,214),'(336)Ethernet receive failure(AVM:JT1)'),
            337:(QtGui.QColor.fromRgb(22,129,239),'(337)Ethernet receive failure_2(AVM:JT1)'),
            338:(QtGui.QColor.fromRgb(22,147,8),'(338)Ethernet Clock fail(AVM)'),
            339:(QtGui.QColor.fromRgb(22,164,33),'(339)Ethernet Clock fail_2(AVM)'),
            340:(QtGui.QColor.fromRgb(22,181,58),'(340)Ethernet CRC fail(AVM)'),
            341:(QtGui.QColor.fromRgb(22,198,83),'(341)Ethernet CRC fail_2(AVM)'),
            342:(QtGui.QColor.fromRgb(22,215,108),'(342)Ethernet link down_2(HDMap:JT2)'),
            343:(QtGui.QColor.fromRgb(22,232,133),'(343)Ethernet receive failure_2(HDMap:JT2)'),
            344:(QtGui.QColor.fromRgb(22,249,158),'(344)Ethernet receive failure_2(HDMap:JT1)'),
            345:(QtGui.QColor.fromRgb(23,10,183),'(345)CAN receive failure(ITS3-FD SOW-RL:JT2)'),
            346:(QtGui.QColor.fromRgb(23,27,208),'(346)CAN receive failure(ITS3-FD SOW-RL:JT1)'),
            347:(QtGui.QColor.fromRgb(23,44,233),'(347)Message counter defect(ITS3-FD SR:RL)'),
            348:(QtGui.QColor.fromRgb(23,62,2),'(348)Checksum defect(ITS3-FD SR:RL)'),
            349:(QtGui.QColor.fromRgb(23,79,27),'(349)CAN receive failure(ITS3-FD SOW-RR:JT2)'),
            350:(QtGui.QColor.fromRgb(23,96,52),'(350)CAN receive failure(ITS3-FD SOW-RR:JT1)'),
            351:(QtGui.QColor.fromRgb(23,113,77),'(351)Message counter defect(ITS3-FD SR:RR)'),
            352:(QtGui.QColor.fromRgb(23,130,102),'(352)Checksum defect(ITS3-FD SR:RR)'),
            353:(QtGui.QColor.fromRgb(23,147,127),'(353)CAN receive failure(ITS5-FD SRad_FL:JT2)'),
            354:(QtGui.QColor.fromRgb(23,164,152),'(354)CAN receive failure(ITS5-FD SRad_FL:JT1)'),
            355:(QtGui.QColor.fromRgb(23,181,177),'(355)Message counter defect(ITS5-FD SR:FL)'),
            356:(QtGui.QColor.fromRgb(23,198,202),'(356)Checksum defect(ITS5-FD SR:FL)'),
            357:(QtGui.QColor.fromRgb(23,215,227),'(357)CAN receive failure(ITS5-FD SRad_FR:JT2)'),
            358:(QtGui.QColor.fromRgb(23,232,252),'(358)CAN receive failure(ITS5-FD SRad_FR:JT1)'),
            359:(QtGui.QColor.fromRgb(23,250,21),'(359)Message counter defect(ITS5-FD SR:FR)'),
            360:(QtGui.QColor.fromRgb(24,11,46),'(360)Checksum defect(ITS5-FD SR:FR)'),
            361:(QtGui.QColor.fromRgb(24,28,71),'(361)CAN receive failure(ITS4-FD SONAR:JT2)'),
            362:(QtGui.QColor.fromRgb(24,45,97),'(362)Message counter defect(ITS4-FD SONAR)'),
            363:(QtGui.QColor.fromRgb(24,62,122),'(363)Checksum defect(ITS4-FD SONAR)'),
            364:(QtGui.QColor.fromRgb(24,79,147),'(364)CAN receive failure(CH2-CAN HUD:JT2)'),
            366:(QtGui.QColor.fromRgb(24,113,197),'(366)Clock fail(CH2-CAN HUD)'),
            367:(QtGui.QColor.fromRgb(24,130,222),'(367)CRC fail(CH2-CAN HUD)'),
            368:(QtGui.QColor.fromRgb(24,147,247),'(368)CAN receive failure(ITS2-FD DMC:JT2)'),
            370:(QtGui.QColor.fromRgb(24,182,41),'(370)Clock fail(ITS2-FD DMC)'),
            371:(QtGui.QColor.fromRgb(24,199,66),'(371)CRC fail(ITS2-FD DMC)'),
            372:(QtGui.QColor.fromRgb(24,216,91),'(372)CAN receive failure(ITS4-FD USM:JT2)'),
            373:(QtGui.QColor.fromRgb(24,233,116),'(373)CAN receive failure(ITS4-FD USM:JT1)'),
            374:(QtGui.QColor.fromRgb(24,250,141),'(374)Message counter defect(ITS4-FD USM)'),
            375:(QtGui.QColor.fromRgb(25,11,166),'(375)Checksum defect(ITS4-FD USM)'),
            400:(QtGui.QColor.fromRgb(26,183,23),'(400)LIN bus off'),
            404:(QtGui.QColor.fromRgb(26,251,123),'(404)LIN receive failure(HOD:JT2)'),
            406:(QtGui.QColor.fromRgb(27,29,173),'(406)LIN Clock fail(HOD)'),
            407:(QtGui.QColor.fromRgb(27,46,198),'(407)LIN CRC fail(HOD)'),
            416:(QtGui.QColor.fromRgb(27,200,168),'(416)Cannot use Path notify by CDM'),
            420:(QtGui.QColor.fromRgb(28,13,12),'(420)ICC defect(VDC)'),
            424:(QtGui.QColor.fromRgb(28,81,112),'(424)AEB defect(VDC)'),
            428:(QtGui.QColor.fromRgb(28,149,212),'(428)Steering defect(EPSmain)'),
            432:(QtGui.QColor.fromRgb(28,218,56),'(432)ICC defect(EBA)'),
            436:(QtGui.QColor.fromRgb(29,30,156),'(436)AEB defect(EBA)'),
            440:(QtGui.QColor.fromRgb(29,99,0),'(440)Steering defect(EPSsub)'),
            444:(QtGui.QColor.fromRgb(29,167,100),'(444)ADAS_sub(AVM) defect notify by CDM'),
            448:(QtGui.QColor.fromRgb(29,235,200),'(448)Path1 ICC NG'),
            452:(QtGui.QColor.fromRgb(30,48,44),'(452)Path1 AEB NG'),
            456:(QtGui.QColor.fromRgb(30,116,144),'(456)AEB(VDC ECU) function failure defect(Type C)'),
            460:(QtGui.QColor.fromRgb(30,184,244),'(460)ICC(VDC ECU) function failure defect(Type C)'),
            464:(QtGui.QColor.fromRgb(30,253,88),'(464)ECD(VDC ECU) power voltage defect(Type C)'),
            468:(QtGui.QColor.fromRgb(31,65,189),'(468)EPS fail'),
            472:(QtGui.QColor.fromRgb(31,134,33),'(472)IDM CAN defect(Type C)'),
            476:(QtGui.QColor.fromRgb(31,202,133),'(476)IDM defect'),
            480:(QtGui.QColor.fromRgb(32,14,233),'(480)IDM torque command value defect'),
            484:(QtGui.QColor.fromRgb(32,83,77),'(484)ACC_ALIVE_OFF fail'),
            488:(QtGui.QColor.fromRgb(32,151,177),'(488)ACC_ALIVE_OFF fail(IDM)'),
            492:(QtGui.QColor.fromRgb(32,220,21),'(492)VDC system failure defect(Type C)'),
            496:(QtGui.QColor.fromRgb(33,32,121),'(496)ABS system failure defect(Type C)'),
            500:(QtGui.QColor.fromRgb(33,100,221),'(500)TCS system failure defect(Type C)'),
            504:(QtGui.QColor.fromRgb(33,169,65),'(504)inner VDC LDP function defect(Type C)'),
            508:(QtGui.QColor.fromRgb(33,237,165),'(508)VDC ECU defect'),
            512:(QtGui.QColor.fromRgb(34,50,9),'(512)Front wheel pulse sensor failure defect(Right)'),
            513:(QtGui.QColor.fromRgb(34,67,34),'(513)Front wheel pulse sensor failure defect(Left)'),
            514:(QtGui.QColor.fromRgb(34,84,59),'(514)Rear wheel pulse sensor failure defect(Right)'),
            515:(QtGui.QColor.fromRgb(34,101,84),'(515)Rear wheel pulse sensor failure defect(Left)'),
            516:(QtGui.QColor.fromRgb(34,118,110),'(516)vehicle speed sensor failure defect'),
            520:(QtGui.QColor.fromRgb(34,186,210),'(520)wheel pulse speed sensor UnavailableValue'),
            524:(QtGui.QColor.fromRgb(34,255,54),'(524)wheel pulse speed signal defect(Left)'),
            525:(QtGui.QColor.fromRgb(35,16,79),'(525)wheel pulse speed signal defect(Right)'),
            528:(QtGui.QColor.fromRgb(35,67,154),'(528)break SW failure defect'),
            532:(QtGui.QColor.fromRgb(35,135,254),'(532)stop lamp relay OFF fixed defect'),
            536:(QtGui.QColor.fromRgb(35,204,98),'(536)stop lamp relay defect(lamp control by CDM)'),
            540:(QtGui.QColor.fromRgb(36,16,198),'(540)stop lamp relay ON fixed defect'),
            544:(QtGui.QColor.fromRgb(36,85,42),'(544)ePKB parking break defect display fail'),
            548:(QtGui.QColor.fromRgb(36,153,142),'(548)ePKB SSA fail flag fail'),
            552:(QtGui.QColor.fromRgb(36,221,242),'(552)accel pedal flag detect fail'),
            556:(QtGui.QColor.fromRgb(37,34,86),'(556)ETC fail flag detect fail'),
            560:(QtGui.QColor.fromRgb(37,102,186),'(560)ECMCANFAIL flag defect'),
            564:(QtGui.QColor.fromRgb(37,171,30),'(564)ACC command value defect detect fail'),
            568:(QtGui.QColor.fromRgb(37,239,131),'(568)HCM system defect'),
            572:(QtGui.QColor.fromRgb(38,51,231),'(572)ECMASCD fail flag detect'),
            574:(QtGui.QColor.fromRgb(38,86,25),'(574)lane info miss(Eth or CAN)'),
            575:(QtGui.QColor.fromRgb(38,103,50),'(575)lane info receive failure'),
            576:(QtGui.QColor.fromRgb(38,120,75),'(576)ECMACCINH flag defect'),
            580:(QtGui.QColor.fromRgb(38,188,175),'(580)gear position defect(AT)'),
            584:(QtGui.QColor.fromRgb(39,1,19),'(584)gear position defect(CVT)'),
            588:(QtGui.QColor.fromRgb(39,69,119),'(588)CVT system defect'),
            592:(QtGui.QColor.fromRgb(39,137,219),'(592)stearing sensor defect'),
            596:(QtGui.QColor.fromRgb(39,206,63),'(596)stearing SW fixed defect(C1N)'),
            600:(QtGui.QColor.fromRgb(40,18,163),'(600)stearing SW logical defect(C1N)'),
            604:(QtGui.QColor.fromRgb(40,87,7),'(604)ICC main SW fixed defect(C1N)'),
            608:(QtGui.QColor.fromRgb(40,155,107),'(608)stearing SW fixed defect(C1A)'),
            612:(QtGui.QColor.fromRgb(40,223,207),'(612)ICC main SW fixed defect(C1A)'),
            616:(QtGui.QColor.fromRgb(41,36,51),'(616)stearing SW logical defect(C1A)'),
            620:(QtGui.QColor.fromRgb(41,104,152),'(620)METER failure'),
            624:(QtGui.QColor.fromRgb(41,172,252),'(624)ADAS_METER Com failure'),
            628:(QtGui.QColor.fromRgb(41,241,96),'(628)millimeter wave radar failure'),
            632:(QtGui.QColor.fromRgb(42,53,196),'(632)millimeter wave radar CAN Com defect'),
            636:(QtGui.QColor.fromRgb(42,122,40),'(636)millimeter wave radar high temperatur defect'),
            640:(QtGui.QColor.fromRgb(42,190,140),'(640)millimeter wave radar low voltage defect'),
            644:(QtGui.QColor.fromRgb(43,2,240),'(644)millimeter wave radar axis alighment defect'),
            648:(QtGui.QColor.fromRgb(43,71,84),'(648)ADAS->FrontRadar Com fail'),
            652:(QtGui.QColor.fromRgb(43,139,184),'(652)FrontRadar BackUp Mode fail'),
            656:(QtGui.QColor.fromRgb(43,208,28),'(656)FrontRadar failure'),
            660:(QtGui.QColor.fromRgb(44,20,128),'(660)Camera defect'),
            664:(QtGui.QColor.fromRgb(44,88,228),'(664)Camera aiming not complete defect'),
            668:(QtGui.QColor.fromRgb(44,157,72),'(668)Camera high temperature detect1 fail'),
            672:(QtGui.QColor.fromRgb(44,225,173),'(672)ADAS->FrontCamera Com fail'),
            674:(QtGui.QColor.fromRgb(45,3,223),'(674)TSR Signal Com defect'),
            676:(QtGui.QColor.fromRgb(45,38,17),'(676)ADAS sub->FrontCameraCom fail'),
            680:(QtGui.QColor.fromRgb(45,106,117),'(680)FrontCamera BackUp Mode fail'),
            684:(QtGui.QColor.fromRgb(45,174,217),'(684)FrontCamera defect failure'),
            688:(QtGui.QColor.fromRgb(45,243,61),'(688)Hands off judgement threshold not calibration'),
            692:(QtGui.QColor.fromRgb(46,55,161),'(692)ADASsub failure defect by ADASmain'),
            696:(QtGui.QColor.fromRgb(46,124,5),'(696)AD2 Sub fail(LK prohibit)'),
            696:(QtGui.QColor.fromRgb(46,124,5),'(696)AD2 Sub fail(AD2 prohibit)'),
            697:(QtGui.QColor.fromRgb(46,141,30),'(697)AVM recognition status defect'),
            700:(QtGui.QColor.fromRgb(46,192,105),'(700)AVM status fail'),
            708:(QtGui.QColor.fromRgb(47,73,49),'(708)SOW sensor LEFT detect defect'),
            712:(QtGui.QColor.fromRgb(47,141,149),'(712)SOW sensor RIGHT detect defect'),
            716:(QtGui.QColor.fromRgb(47,209,249),'(716)SOW sensor LEFT CAN receive failure defect'),
            720:(QtGui.QColor.fromRgb(48,22,93),'(720)SOW sensor RIGHT CAN receive failure defect'),
            724:(QtGui.QColor.fromRgb(48,90,194),'(724)SOW sensor LEFT detect defect2'),
            728:(QtGui.QColor.fromRgb(48,159,38),'(728)SOW sensor RIGHT detect defect2'),
            732:(QtGui.QColor.fromRgb(48,227,138),'(732)SOW sensorFL detect defect(AD2)'),
            736:(QtGui.QColor.fromRgb(49,39,238),'(736)SOW sensorFR detect defect(AD2)'),
            740:(QtGui.QColor.fromRgb(49,108,82),'(740)SOW sensorRL detect defect(AD2)'),
            744:(QtGui.QColor.fromRgb(49,176,182),'(744)SOW sensorRR detect defect(AD2)'),
            748:(QtGui.QColor.fromRgb(49,245,26),'(748)SOW sensor LEFT detect defect3'),
            752:(QtGui.QColor.fromRgb(50,57,126),'(752)SOW sensor RIGHT detect defect3'),
            756:(QtGui.QColor.fromRgb(50,125,226),'(756)Sonar detect defect(EAP)'),
            760:(QtGui.QColor.fromRgb(50,194,70),'(760)Sonar system defect'),
            764:(QtGui.QColor.fromRgb(51,6,170),'(764)HD-MAP error message fail'),
            768:(QtGui.QColor.fromRgb(51,75,14),'(768)HUD failure defect'),
            772:(QtGui.QColor.fromRgb(51,143,114),'(772)ADAS_HUDCom failure defect'),
            776:(QtGui.QColor.fromRgb(51,211,215),'(776)DMS defect'),
            780:(QtGui.QColor.fromRgb(52,24,59),'(780)DMS aiming not complete'),
            784:(QtGui.QColor.fromRgb(52,92,159),'(784)EEM defect'),
            788:(QtGui.QColor.fromRgb(52,161,3),'(788)Air pressure defect'),
            796:(QtGui.QColor.fromRgb(53,41,203),'(796)HOD defect'),
            800:(QtGui.QColor.fromRgb(53,110,47),'(800)HOD HW defect'),
            802:(QtGui.QColor.fromRgb(53,144,97),'(802)HOD HW defect'),
            803:(QtGui.QColor.fromRgb(53,161,122),'(803)HOD HW defect'),
            804:(QtGui.QColor.fromRgb(53,178,147),'(804)HOD HW defect'),
            807:(QtGui.QColor.fromRgb(53,229,222),'(807)HOD bus defect'),
            808:(QtGui.QColor.fromRgb(53,246,247),'(808)EPS mortor degree invalid'),
            812:(QtGui.QColor.fromRgb(54,59,91),'(812)EPSsub motor degree invalid'),
            816:(QtGui.QColor.fromRgb(54,127,191),'(816)EPS stearing torque value invalid'),
            820:(QtGui.QColor.fromRgb(54,196,35),'(820)EPSub stearing torque value invalid'),
            824:(QtGui.QColor.fromRgb(55,8,135),'(824)break pedal Signal defect'),
            828:(QtGui.QColor.fromRgb(55,76,236),'(828)break pedal Signal2 defect'),
            832:(QtGui.QColor.fromRgb(55,145,80),'(832)break pressure sensor Signal defect'),
            836:(QtGui.QColor.fromRgb(55,213,180),'(836)Vehicle speed sensorSignal defect'),
            840:(QtGui.QColor.fromRgb(56,26,24),'(840)Wheel speed pulse Signal defect(FL)'),
            841:(QtGui.QColor.fromRgb(56,43,49),'(841)Wheel speed pulse Signal defect(FR)'),
            844:(QtGui.QColor.fromRgb(56,94,124),'(844)Wheel pulse direction Signal defect(RL)'),
            845:(QtGui.QColor.fromRgb(56,111,149),'(845)Wheel pulse direction Signal defect(RR)'),
            848:(QtGui.QColor.fromRgb(56,162,224),'(848)Yaw rate sensor Signal defect'),
            852:(QtGui.QColor.fromRgb(56,231,68),'(852)Wide direction corrected G Signal defect'),
            856:(QtGui.QColor.fromRgb(57,43,168),'(856)Long direction corrected G Signal defect'),
            860:(QtGui.QColor.fromRgb(57,112,12),'(860)Steering wheel degree Signal defect'),
            864:(QtGui.QColor.fromRgb(57,180,112),'(864)Gear position Signal defect'),
            868:(QtGui.QColor.fromRgb(57,248,212),'(868)Accel sensorSignal defect'),
            872:(QtGui.QColor.fromRgb(58,61,56),'(872)Wiper Signal defect'),
            876:(QtGui.QColor.fromRgb(58,129,156),'(876)Outside temperature sensorSignal defect'),
            880:(QtGui.QColor.fromRgb(58,198,1),'(880)Wheel rotate direction Signal defect(FL)'),
            884:(QtGui.QColor.fromRgb(59,10,101),'(884)Wheel rotate direction Signal defect(FR)'),
            896:(QtGui.QColor.fromRgb(59,215,145),'(896)Wide G Signal defect'),
            900:(QtGui.QColor.fromRgb(60,27,245),'(900)Vehicle speed Signal defect'),
            904:(QtGui.QColor.fromRgb(60,96,89),'(904)SW1 welding failure defect'),
            908:(QtGui.QColor.fromRgb(60,164,189),'(908)SW3 welding failure defect'),
            912:(QtGui.QColor.fromRgb(60,233,33),'(912)FEB(FCA) continously actuation count max defect'),
            916:(QtGui.QColor.fromRgb(61,45,133),'(916)G sensorSignal defect'),
            920:(QtGui.QColor.fromRgb(61,113,233),'(920)SW2 welding failure defect'),
            924:(QtGui.QColor.fromRgb(61,182,77),'(924)Stearing rotate speed Signal defect'),
            928:(QtGui.QColor.fromRgb(61,250,177),'(928)Wheel rotate direction Signal defect(EBA)'),
            932:(QtGui.QColor.fromRgb(62,63,22),'(932)Wheel speedpulseSignal defect(EBA)'),
            936:(QtGui.QColor.fromRgb(62,131,122),'(936)Wheel speed sensorSignal defect(EBA)'),
            940:(QtGui.QColor.fromRgb(62,199,222),'(940)Vehicle speed Signal defect(EBA)'),
            944:(QtGui.QColor.fromRgb(63,12,66),'(944)break information Signal defect'),
            1088:(QtGui.QColor.fromRgb(72,170,85),'(1088)Low power voltage cancel defect'),
            1092:(QtGui.QColor.fromRgb(72,238,185),'(1092)R-Car low priority monitoring'),
            1104:(QtGui.QColor.fromRgb(73,187,229),'(1104)CAN receive failure(ITS4-FD SONAR:JT1)'),
            1108:(QtGui.QColor.fromRgb(74,0,73),'(1108)CAN receive failure(ITS1-FD IVI:JT2)'),
            1112:(QtGui.QColor.fromRgb(74,68,173),'(1112)CAN receive failure(ITS4-FD IVI:JT2)'),
            1120:(QtGui.QColor.fromRgb(74,205,117),'(1120)IDM CAN defect(Type A)'),
            1124:(QtGui.QColor.fromRgb(75,17,217),'(1124)Path1(&bis) Steering NG'),
            1128:(QtGui.QColor.fromRgb(75,86,61),'(1128)Path4 Steering NG'),
            1132:(QtGui.QColor.fromRgb(75,154,161),'(1132)AEB(VDC ECU) function failure defect(Type A)'),
            1136:(QtGui.QColor.fromRgb(75,223,6),'(1136)ICC(VDC ECU) function failure defect(Type A)'),
            1140:(QtGui.QColor.fromRgb(76,35,106),'(1140)ECD(VDC ECU) power voltage defect(Type A)'),
            1144:(QtGui.QColor.fromRgb(76,103,206),'(1144)VDC system failure defect(Type A)'),
            1148:(QtGui.QColor.fromRgb(76,172,50),'(1148)ABS system failure defect(Type A)'),
            1152:(QtGui.QColor.fromRgb(76,240,150),'(1152)TCS system failure defect(Type A)'),
            1156:(QtGui.QColor.fromRgb(77,52,250),'(1156)LDP inner VDC function defect(Type A)'),
            1160:(QtGui.QColor.fromRgb(77,121,94),'(1160)Vehicle speed sensor defect(Cancel： defect occurred timing)'),
            1164:(QtGui.QColor.fromRgb(77,189,194),'(1164)Wheel speed sensor defect(Cancel)'),
            1168:(QtGui.QColor.fromRgb(78,2,38),'(1168)ACC_ENABLE_OFF cancel'),
            1172:(QtGui.QColor.fromRgb(78,70,138),'(1172)AD2_BRK_ACTR_STATUS cancel'),
            1176:(QtGui.QColor.fromRgb(78,138,238),'(1176)ePKB SSA available status flag  cancel'),
            1180:(QtGui.QColor.fromRgb(78,207,82),'(1180)ePKB ePKB unavailable'),
            1182:(QtGui.QColor.fromRgb(78,241,132),'(1182)ePKB( parking break defect )(cancel)'),
            1184:(QtGui.QColor.fromRgb(79,19,182),'(1184)ePKB SSA fail flag  cancel'),
            1188:(QtGui.QColor.fromRgb(79,88,27),'(1188)Break oil pressure command value defect'),
            1192:(QtGui.QColor.fromRgb(79,156,127),'(1192)ECM ASCD cancel'),
            1196:(QtGui.QColor.fromRgb(79,224,227),'(1196)Stearing SW  logical defect cancel(C1N)'),
            1200:(QtGui.QColor.fromRgb(80,37,71),'(1200)Stearing SW  logical defect cancel(C1A)'),
            1204:(QtGui.QColor.fromRgb(80,105,171),'(1204)G sensorーUnavailableValue'),
            1208:(QtGui.QColor.fromRgb(80,174,15),'(1208)Radar initial status'),
            1212:(QtGui.QColor.fromRgb(80,242,115),'(1212)Camera reset cancel'),
            1216:(QtGui.QColor.fromRgb(81,54,215),'(1216)Millimeter wave radar camera fusion defect'),
            1220:(QtGui.QColor.fromRgb(81,123,59),'(1220)SR Alignment unadjusted'),
            1224:(QtGui.QColor.fromRgb(81,191,159),'(1224)SideRadar low valtage'),
            1228:(QtGui.QColor.fromRgb(82,4,3),'(1228)Initial not completed'),
            1232:(QtGui.QColor.fromRgb(82,72,103),'(1232)HD-MAP license expired'),
            1236:(QtGui.QColor.fromRgb(82,140,203),'(1236)HD-MAP error message cancel'),
            1244:(QtGui.QColor.fromRgb(83,21,148),'(1244)EPS cancel'),
            1248:(QtGui.QColor.fromRgb(83,89,248),'(1248)AVM recognition status cancel'),
            1252:(QtGui.QColor.fromRgb(83,158,92),'(1252)Clutch defect'),
            1256:(QtGui.QColor.fromRgb(83,226,192),'(1256)Path unavailable notify(cancel) by CDM'),
            1260:(QtGui.QColor.fromRgb(84,39,36),'(1260)ADAS_sub(AVM) defect notify(cancel) by CDM'),
            1345:(QtGui.QColor.fromRgb(89,212,115),'(1345)HDMAP unavailable'),
            1346:(QtGui.QColor.fromRgb(89,229,140),'(1346)Not highway'),
            1347:(QtGui.QColor.fromRgb(89,246,165),'(1347)AD2 unavailable area'),
            1348:(QtGui.QColor.fromRgb(90,7,190),'(1348)No information HDMAP'),
            1349:(QtGui.QColor.fromRgb(90,24,215),'(1349)No median strip'),
            1350:(QtGui.QColor.fromRgb(90,41,240),'(1350)Inside tunnel'),
            1351:(QtGui.QColor.fromRgb(90,59,9),'(1351)Limitted speed under 40 mph(or 50 km/h)'),
            1352:(QtGui.QColor.fromRgb(90,76,34),'(1352)Merge point appear continously'),
            1353:(QtGui.QColor.fromRgb(90,93,59),'(1353)Lane width narrow on HDMAP'),
            1354:(QtGui.QColor.fromRgb(90,110,84),'(1354)FA area (HDMAP old version or Shape limited or SW version limited)'),
            1355:(QtGui.QColor.fromRgb(90,127,109),'(1355)Reserved'),
            1356:(QtGui.QColor.fromRgb(90,144,134),'(1356)Strong curve(under R90)'),
            1357:(QtGui.QColor.fromRgb(90,161,159),'(1357)Strong curve(RCar)'),
            1358:(QtGui.QColor.fromRgb(90,178,184),'(1358)Camera unstable area'),
            1359:(QtGui.QColor.fromRgb(90,195,209),'(1359)Camera unstable area by HDMAP information'),
            1360:(QtGui.QColor.fromRgb(90,212,234),'(1360)Main path remain under 1.3km and remain path to branch is shorter than main path'),
            1361:(QtGui.QColor.fromRgb(90,230,3),'(1361)Cannot recognize vehicle position'),
            1362:(QtGui.QColor.fromRgb(90,247,28),'(1362)Remain length under 50m to merge point'),
            1363:(QtGui.QColor.fromRgb(91,8,53),'(1363)Ramp road or not main road'),
            1364:(QtGui.QColor.fromRgb(91,25,78),'(1364)Over 30m after passed branch point'),
            1365:(QtGui.QColor.fromRgb(91,42,103),'(1365)Near exit or merge point (TD request before 50m)'),
            1366:(QtGui.QColor.fromRgb(91,59,128),'(1366)Near tollgate (TD request before 50m)'),
            1367:(QtGui.QColor.fromRgb(91,76,153),'(1367)Reserved'),
            1368:(QtGui.QColor.fromRgb(91,93,178),'(1368)Reserved'),
            1369:(QtGui.QColor.fromRgb(91,110,203),'(1369)Reserved'),
            1370:(QtGui.QColor.fromRgb(91,127,228),'(1370)Near exit or merge point (Standby：before 150m)'),
            1371:(QtGui.QColor.fromRgb(91,144,253),'(1371)Near exit or merge point (SteerReq：before 150m)'),
            1372:(QtGui.QColor.fromRgb(91,162,22),'(1372)Near tollgate (Standby：before 150m)'),
            1373:(QtGui.QColor.fromRgb(91,179,47),'(1373)Near tollgate  (SteerReq：before 150m)'),
            1374:(QtGui.QColor.fromRgb(91,196,72),'(1374)Reserved'),
            1375:(QtGui.QColor.fromRgb(91,213,97),'(1375)Reserved'),
            1376:(QtGui.QColor.fromRgb(91,230,122),'(1376)Near exit or merge point (HandsOnReq：before 800m)'),
            1377:(QtGui.QColor.fromRgb(91,247,147),'(1377)Near tollgate (HandsOnReq：before 800m)'),
            1378:(QtGui.QColor.fromRgb(92,8,172),'(1378)Reserved'),
            1379:(QtGui.QColor.fromRgb(92,25,197),'(1379)Steering request by FailSafe'),
            1380:(QtGui.QColor.fromRgb(92,42,222),'(1380)Near maintenance area'),
            1381:(QtGui.QColor.fromRgb(92,59,247),'(1381)Not soon start AD2 situation, when available wide control'),
            1536:(QtGui.QColor.fromRgb(102,150,29),'(1536)ABS active cancel(w/o ACC) defect'),
            1537:(QtGui.QColor.fromRgb(102,167,54),'(1537)ABS active cancel'),
            1540:(QtGui.QColor.fromRgb(102,218,129),'(1540)VDC active cancel(w/o ACC) defect'),
            1541:(QtGui.QColor.fromRgb(102,235,154),'(1541)VDC active cancel'),
            1542:(QtGui.QColor.fromRgb(102,252,179),'(1542)VDC active cancel'),
            1544:(QtGui.QColor.fromRgb(103,30,229),'(1544)TCS active cancel'),
            1545:(QtGui.QColor.fromRgb(103,47,254),'(1545)TCS active cancel'),
            1548:(QtGui.QColor.fromRgb(103,99,74),'(1548)ABS lamp lighting'),
            1552:(QtGui.QColor.fromRgb(103,167,174),'(1552)ECM ACC cancel'),
            1556:(QtGui.QColor.fromRgb(103,236,18),'(1556)ACC prohibit Signal ON (ECMACCINH flag defect)'),
            1560:(QtGui.QColor.fromRgb(104,48,118),'(1560)FCA main braking active'),
            1564:(QtGui.QColor.fromRgb(104,116,218),'(1564)FCA sub braking active'),
            1568:(QtGui.QColor.fromRgb(104,185,62),'(1568)DBA active cancel relate distance between cars'),
            1573:(QtGui.QColor.fromRgb(105,14,187),'(1573)EAP active cancel'),
            1576:(QtGui.QColor.fromRgb(105,66,6),'(1576)CBA active cancel'),
            1580:(QtGui.QColor.fromRgb(105,134,106),'(1580)CBA active cancel'),
            1581:(QtGui.QColor.fromRgb(105,151,131),'(1581)IPA active'),
            2048:(QtGui.QColor.fromRgb(136,200,39),'(2048)Millimeter wave radar block defect'),
            2048:(QtGui.QColor.fromRgb(136,200,39),'(2048)Millimeter wave radar block defect(ICC)'),
            2052:(QtGui.QColor.fromRgb(137,12,139),'(2052)Millimeter wave radar interference defect'),
            2056:(QtGui.QColor.fromRgb(137,80,239),'(2056)SCAM3 Full blockage defect'),
            2060:(QtGui.QColor.fromRgb(137,149,83),'(2060)SCAM3 Partial blockage defect'),
            2064:(QtGui.QColor.fromRgb(137,217,184),'(2064)CameraYaw direction misalignment defect'),
            2068:(QtGui.QColor.fromRgb(138,30,28),'(2068)CameraPitch direction misalignment defect'),
            2072:(QtGui.QColor.fromRgb(138,98,128),'(2072)Camera focus misalignment defect'),
            2076:(QtGui.QColor.fromRgb(138,166,228),'(2076)Camera auto alignment Yaw direction threshold out defect'),
            2080:(QtGui.QColor.fromRgb(138,235,72),'(2080)Camera auto alignment Pitch direction threshold out defect'),
            2084:(QtGui.QColor.fromRgb(139,47,172),'(2084)Camera sun light defect'),
            2088:(QtGui.QColor.fromRgb(139,116,16),'(2088)Camera bad weather (SCAM3) defect'),
            2092:(QtGui.QColor.fromRgb(139,184,116),'(2092)TJP camera not clear (ICC)'),
            2096:(QtGui.QColor.fromRgb(139,252,216),'(2096)TJP camera bad weather(ICC)'),
            2100:(QtGui.QColor.fromRgb(140,65,60),'(2100)TJP camera splash(ICC)'),
            2104:(QtGui.QColor.fromRgb(140,133,160),'(2104)TJP camera sun light as vertical line(ICC)'),
            2108:(QtGui.QColor.fromRgb(140,202,4),'(2108)TJP camera night fog(ICC)'),
            2112:(QtGui.QColor.fromRgb(141,14,104),'(2112)Sun light short time'),
            2116:(QtGui.QColor.fromRgb(141,82,205),'(2116)Rainning'),
            2120:(QtGui.QColor.fromRgb(141,151,49),'(2120)Camera not clear defect'),
            2124:(QtGui.QColor.fromRgb(141,219,149),'(2124)Camera splash defect'),
            2128:(QtGui.QColor.fromRgb(142,31,249),'(2128)Camera sun light as vertical line defect'),
            2132:(QtGui.QColor.fromRgb(142,100,93),'(2132)Camera night fog defect'),
            2136:(QtGui.QColor.fromRgb(142,168,193),'(2136)Camera night ranning defect'),
            2140:(QtGui.QColor.fromRgb(142,237,37),'(2140)Camera window freezing defect'),
            2144:(QtGui.QColor.fromRgb(143,49,137),'(2144)Camera night rainning defect by M'),
            2148:(QtGui.QColor.fromRgb(143,117,237),'(2148)Camera message output defect'),
            2152:(QtGui.QColor.fromRgb(143,186,81),'(2152)SideRadar wave interference'),
            2156:(QtGui.QColor.fromRgb(143,254,181),'(2156)blockage status'),
            2160:(QtGui.QColor.fromRgb(144,67,25),'(2160)Low reliability of distance estimate'),
            2164:(QtGui.QColor.fromRgb(144,135,125),'(2164)Unavailable distance estimate'),
            2168:(QtGui.QColor.fromRgb(144,203,226),'(2168)EEM cancel'),
            2172:(QtGui.QColor.fromRgb(145,16,70),'(2172)Road line shape mismatch defect'),
            2176:(QtGui.QColor.fromRgb(145,84,170),'(2176)AVM performance decrease cancel'),
            2180:(QtGui.QColor.fromRgb(145,153,14),'(2180)Sensor status cancel'),
            2184:(QtGui.QColor.fromRgb(145,221,114),'(2184)ASILD correspondence stearing correction active'),
            2208:(QtGui.QColor.fromRgb(147,119,202),'(2208)Abnormal MAP control point'),
            2209:(QtGui.QColor.fromRgb(147,136,227),'(2209)Bad weather'),
            2210:(QtGui.QColor.fromRgb(147,153,252),'(2210)Camera road line shape defect (over 2sec)'),
            2211:(QtGui.QColor.fromRgb(147,171,21),'(2211)Camera road line shape defect'),
            2212:(QtGui.QColor.fromRgb(147,188,46),'(2212)DMS recognize fail'),
            2213:(QtGui.QColor.fromRgb(147,205,71),'(2213)Use MAP in LK control'),
            2214:(QtGui.QColor.fromRgb(147,222,96),'(2214)Servo gain under 0.95'),
            2215:(QtGui.QColor.fromRgb(147,239,121),'(2215)Not driving over 1 sec road center ±30cm range, when LKA->TJA transition'),
            2216:(QtGui.QColor.fromRgb(148,0,146),'(2216)Approach warning'),
            2217:(QtGui.QColor.fromRgb(148,17,171),'(2217)Hands On request by FailSafe'),
            2218:(QtGui.QColor.fromRgb(148,34,196),'(2218)LDP active'),
            2560:(QtGui.QColor.fromRgb(170,250,49),'(2560)Wheel speed sensor electromagnetic noise'),
            2564:(QtGui.QColor.fromRgb(171,62,149),'(2564)wheel slip cancel'),
            2565:(QtGui.QColor.fromRgb(171,79,174),'(2565)wheel slip cancel'),
            2568:(QtGui.QColor.fromRgb(171,130,249),'(2568)Steep slope'),
            2572:(QtGui.QColor.fromRgb(171,199,93),'(2572)Inching lost cancel　(closing)'),
            2576:(QtGui.QColor.fromRgb(172,11,193),'(2576)Inching lost cancel'),
            2580:(QtGui.QColor.fromRgb(172,80,38),'(2580)Low vehicle speed'),
            2584:(QtGui.QColor.fromRgb(172,148,138),'(2584)ASCD vehicle speed defect'),
            2588:(QtGui.QColor.fromRgb(172,216,238),'(2588)Stall control cancel lost(ACC)'),
            2592:(QtGui.QColor.fromRgb(173,29,82),'(2592)Stall keep control over 3 minute'),
            2596:(QtGui.QColor.fromRgb(173,97,182),'(2596)Dynamic ePKB cancel'),
            2600:(QtGui.QColor.fromRgb(173,166,26),'(2600)ePKB system (ePKB braking status)'),
            2604:(QtGui.QColor.fromRgb(173,234,126),'(2604)System Ready OFF cancel'),
            2608:(QtGui.QColor.fromRgb(174,46,226),'(2608)Engin stall cancel'),
            3072:(QtGui.QColor.fromRgb(205,44,59),'(3072)Getting off (TJP)'),
            3073:(QtGui.QColor.fromRgb(205,61,84),'(3073)Getting off (ACC+LKA)'),
            3076:(QtGui.QColor.fromRgb(205,112,159),'(3076)Accel control when other door open'),
            3080:(QtGui.QColor.fromRgb(205,181,3),'(3080)Real gear shift position cancel'),
            3084:(QtGui.QColor.fromRgb(205,249,103),'(3084)PKB SW ON cancel'),
            3088:(QtGui.QColor.fromRgb(206,61,203),'(3088)Control SW double push'),
            3092:(QtGui.QColor.fromRgb(206,130,47),'(3092)Active,Cancel button push same time'),
            3096:(QtGui.QColor.fromRgb(206,198,148),'(3096)HDCON cancel'),
            3100:(QtGui.QColor.fromRgb(207,10,248),'(3100)DCTDowngradeMode cancel'),
            3104:(QtGui.QColor.fromRgb(207,79,92),'(3104)TCS(VDC) OFF SW operation cancel(other ACC) defect'),
            3105:(QtGui.QColor.fromRgb(207,96,117),'(3105)TCS(VDC) OFF SW operation cancel(ACC) defect'),
            3108:(QtGui.QColor.fromRgb(207,147,192),'(3108)FEB MAIN SW OFF defect'),
            3112:(QtGui.QColor.fromRgb(207,216,36),'(3112)AT shift position is not D position'),
            3116:(QtGui.QColor.fromRgb(208,28,136),'(3116)ETS mode cancel'),
            3120:(QtGui.QColor.fromRgb(208,96,236),'(3120)Offload SW cancel'),
            3124:(QtGui.QColor.fromRgb(208,165,80),'(3124)Snow mode SW ON cancel'),
            3128:(QtGui.QColor.fromRgb(208,233,180),'(3128)Driver clutch  operation cancel'),
            3132:(QtGui.QColor.fromRgb(209,46,24),'(3132)break/accel same time operation'),
            3136:(QtGui.QColor.fromRgb(209,114,124),'(3136)Driver steering cancel'),
            3140:(QtGui.QColor.fromRgb(209,182,224),'(3140)Wiper cancel'),
            3144:(QtGui.QColor.fromRgb(209,251,68),'(3144)Wiper low active cancel'),
            3148:(QtGui.QColor.fromRgb(210,63,169),'(3148)Driver getting off'),
            3584:(QtGui.QColor.fromRgb(239,94,69),'(3584)ACC MAIN SW OFF cancel'),
            3588:(QtGui.QColor.fromRgb(239,162,169),'(3588)Cancel SW ON cancel'),
            3592:(QtGui.QColor.fromRgb(239,231,13),'(3592)Driver break operation (TJP)'),
            3648:(QtGui.QColor.fromRgb(243,164,134),'(3648)Meter vehicle speed is over 85 mph(or 130km/h)'),
            3649:(QtGui.QColor.fromRgb(243,181,159),'(3649)Driver not looking front'),
            3650:(QtGui.QColor.fromRgb(243,198,184),'(3650)Driver did not hands on'),
            3651:(QtGui.QColor.fromRgb(243,215,209),'(3651)Accel overdrive'),
            3652:(QtGui.QColor.fromRgb(243,232,234),'(3652)Winker lamp on'),
            3653:(QtGui.QColor.fromRgb(243,250,3),'(3653)Driver trigger LC'),
            3712:(QtGui.QColor.fromRgb(247,234,199),'(3712)Now on LC suggested'),
            3713:(QtGui.QColor.fromRgb(247,251,224),'(3713)Reserved'),
            3714:(QtGui.QColor.fromRgb(248,12,250),'(3714)LC running')}

    if getLocal() == 'ja_JP':
        ND2_code_symbolDic = {
            2:(QtGui.QColor.fromRgb(0,144,82),'(2)バッテリー高電圧異常'),
            4:(QtGui.QColor.fromRgb(1,32,164),'(4)バッテリー低電圧異常'),
            8:(QtGui.QColor.fromRgb(2,65,72),'(8)IGN電圧診断'),
            10:(QtGui.QColor.fromRgb(2,209,154),'(10)IGN異常'),
            12:(QtGui.QColor.fromRgb(3,97,236),'(12)内部電源回路診断'),
            16:(QtGui.QColor.fromRgb(4,130,144),'(16)RAM異常'),
            20:(QtGui.QColor.fromRgb(5,163,52),'(20)Flash ROM異常'),
            24:(QtGui.QColor.fromRgb(6,195,216),'(24)ECM Error'),
            28:(QtGui.QColor.fromRgb(7,228,124),'(28)SPIDER診断'),
            32:(QtGui.QColor.fromRgb(9,5,32),'(32)CANコントローラ診断'),
            36:(QtGui.QColor.fromRgb(10,37,196),'(36)イーサネット診断'),
            40:(QtGui.QColor.fromRgb(11,70,104),'(40)リレー出力診断'),
            41:(QtGui.QColor.fromRgb(11,142,145),'(41)SPI通信CRC診断'),
            42:(QtGui.QColor.fromRgb(11,214,186),'(42)SPI通信Clock診断'),
            43:(QtGui.QColor.fromRgb(12,30,227),'(43)SPI通信未受信診断'),
            44:(QtGui.QColor.fromRgb(12,103,12),'(44)ITS電源回路診断'),
            48:(QtGui.QColor.fromRgb(13,135,176),'(48)SPI診断'),
            52:(QtGui.QColor.fromRgb(14,168,84),'(52)LIN診断'),
            56:(QtGui.QColor.fromRgb(15,200,248),'(56)温度センサ異常'),
            60:(QtGui.QColor.fromRgb(16,233,156),'(60)CAN通信遮断診断'),
            64:(QtGui.QColor.fromRgb(18,10,64),'(64)LED回路異常'),
            68:(QtGui.QColor.fromRgb(19,42,228),'(68)MAIN_CPU内部電圧異常'),
            72:(QtGui.QColor.fromRgb(20,75,136),'(72)SUB_CPU内部電圧異常'),
            76:(QtGui.QColor.fromRgb(21,108,44),'(76)CPU間通信（GPIO）診断'),
            80:(QtGui.QColor.fromRgb(22,140,208),'(80)シャットダウン正常終了判定'),
            84:(QtGui.QColor.fromRgb(23,173,116),'(84)IPD異常'),
            88:(QtGui.QColor.fromRgb(24,206,25),'(88)M3N外部RAM異常'),
            92:(QtGui.QColor.fromRgb(25,238,189),'(92)M3N外部ROM異常'),
            96:(QtGui.QColor.fromRgb(27,15,97),'(96)AutoACC診断'),
            100:(QtGui.QColor.fromRgb(28,48,5),'(100)EEPROM異常'),
            120:(QtGui.QColor.fromRgb(33,211,57),'(120)SPIヘッダバージョン診断'),
            124:(QtGui.QColor.fromRgb(34,243,221),'(124)バリアントコード異常'),
            128:(QtGui.QColor.fromRgb(36,20,129),'(128)バスオフ(ITS1-FD JT2)'),
            129:(QtGui.QColor.fromRgb(36,92,170),'(129)バスオフ(ITS2-FD JT2)'),
            130:(QtGui.QColor.fromRgb(36,164,211),'(130)バスオフ(ITS3-FD JT2)'),
            131:(QtGui.QColor.fromRgb(36,236,252),'(131)バスオフ(ITS4-FD JT2)'),
            132:(QtGui.QColor.fromRgb(37,53,37),'(132)バスオフ(ITS5-FD JT2)'),
            133:(QtGui.QColor.fromRgb(37,125,78),'(133)バスオフ(CH2-CAN JT2)'),
            136:(QtGui.QColor.fromRgb(38,85,201),'(136)CAN未受信異常(ITS4-FD IDM:JT2)(MAC)'),
            136:(QtGui.QColor.fromRgb(38,85,201),'(136)CAN未受信異常(ITS4-FD EPS:JT2)(MAC)'),
            137:(QtGui.QColor.fromRgb(38,157,242),'(137)CAN未受信異常(ITS1-FD IDM:JT2)(MAC)'),
            137:(QtGui.QColor.fromRgb(38,157,242),'(137)CAN未受信異常(ITS1-FD ePKB:JT2)(MAC)'),
            137:(QtGui.QColor.fromRgb(38,157,242),'(137)CAN未受信異常(ITS1-FD EPS:JT2)(MAC)'),
            138:(QtGui.QColor.fromRgb(38,230,27),'(138)CAN未受信異常(ITS1-FD METER:JT2)(MAC)'),
            138:(QtGui.QColor.fromRgb(38,230,27),'(138)CAN未受信異常(ITS1-FD BCM:JT2)(MAC)'),
            138:(QtGui.QColor.fromRgb(38,230,27),'(138)CAN未受信異常(ITS4-FD USM:JT2)(MAC)'),
            139:(QtGui.QColor.fromRgb(39,46,68),'(139)CAN未受信異常(ITS4-FD METER:JT2)(MAC)'),
            139:(QtGui.QColor.fromRgb(39,46,68),'(139)CAN未受信異常(ITS4-FD BCM:JT2)(MAC)'),
            140:(QtGui.QColor.fromRgb(39,118,109),'(140)CAN未受信異常(ITS1-FD HEVC:JT2)(MAC)'),
            141:(QtGui.QColor.fromRgb(39,190,150),'(141)CAN未受信異常(ITS4-FD HEVC:JT2)(MAC)'),
            142:(QtGui.QColor.fromRgb(40,6,191),'(142)CAN未受信異常(ITS1-FD AVM:JT2)(MAC)'),
            143:(QtGui.QColor.fromRgb(40,78,232),'(143)CAN未受信異常(ITS4-FD AVM:JT2)(MAC)'),
            144:(QtGui.QColor.fromRgb(40,151,17),'(144)CAN未受信異常(ITS4-FD SONAR:JT2)(MAC)'),
            152:(QtGui.QColor.fromRgb(42,216,89),'(152)CAN未受信異常(ITS1-FD IDM:JT1)'),
            152:(QtGui.QColor.fromRgb(42,216,89),'(152)CAN未受信異常(ITS1-FD IDM:JT2)'),
            154:(QtGui.QColor.fromRgb(43,104,171),'(154)メッセージカウンタ診断(ITS1-FD CDM)'),
            155:(QtGui.QColor.fromRgb(43,176,212),'(155)チェックサム診断(ITS1-FD CDM)'),
            156:(QtGui.QColor.fromRgb(43,248,253),'(156)CAN未受信異常(ITS4-FD IDM:JT2)'),
            157:(QtGui.QColor.fromRgb(44,65,38),'(157)CAN未受信異常(ITS4-FD IDM:JT1)'),
            158:(QtGui.QColor.fromRgb(44,137,79),'(158)メッセージカウンタ診断(ITS4-FD CDM)'),
            159:(QtGui.QColor.fromRgb(44,209,120),'(159)チェックサム診断(ITS4-FD CDM)'),
            160:(QtGui.QColor.fromRgb(45,25,161),'(160)CAN未受信異常(ITS1-FD VDC:JT2)'),
            160:(QtGui.QColor.fromRgb(45,25,161),'(160)CAN未受信異常(ITS1-FD VDC:JT2)(MAC)'),
            161:(QtGui.QColor.fromRgb(45,97,202),'(161)CAN未受信異常(ITS1-FD VDC:JT1)'),
            162:(QtGui.QColor.fromRgb(45,169,243),'(162)メッセージカウンタ診断(ITS1-FD VDC)'),
            163:(QtGui.QColor.fromRgb(45,242,28),'(163)チェックサム診断(ITS1-FD VDC)'),
            164:(QtGui.QColor.fromRgb(46,58,69),'(164)CAN未受信異常(ITS4-FD VDC:JT2)'),
            164:(QtGui.QColor.fromRgb(46,58,69),'(164)CAN未受信異常(ITS4-FD VDC:JT2)(MAC)'),
            164:(QtGui.QColor.fromRgb(46,58,69),'(164)CAN未受信異常(ITS4-FD VDC via CH2:JT2)'),
            165:(QtGui.QColor.fromRgb(46,130,110),'(165)CAN未受信異常(ITS4-FD VDC:JT1)'),
            165:(QtGui.QColor.fromRgb(46,130,110),'(165)CAN未受信異常(ITS4-FD VDC via CH2:JT1)'),
            166:(QtGui.QColor.fromRgb(46,202,151),'(166)メッセージカウンタ診断(ITS4-FD VDC)'),
            167:(QtGui.QColor.fromRgb(47,18,192),'(167)チェックサム診断(ITS4-FD VDC)'),
            168:(QtGui.QColor.fromRgb(47,90,233),'(168)CAN未受信異常(CH2-CAN VDC:JT2)'),
            170:(QtGui.QColor.fromRgb(47,235,59),'(170)メッセージカウンタ診断(CH2-CAN VDC)'),
            171:(QtGui.QColor.fromRgb(48,51,100),'(171)チェックサム診断(CH2-CAN VDC)'),
            172:(QtGui.QColor.fromRgb(48,123,141),'(172)CAN未受信異常(ITS1-FD ePKB:JT2)'),
            173:(QtGui.QColor.fromRgb(48,195,182),'(173)CAN未受信異常(ITS1-FD ePKB:JT1)'),
            174:(QtGui.QColor.fromRgb(49,11,223),'(174)メッセージカウンタ診断(ITS4-FD ePKB)'),
            175:(QtGui.QColor.fromRgb(49,84,8),'(175)チェックサム診断(ITS4-FD ePKB)'),
            178:(QtGui.QColor.fromRgb(50,44,132),'(178)メッセージカウンタ診断(CH2-CAN ePKB)'),
            179:(QtGui.QColor.fromRgb(50,116,173),'(179)チェックサム診断(CH2-CAN ePKB)'),
            180:(QtGui.QColor.fromRgb(50,188,214),'(180)CAN未受信異常(ITS1-FD EBA:JT2)'),
            184:(QtGui.QColor.fromRgb(51,221,122),'(184)CAN未受信異常(CH2-CAN EBA:JT2)'),
            186:(QtGui.QColor.fromRgb(52,109,204),'(186)Clockフェール(CH2-CAN EBA)'),
            187:(QtGui.QColor.fromRgb(52,181,245),'(187)CRCフェール(CH2-CAN EBA)'),
            188:(QtGui.QColor.fromRgb(52,254,30),'(188)CAN未受信異常(ITS1-FD EPS:JT2)'),
            189:(QtGui.QColor.fromRgb(53,70,71),'(189)CAN未受信異常(ITS1-FD EPS:JT1)'),
            190:(QtGui.QColor.fromRgb(53,142,112),'(190)メッセージカウンタ診断(ITS1-FD EPS)'),
            191:(QtGui.QColor.fromRgb(53,214,153),'(191)チェックサム診断(ITS1-FD EPS)'),
            192:(QtGui.QColor.fromRgb(54,30,194),'(192)CAN未受信異常(ITS4-FD EPS:JT2)'),
            193:(QtGui.QColor.fromRgb(54,102,235),'(193)CAN未受信異常(ITS4-FD EPS:JT1)'),
            194:(QtGui.QColor.fromRgb(54,175,20),'(194)メッセージカウンタ診断(ITS4-FD EPS)'),
            195:(QtGui.QColor.fromRgb(54,247,61),'(195)チェックサム診断(ITS4-FD EPS)'),
            196:(QtGui.QColor.fromRgb(55,63,102),'(196)CAN未受信異常(CH2-CAN EPSsub:JT2)'),
            198:(QtGui.QColor.fromRgb(55,207,184),'(198)Clockフェール(CH2-CAN EPSsub)'),
            199:(QtGui.QColor.fromRgb(56,23,225),'(199)CRCフェール(CH2-CAN EPSsub)'),
            200:(QtGui.QColor.fromRgb(56,96,10),'(200)CAN未受信異常(ITS1-FD BCM:JT2)'),
            201:(QtGui.QColor.fromRgb(56,168,51),'(201)CAN未受信異常(ITS1-FD BCM:JT1)'),
            202:(QtGui.QColor.fromRgb(56,240,92),'(202)メッセージカウンタ診断(ITS1-FD BCM)'),
            203:(QtGui.QColor.fromRgb(57,56,133),'(203)チェックサム診断(ITS1-FD BCM)'),
            204:(QtGui.QColor.fromRgb(57,128,174),'(204)CAN未受信異常(ITS4-FD BCM:JT2)'),
            205:(QtGui.QColor.fromRgb(57,200,215),'(205)CAN未受信異常(ITS4-FD BCM:JT1)'),
            206:(QtGui.QColor.fromRgb(58,17,0),'(206)メッセージカウンタ診断(ITS4-FD BCM)'),
            207:(QtGui.QColor.fromRgb(58,89,41),'(207)チェックサム診断(ITS4-FD BCM)'),
            208:(QtGui.QColor.fromRgb(58,161,82),'(208)CAN未受信異常(ITS1-FD METER:JT2)'),
            212:(QtGui.QColor.fromRgb(59,193,246),'(212)CAN未受信異常(ITS4-FD METER:JT2)'),
            213:(QtGui.QColor.fromRgb(60,10,31),'(213)CAN未受信異常(ITS4-FD METER:JT1)'),
            214:(QtGui.QColor.fromRgb(60,82,72),'(214)メッセージカウンタ診断(ITS4-FD METER)'),
            215:(QtGui.QColor.fromRgb(60,154,113),'(215)チェックサム診断(ITS4-FD METER)'),
            216:(QtGui.QColor.fromRgb(60,226,154),'(216)CAN未受信異常(ITS4-FD STR:JT2)'),
            216:(QtGui.QColor.fromRgb(60,226,154),'(216)CAN未受信異常(ITS4-FD STR:JT2)(MAC)'),
            217:(QtGui.QColor.fromRgb(61,42,195),'(217)CAN未受信異常(ITS4-FD STR:JT1)'),
            218:(QtGui.QColor.fromRgb(61,114,236),'(218)メッセージカウンタ診断(ITS4-FD STR)'),
            219:(QtGui.QColor.fromRgb(61,187,21),'(219)チェックサム診断(ITS4-FD STR)'),
            220:(QtGui.QColor.fromRgb(62,3,62),'(220)CAN未受信異常(ITS1-FD HEVC:JT2)'),
            221:(QtGui.QColor.fromRgb(62,75,103),'(221)CAN未受信異常(ITS1-FD HEVC:JT1)'),
            222:(QtGui.QColor.fromRgb(62,147,144),'(222)メッセージカウンタ診断(ITS1-FD HEVC)'),
            223:(QtGui.QColor.fromRgb(62,219,185),'(223)チェックサム診断(ITS1-FD HEVC)'),
            224:(QtGui.QColor.fromRgb(63,35,226),'(224)CAN未受信異常(ITS4-FD HEVC:JT2)'),
            225:(QtGui.QColor.fromRgb(63,108,11),'(225)CAN未受信異常(ITS4-FD HEVC:JT1)'),
            226:(QtGui.QColor.fromRgb(63,180,52),'(226)メッセージカウンタ診断(ITS4-FD HEVC)'),
            227:(QtGui.QColor.fromRgb(63,252,93),'(227)チェックサム診断(ITS4-FD HEVC)'),
            228:(QtGui.QColor.fromRgb(64,68,134),'(228)メッセージカウンタ診断(ITS4-FD HCM)'),
            229:(QtGui.QColor.fromRgb(64,140,175),'(229)チェックサム診断(ITS4-FD HCM)'),
            230:(QtGui.QColor.fromRgb(64,212,216),'(230)メッセージカウンタ診断(ITS4-FD ATCU)'),
            231:(QtGui.QColor.fromRgb(65,29,1),'(231)チェックサム診断(ITS4-FD ATCU)'),
            232:(QtGui.QColor.fromRgb(65,101,42),'(232)Ethernet link down(Radar:JT2)'),
            233:(QtGui.QColor.fromRgb(65,173,83),'(233)Ethernet link down_2(Radar:JT2)'),
            234:(QtGui.QColor.fromRgb(65,245,124),'(234)Ethernet 未受信(Radar:JT2)'),
            235:(QtGui.QColor.fromRgb(66,61,165),'(235)Ethernet 未受信_2(Radar:JT2)'),
            236:(QtGui.QColor.fromRgb(66,133,206),'(236)Ethernet 未受信(Radar:JT1)'),
            237:(QtGui.QColor.fromRgb(66,205,247),'(237)Ethernet 未受信_2(Radar:JT1)'),
            238:(QtGui.QColor.fromRgb(67,22,32),'(238)Ethernet Clockフェール(Radar)'),
            239:(QtGui.QColor.fromRgb(67,94,73),'(239)Ethernet Clockフェール_2(Radar)'),
            240:(QtGui.QColor.fromRgb(67,166,114),'(240)Ethernet CRCフェール(Radar)'),
            241:(QtGui.QColor.fromRgb(67,238,155),'(241)Ethernet CRCフェール_2(Radar)'),
            242:(QtGui.QColor.fromRgb(68,54,196),'(242)CAN未受信異常(ITS2-FD CAM:JT2)'),
            243:(QtGui.QColor.fromRgb(68,126,237),'(243)CAN未受信異常(ITS2-FD CAM:JT1)'),
            244:(QtGui.QColor.fromRgb(68,199,22),'(244)Clockフェール(ITS2-FD Camera)'),
            245:(QtGui.QColor.fromRgb(69,15,63),'(245)CRCフェール(ITS2-FD FrCamera)'),
            246:(QtGui.QColor.fromRgb(69,87,104),'(246)Ethernet link down(FrCamera:JT2)'),
            247:(QtGui.QColor.fromRgb(69,159,145),'(247)Ethernet link down_2(FrCamera:JT2)'),
            248:(QtGui.QColor.fromRgb(69,231,186),'(248)Ethernet 未受信(FrCamera2:JT2)'),
            249:(QtGui.QColor.fromRgb(70,47,227),'(249)Ethernet 未受信_2(FrCamera2:JT2)'),
            250:(QtGui.QColor.fromRgb(70,120,12),'(250)Ethernet 未受信(FrCamera2:JT1)'),
            251:(QtGui.QColor.fromRgb(70,192,53),'(251)Ethernet 未受信_2(FrCamera2:JT1)'),
            252:(QtGui.QColor.fromRgb(71,8,94),'(252)Ethernet Clockフェール(FrCamera2)'),
            253:(QtGui.QColor.fromRgb(71,80,135),'(253)Ethernet Clockフェール_2(FrCamera2)'),
            254:(QtGui.QColor.fromRgb(71,152,176),'(254)Ethernet CRCフェール(FrCamera2)'),
            255:(QtGui.QColor.fromRgb(71,224,217),'(255)Ethernet CRCフェール_2(FrCamera2)'),
            256:(QtGui.QColor.fromRgb(72,41,2),'(256)CAN未受信異常(ITS1-FD AVM:JT2)'),
            257:(QtGui.QColor.fromRgb(72,113,43),'(257)CAN未受信異常(ITS1-FD AVM:JT1)'),
            258:(QtGui.QColor.fromRgb(72,185,84),'(258)メッセージカウンタ診断(ITS1-FD AVM)'),
            259:(QtGui.QColor.fromRgb(73,1,125),'(259)チェックサム診断(ITS1-FD AVM)'),
            260:(QtGui.QColor.fromRgb(73,73,166),'(260)CAN未受信異常(ITS3-FD AVM:JT2)'),
            262:(QtGui.QColor.fromRgb(73,217,248),'(262)メッセージカウンタ診断(ITS3-FD AVM)'),
            263:(QtGui.QColor.fromRgb(74,34,33),'(263)チェックサム診断(ITS3-FD AVM)'),
            264:(QtGui.QColor.fromRgb(74,106,75),'(264)CAN未受信異常(ITS4-FD AVM:JT2)'),
            265:(QtGui.QColor.fromRgb(74,178,116),'(265)CAN未受信異常(ITS4-FD AVM:JT1)'),
            266:(QtGui.QColor.fromRgb(74,250,157),'(266)メッセージカウンタ診断(ITS4-FD AVM)'),
            267:(QtGui.QColor.fromRgb(75,66,198),'(267)チェックサム診断(ITS4-FD AVM)'),
            268:(QtGui.QColor.fromRgb(75,138,239),'(268)Ethernet link down(AVM:JT2)'),
            269:(QtGui.QColor.fromRgb(75,211,24),'(269)Ethernet link down_2(AVM:JT2)'),
            270:(QtGui.QColor.fromRgb(76,27,65),'(270)Ethernet 未受信(AVM:JT2)'),
            271:(QtGui.QColor.fromRgb(76,99,106),'(271)Ethernet 未受信_2(AVM:JT2)'),
            272:(QtGui.QColor.fromRgb(76,171,147),'(272)Ethernet 未受信(AVM:JT1)'),
            273:(QtGui.QColor.fromRgb(76,243,188),'(273)Ethernet 未受信_2(AVM:JT1)'),
            274:(QtGui.QColor.fromRgb(77,59,229),'(274)Ethernet Clockフェール(AVM)'),
            275:(QtGui.QColor.fromRgb(77,132,14),'(275)Ethernet Clockフェール_2(AVM)'),
            276:(QtGui.QColor.fromRgb(77,204,55),'(276)Ethernet CRCフェール(AVM)'),
            277:(QtGui.QColor.fromRgb(78,20,96),'(277)Ethernet CRCフェール_2(AVM)'),
            278:(QtGui.QColor.fromRgb(78,92,137),'(278)Ethernet link down_2(HDMap:JT2)'),
            279:(QtGui.QColor.fromRgb(78,164,178),'(279)Ethernet 未受信_2(HDMap:JT2)'),
            280:(QtGui.QColor.fromRgb(78,236,219),'(280)Ethernet 未受信_2(HDMap:JT1)'),
            281:(QtGui.QColor.fromRgb(79,53,4),'(281)CAN未受信異常(ITS3-FD SOW-RL:JT2)'),
            282:(QtGui.QColor.fromRgb(79,125,45),'(282)CAN未受信異常(ITS3-FD SOW-RL:JT1)'),
            283:(QtGui.QColor.fromRgb(79,197,86),'(283)メッセージカウンタ診断(ITS3-FD SR:RL)'),
            284:(QtGui.QColor.fromRgb(80,13,127),'(284)チェックサム診断(ITS3-FD SR:RL)'),
            285:(QtGui.QColor.fromRgb(80,85,168),'(285)CAN未受信異常(ITS3-FD SOW-RR:JT2)'),
            286:(QtGui.QColor.fromRgb(80,157,209),'(286)CAN未受信異常(ITS3-FD SOW-RR:JT1)'),
            287:(QtGui.QColor.fromRgb(80,229,250),'(287)メッセージカウンタ診断(ITS3-FD SR:RR)'),
            288:(QtGui.QColor.fromRgb(81,46,35),'(288)チェックサム診断(ITS3-FD SR:RR)'),
            289:(QtGui.QColor.fromRgb(81,118,76),'(289)CAN未受信異常(ITS5-FD SRad_FL:JT2)'),
            290:(QtGui.QColor.fromRgb(81,190,117),'(290)CAN未受信異常(ITS5-FD SRad_FL:JT1)'),
            291:(QtGui.QColor.fromRgb(82,6,158),'(291)メッセージカウンタ診断(ITS5-FD SR:FL)'),
            292:(QtGui.QColor.fromRgb(82,78,199),'(292)チェックサム診断(ITS5-FD SR:FL)'),
            293:(QtGui.QColor.fromRgb(82,150,240),'(293)CAN未受信異常(ITS5-FD SRad_FR:JT2)'),
            294:(QtGui.QColor.fromRgb(82,223,25),'(294)CAN未受信異常(ITS5-FD SRad_FR:JT1)'),
            295:(QtGui.QColor.fromRgb(83,39,66),'(295)メッセージカウンタ診断(ITS5-FD SR:FR)'),
            296:(QtGui.QColor.fromRgb(83,111,107),'(296)チェックサム診断(ITS5-FD SR:FR)'),
            297:(QtGui.QColor.fromRgb(83,183,148),'(297)CAN未受信異常(ITS4-FD SONAR:JT2)'),
            298:(QtGui.QColor.fromRgb(83,255,189),'(298)メッセージカウンタ診断(ITS4-FD SONAR)'),
            299:(QtGui.QColor.fromRgb(84,71,230),'(299)チェックサム診断(ITS4-FD SONAR)'),
            300:(QtGui.QColor.fromRgb(84,144,15),'(300)CAN未受信異常(CH2-CAN HUD:JT2)'),
            302:(QtGui.QColor.fromRgb(85,32,97),'(302)Clockフェール(CH2-CAN HUD)'),
            303:(QtGui.QColor.fromRgb(85,104,138),'(303)CRCフェール(CH2-CAN HUD)'),
            304:(QtGui.QColor.fromRgb(85,176,179),'(304)CAN未受信異常(ITS2-FD DMC:JT2)'),
            306:(QtGui.QColor.fromRgb(86,65,5),'(306)Clockフェール(ITS2-FD DMC)'),
            307:(QtGui.QColor.fromRgb(86,137,46),'(307)CRCフェール(ITS2-FD DMC)'),
            308:(QtGui.QColor.fromRgb(86,209,87),'(308)CAN未受信異常(ITS4-FD USM:JT2)'),
            309:(QtGui.QColor.fromRgb(87,25,128),'(309)CAN未受信異常(ITS4-FD USM:JT1)'),
            310:(QtGui.QColor.fromRgb(87,97,169),'(310)メッセージカウンタ診断(ITS4-FD USM)'),
            311:(QtGui.QColor.fromRgb(87,169,210),'(311)チェックサム診断(ITS4-FD USM)'),
            336:(QtGui.QColor.fromRgb(94,181,211),'(336)LIN バスオフ'),
            340:(QtGui.QColor.fromRgb(95,214,119),'(340)LIN未受信(HOD:JT2)'),
            342:(QtGui.QColor.fromRgb(96,102,201),'(342)LIN Clockフェール(HOD)'),
            343:(QtGui.QColor.fromRgb(96,174,242),'(343)LIN CRCフェール(HOD)'),
            352:(QtGui.QColor.fromRgb(99,56,100),'(352)CDM判断によるPath使用不可通知'),
            356:(QtGui.QColor.fromRgb(100,89,8),'(356)ICC異常(VDC)'),
            360:(QtGui.QColor.fromRgb(101,121,172),'(360)AEB異常(VDC)'),
            364:(QtGui.QColor.fromRgb(102,154,80),'(364)Steering異常(EPSmain)'),
            368:(QtGui.QColor.fromRgb(103,186,244),'(368)ICC異常(EBA)'),
            372:(QtGui.QColor.fromRgb(104,219,152),'(372)AEB異常(EBA)'),
            376:(QtGui.QColor.fromRgb(105,252,60),'(376)Steering異常(EPSsub)'),
            380:(QtGui.QColor.fromRgb(107,28,224),'(380)CDMからのADAS_sub(AVM)異常通知'),
            384:(QtGui.QColor.fromRgb(108,61,132),'(384)Path1 ICC NG'),
            388:(QtGui.QColor.fromRgb(109,94,40),'(388)Path1 AEB NG'),
            392:(QtGui.QColor.fromRgb(110,126,204),'(392)AEB（VDC ECU）機能故障診断(Type C)'),
            396:(QtGui.QColor.fromRgb(111,159,112),'(396)ICC（VDC ECU）機能故障診断(Type C)'),
            400:(QtGui.QColor.fromRgb(112,192,20),'(400)ECD(VDC ECU) 電源電圧異常(Type C)'),
            404:(QtGui.QColor.fromRgb(113,224,184),'(404)EPSフェール'),
            408:(QtGui.QColor.fromRgb(115,1,92),'(408)IDM CAN異常診断結果(Type C)'),
            412:(QtGui.QColor.fromRgb(116,34,0),'(412)IDM異常判定'),
            416:(QtGui.QColor.fromRgb(117,66,164),'(416)IDMトルク指令値異常'),
            420:(QtGui.QColor.fromRgb(118,99,72),'(420)ACC_ALIVE_OFFフェール'),
            424:(QtGui.QColor.fromRgb(119,131,236),'(424)ACC_ALIVE_OFFフェール(IDM)'),
            428:(QtGui.QColor.fromRgb(120,164,144),'(428)VDCシステム故障診断結果(Type C)'),
            432:(QtGui.QColor.fromRgb(121,197,52),'(432)ABSシステム故障診断結果(Type C)'),
            436:(QtGui.QColor.fromRgb(122,229,216),'(436)TCSｼｽﾃﾑ故障診断結果(Type C)'),
            440:(QtGui.QColor.fromRgb(124,6,125),'(440)VDC内LDP機能異常診断結果(Type C)'),
            444:(QtGui.QColor.fromRgb(125,39,33),'(444)VDC ECU診断中判定'),
            448:(QtGui.QColor.fromRgb(126,71,197),'(448)前輪車輪速センサ不整合故障診断結果(Right)'),
            449:(QtGui.QColor.fromRgb(126,143,238),'(449)前輪車輪速センサ不整合故障診断結果(Left)'),
            450:(QtGui.QColor.fromRgb(126,216,23),'(450)後輪車輪速センサ不整合故障診断結果(Right)'),
            451:(QtGui.QColor.fromRgb(127,32,64),'(451)後輪車輪速センサ不整合故障診断結果(Left)'),
            452:(QtGui.QColor.fromRgb(127,104,105),'(452)車速センサ不整合故障'),
            456:(QtGui.QColor.fromRgb(128,137,13),'(456)車輪速ｾﾝｻUnavailableValue'),
            460:(QtGui.QColor.fromRgb(129,169,177),'(460)車輪速パルス信号異常判断(Left)'),
            461:(QtGui.QColor.fromRgb(129,241,218),'(461)車輪速パルス信号異常判断(Right)'),
            464:(QtGui.QColor.fromRgb(130,202,85),'(464)ブレーキSW故障診断結果'),
            468:(QtGui.QColor.fromRgb(131,234,249),'(468)ストップランプリレーOFF固着診断結果'),
            472:(QtGui.QColor.fromRgb(133,11,157),'(472)ストップランプリレー診断(CDMによるランプ制御)'),
            476:(QtGui.QColor.fromRgb(134,44,65),'(476)ストップランプリレーON固着診断'),
            480:(QtGui.QColor.fromRgb(135,76,229),'(480)ePKB パーキングブレーキ異常表示フェール'),
            484:(QtGui.QColor.fromRgb(136,109,137),'(484)ePKB SSAフェールフラグ フェール'),
            488:(QtGui.QColor.fromRgb(137,142,45),'(488)ｱｸｾﾙﾍﾟﾀﾞﾙﾌｪｰﾙﾌﾗｸﾞ検出診断結果'),
            492:(QtGui.QColor.fromRgb(138,174,209),'(492)ETCフェールフラグ検出診断結果'),
            496:(QtGui.QColor.fromRgb(139,207,117),'(496)ECMCANFAILフラグ診断結果'),
            500:(QtGui.QColor.fromRgb(140,240,25),'(500)ACC指令値異常検出診断結果'),
            504:(QtGui.QColor.fromRgb(142,16,189),'(504)HCMｼｽﾃﾑ異常'),
            508:(QtGui.QColor.fromRgb(143,49,97),'(508)ECMASCDﾌｪｰﾙﾌﾗｸﾞ検出'),
            510:(QtGui.QColor.fromRgb(143,193,179),'(510)レーン情報喪失(Eth及びCAN)'),
            511:(QtGui.QColor.fromRgb(144,9,220),'(511)レーン情報受信異常'),
            512:(QtGui.QColor.fromRgb(144,82,5),'(512)ECMACCINHﾌﾗｸﾞ診断'),
            516:(QtGui.QColor.fromRgb(145,114,169),'(516)ギヤ位置不整合検出(AT)'),
            520:(QtGui.QColor.fromRgb(146,147,77),'(520)ギヤ位置不整合検出(CVT)'),
            524:(QtGui.QColor.fromRgb(147,179,241),'(524)CVTシステム異常'),
            528:(QtGui.QColor.fromRgb(148,212,150),'(528)舵角センサ異常診断結果'),
            532:(QtGui.QColor.fromRgb(149,245,58),'(532)ステアリングSW溶着診断（C1N）'),
            536:(QtGui.QColor.fromRgb(151,21,222),'(536)ｽﾃｱﾘﾝｸﾞ SW 論理異常フェール （C1N）'),
            540:(QtGui.QColor.fromRgb(152,54,130),'(540)ICCﾒｲﾝ SW溶着故障 （C1N）'),
            544:(QtGui.QColor.fromRgb(153,87,38),'(544)ステアリングSW溶着診断（C1A)'),
            548:(QtGui.QColor.fromRgb(154,119,202),'(548)ICCﾒｲﾝ SW溶着故障(C1A)'),
            552:(QtGui.QColor.fromRgb(155,152,110),'(552)ｽﾃｱﾘﾝｸﾞ SW 論理異常フェール(C1A)'),
            556:(QtGui.QColor.fromRgb(156,185,18),'(556)METER故障診断'),
            560:(QtGui.QColor.fromRgb(157,217,182),'(560)ADAS_METER通信故障診断'),
            564:(QtGui.QColor.fromRgb(158,250,90),'(564)ﾐﾘ波ﾚｰﾀﾞ故障診断結果'),
            568:(QtGui.QColor.fromRgb(160,26,254),'(568)ﾐﾘ波ﾚｰﾀﾞｰCAN通信異常診断結果'),
            572:(QtGui.QColor.fromRgb(161,59,162),'(572)ﾐﾘ波ﾚｰﾀﾞ高温異常診断結果'),
            576:(QtGui.QColor.fromRgb(162,92,70),'(576)ﾐﾘ波ﾚｰﾀﾞｰ低電圧異常診断結果'),
            580:(QtGui.QColor.fromRgb(163,124,234),'(580)ﾐﾘ波ﾚｰﾀﾞｰ軸ずれ異常診断結果'),
            584:(QtGui.QColor.fromRgb(164,157,142),'(584)ADAS->FrontRadar通信フェール'),
            588:(QtGui.QColor.fromRgb(165,190,50),'(588)FrontRadar BackUp Modeフェール'),
            592:(QtGui.QColor.fromRgb(166,222,214),'(592)FrontRadar故障フェール'),
            596:(QtGui.QColor.fromRgb(167,255,122),'(596)カメラ異常判断診断結果'),
            600:(QtGui.QColor.fromRgb(169,32,30),'(600)カメラエーミング未実施診断結果'),
            604:(QtGui.QColor.fromRgb(170,64,194),'(604)カメラ高温検知1診断結果'),
            608:(QtGui.QColor.fromRgb(171,97,102),'(608)ADAS->FrontCamera通信フェール'),
            610:(QtGui.QColor.fromRgb(171,241,184),'(610)TSR信号通信異常診断'),
            612:(QtGui.QColor.fromRgb(172,130,10),'(612)ADAS sub->FrontCamera通信フェール'),
            616:(QtGui.QColor.fromRgb(173,162,175),'(616)FrontCamera BackUp Modeフェール'),
            620:(QtGui.QColor.fromRgb(174,195,83),'(620)FrontCamera故障フェール'),
            624:(QtGui.QColor.fromRgb(175,227,247),'(624)ハンズオフ判定しきい値未キャリブ'),
            628:(QtGui.QColor.fromRgb(177,4,155),'(628)ADASmainによるADASsub故障診断'),
            632:(QtGui.QColor.fromRgb(178,37,63),'(632)AD2 Sub系統フェール(LK禁止)'),
            632:(QtGui.QColor.fromRgb(178,37,63),'(632)AD2 Sub系統フェール(AD2禁止)'),
            633:(QtGui.QColor.fromRgb(178,109,104),'(633)AVM認識状態異常'),
            636:(QtGui.QColor.fromRgb(179,69,227),'(636)AVMステータスフェール'),
            644:(QtGui.QColor.fromRgb(181,135,43),'(644)SOWセンサLEFT 異常判断診断結果'),
            648:(QtGui.QColor.fromRgb(182,167,207),'(648)SOWセンサRIGHT 異常判断診断結果'),
            652:(QtGui.QColor.fromRgb(183,200,115),'(652)SOWセンサLEFT CAN未受信診断結果'),
            656:(QtGui.QColor.fromRgb(184,233,23),'(656)SOWセンサRIGHT CAN未受信診断結果'),
            660:(QtGui.QColor.fromRgb(186,9,187),'(660)SOWセンサLEFT 異常判断2'),
            664:(QtGui.QColor.fromRgb(187,42,95),'(664)SOWセンサRIGHT 異常判断2'),
            668:(QtGui.QColor.fromRgb(188,75,3),'(668)SOWセンサFL異常判断(AD2)'),
            672:(QtGui.QColor.fromRgb(189,107,167),'(672)SOWセンサFR異常判断(AD2)'),
            676:(QtGui.QColor.fromRgb(190,140,75),'(676)SOWセンサRL異常判断(AD2)'),
            680:(QtGui.QColor.fromRgb(191,172,239),'(680)SOWセンサRR異常判断(AD2)'),
            684:(QtGui.QColor.fromRgb(192,205,147),'(684)SOWセンサLEFT 異常判断3'),
            688:(QtGui.QColor.fromRgb(193,238,55),'(688)SOWセンサRIGHT 異常判断3'),
            692:(QtGui.QColor.fromRgb(195,14,219),'(692)ソナー異常判断(EAP)'),
            696:(QtGui.QColor.fromRgb(196,47,127),'(696)ソナーシステム故障'),
            700:(QtGui.QColor.fromRgb(197,80,35),'(700)HD-MAPエラーメッセージフェール'),
            704:(QtGui.QColor.fromRgb(198,112,200),'(704)HUD故障診断'),
            708:(QtGui.QColor.fromRgb(199,145,108),'(708)ADAS_HUD通信故障診断'),
            712:(QtGui.QColor.fromRgb(200,178,16),'(712)DMS故障'),
            716:(QtGui.QColor.fromRgb(201,210,180),'(716)DMSエーミング未実施'),
            720:(QtGui.QColor.fromRgb(202,243,88),'(720)EEM故障'),
            724:(QtGui.QColor.fromRgb(204,19,252),'(724)空気圧異常'),
            732:(QtGui.QColor.fromRgb(206,85,68),'(732)HOD異常診断'),
            736:(QtGui.QColor.fromRgb(207,117,232),'(736)HOD HW異常'),
            738:(QtGui.QColor.fromRgb(208,6,58),'(738)HOD HW異常'),
            739:(QtGui.QColor.fromRgb(208,78,99),'(739)HOD HW異常'),
            740:(QtGui.QColor.fromRgb(208,150,140),'(740)HOD HW異常'),
            743:(QtGui.QColor.fromRgb(209,111,7),'(743)HOD バス異常'),
            744:(QtGui.QColor.fromRgb(209,183,48),'(744)EPSモーター角度値無効'),
            748:(QtGui.QColor.fromRgb(210,215,212),'(748)EPSsubモーター角度値無効'),
            752:(QtGui.QColor.fromRgb(211,248,120),'(752)EPSステアリングトルク値無効'),
            756:(QtGui.QColor.fromRgb(213,25,28),'(756)EPSubステアリングトルク値無効'),
            760:(QtGui.QColor.fromRgb(214,57,192),'(760)ブレーキペダル信号異常'),
            764:(QtGui.QColor.fromRgb(215,90,100),'(764)ブレーキペダル信号2異常'),
            768:(QtGui.QColor.fromRgb(216,123,8),'(768)ブレーキ圧力センサ信号異常'),
            772:(QtGui.QColor.fromRgb(217,155,172),'(772)車速センサ信号異常'),
            776:(QtGui.QColor.fromRgb(218,188,80),'(776)車輪速パルス信号異常(FL)'),
            777:(QtGui.QColor.fromRgb(219,4,121),'(777)車輪速パルス信号異常(FR)'),
            780:(QtGui.QColor.fromRgb(219,220,244),'(780)車輪回転方向信号異常(RL)'),
            781:(QtGui.QColor.fromRgb(220,37,29),'(781)車輪回転方向信号異常(RR)'),
            784:(QtGui.QColor.fromRgb(220,253,152),'(784)ヨーレートセンサ信号異常'),
            788:(QtGui.QColor.fromRgb(222,30,60),'(788)補正横加速度信号異常'),
            792:(QtGui.QColor.fromRgb(223,62,225),'(792)補正縦加速度信号異常'),
            796:(QtGui.QColor.fromRgb(224,95,133),'(796)ステアリングホイール角信号異常'),
            800:(QtGui.QColor.fromRgb(225,128,41),'(800)ギヤ位置信号異常'),
            804:(QtGui.QColor.fromRgb(226,160,205),'(804)アクセルセンサ信号異常'),
            808:(QtGui.QColor.fromRgb(227,193,113),'(808)ワイパー信号異常'),
            812:(QtGui.QColor.fromRgb(228,226,21),'(812)外気温センサ信号異常'),
            816:(QtGui.QColor.fromRgb(230,2,185),'(816)車輪回転方向信号異常(FL)'),
            820:(QtGui.QColor.fromRgb(231,35,93),'(820)車輪回転方向信号異常(FR)'),
            832:(QtGui.QColor.fromRgb(234,133,73),'(832)横加速度信号異常'),
            836:(QtGui.QColor.fromRgb(235,165,237),'(836)車両速度信号異常'),
            840:(QtGui.QColor.fromRgb(236,198,145),'(840)SW1溶着故障診断結果'),
            844:(QtGui.QColor.fromRgb(237,231,53),'(844)SW3溶着故障診断結果'),
            848:(QtGui.QColor.fromRgb(239,7,217),'(848)FEB(FCA)連続作動回数上限診断結果'),
            852:(QtGui.QColor.fromRgb(240,40,125),'(852)Gセンサ信号異常'),
            856:(QtGui.QColor.fromRgb(241,73,33),'(856)SW2溶着故障診断結果'),
            860:(QtGui.QColor.fromRgb(242,105,197),'(860)舵角速度信号異常'),
            864:(QtGui.QColor.fromRgb(243,138,105),'(864)車輪回転方向信号異常(EBA)'),
            868:(QtGui.QColor.fromRgb(244,171,13),'(868)車輪速パルス信号異常(EBA)'),
            872:(QtGui.QColor.fromRgb(245,203,177),'(872)車輪速センサ信号異常(EBA)'),
            876:(QtGui.QColor.fromRgb(246,236,85),'(876)車速信号異常(EBA)'),
            880:(QtGui.QColor.fromRgb(248,12,250),'(880)ブレーキ情報信号異常')}
        
    else:
        ND2_code_symbolDic = {
            2:(QtGui.QColor.fromRgb(0,144,82),'(2)Battery high voltage error'),
            4:(QtGui.QColor.fromRgb(1,32,164),'(4)Battery low voltage error'),
            8:(QtGui.QColor.fromRgb(2,65,72),'(8)IGN voltage diagnosis'),
            10:(QtGui.QColor.fromRgb(2,209,154),'(10)IGN anomaly'),
            12:(QtGui.QColor.fromRgb(3,97,236),'(12)Internal power supply circuit diagnosis'),
            16:(QtGui.QColor.fromRgb(4,130,144),'(16)RAM error'),
            20:(QtGui.QColor.fromRgb(5,163,52),'(20)Flash ROM error'),
            24:(QtGui.QColor.fromRgb(6,195,216),'(24)ECM Error'),
            28:(QtGui.QColor.fromRgb(7,228,124),'(28)SPIDER Diagnosis'),
            32:(QtGui.QColor.fromRgb(9,5,32),'(32)CAN controller diagnostics'),
            36:(QtGui.QColor.fromRgb(10,37,196),'(36)ethernet diagnostics'),
            40:(QtGui.QColor.fromRgb(11,70,104),'(40)relay output diagnostic'),
            41:(QtGui.QColor.fromRgb(11,142,145),'(41)SPI communication CRC diagnosis'),
            42:(QtGui.QColor.fromRgb(11,214,186),'(42)SPI communication clock diagnosis'),
            43:(QtGui.QColor.fromRgb(12,30,227),'(43)SPI communication unreceived diagnosis'),
            44:(QtGui.QColor.fromRgb(12,103,12),'(44)ITS power circuit diagnosis'),
            48:(QtGui.QColor.fromRgb(13,135,176),'(48)SPI diagnostics'),
            52:(QtGui.QColor.fromRgb(14,168,84),'(52)LIN diagnosis'),
            56:(QtGui.QColor.fromRgb(15,200,248),'(56)Abnormal temperature sensor'),
            60:(QtGui.QColor.fromRgb(16,233,156),'(60)CAN communication interruption diagnosis'),
            64:(QtGui.QColor.fromRgb(18,10,64),'(64)LED circuit error'),
            68:(QtGui.QColor.fromRgb(19,42,228),'(68)MAIN_CPU internal voltage error'),
            72:(QtGui.QColor.fromRgb(20,75,136),'(72)SUB_CPU internal voltage error'),
            76:(QtGui.QColor.fromRgb(21,108,44),'(76)Inter-CPU communication (GPIO) diagnostics'),
            80:(QtGui.QColor.fromRgb(22,140,208),'(80)Shutdown normal end judgment'),
            84:(QtGui.QColor.fromRgb(23,173,116),'(84)IPD anomaly'),
            88:(QtGui.QColor.fromRgb(24,206,25),'(88)M3N external RAM error'),
            92:(QtGui.QColor.fromRgb(25,238,189),'(92)M3N external ROM error'),
            96:(QtGui.QColor.fromRgb(27,15,97),'(96)AutoACC Diagnosis'),
            100:(QtGui.QColor.fromRgb(28,48,5),'(100)EEPROM error'),
            120:(QtGui.QColor.fromRgb(33,211,57),'(120)SPI header version diagnosis'),
            124:(QtGui.QColor.fromRgb(34,243,221),'(124)Variant code error'),
            128:(QtGui.QColor.fromRgb(36,20,129),'(128)Bus off (ITS1-FD JT2)'),
            129:(QtGui.QColor.fromRgb(36,92,170),'(129)Bus off (ITS2-FD JT2)'),
            130:(QtGui.QColor.fromRgb(36,164,211),'(130)Bus off (ITS3-FD JT2)'),
            131:(QtGui.QColor.fromRgb(36,236,252),'(131)Bus off (ITS4-FD JT2)'),
            132:(QtGui.QColor.fromRgb(37,53,37),'(132)Bus off (ITS5-FD JT2)'),
            133:(QtGui.QColor.fromRgb(37,125,78),'(133)Bus off (CH2-CAN JT2)'),
            136:(QtGui.QColor.fromRgb(38,85,201),'(136)CAN unreceived error (ITS4-FD IDM: JT2) (MAC)'),
            136:(QtGui.QColor.fromRgb(38,85,201),'(136)CAN unreceived error (ITS4-FD EPS: JT2) (MAC)'),
            137:(QtGui.QColor.fromRgb(38,157,242),'(137)CAN unreceived error (ITS1-FD IDM: JT2) (MAC)'),
            137:(QtGui.QColor.fromRgb(38,157,242),'(137)CAN unreceived error (ITS1-FD ePKB:JT2) (MAC)'),
            137:(QtGui.QColor.fromRgb(38,157,242),'(137)CAN unreceived error (ITS1-FD EPS:JT2) (MAC)'),
            138:(QtGui.QColor.fromRgb(38,230,27),'(138)CAN unreceived error (ITS1-FD METER: JT2) (MAC)'),
            138:(QtGui.QColor.fromRgb(38,230,27),'(138)CAN unreceived error (ITS1-FD BCM:JT2) (MAC)'),
            138:(QtGui.QColor.fromRgb(38,230,27),'(138)CAN unreceived error (ITS4-FD USM:JT2) (MAC)'),
            139:(QtGui.QColor.fromRgb(39,46,68),'(139)CAN unreceived error (ITS4-FD METER: JT2) (MAC)'),
            139:(QtGui.QColor.fromRgb(39,46,68),'(139)CAN unreceived error (ITS4-FD BCM:JT2) (MAC)'),
            140:(QtGui.QColor.fromRgb(39,118,109),'(140)CAN unreceived error (ITS1-FD HEVC:JT2) (MAC)'),
            141:(QtGui.QColor.fromRgb(39,190,150),'(141)CAN unreceived error (ITS4-FD HEVC: JT2) (MAC)'),
            142:(QtGui.QColor.fromRgb(40,6,191),'(142)CAN unreceived error (ITS1-FD AVM: JT2) (MAC)'),
            143:(QtGui.QColor.fromRgb(40,78,232),'(143)CAN unreceived error (ITS4-FD AVM: JT2) (MAC)'),
            144:(QtGui.QColor.fromRgb(40,151,17),'(144)CAN unreceived error (ITS4-FD SONAR:JT2) (MAC)'),
            152:(QtGui.QColor.fromRgb(42,216,89),'(152)CAN unreceived error (ITS1-FD IDM: JT1)'),
            152:(QtGui.QColor.fromRgb(42,216,89),'(152)CAN unreceived error (ITS1-FD IDM: JT2)'),
            154:(QtGui.QColor.fromRgb(43,104,171),'(154)Message counter diagnostics (ITS1-FD CDM)'),
            155:(QtGui.QColor.fromRgb(43,176,212),'(155)Checksum diagnostics (ITS1-FD CDM)'),
            156:(QtGui.QColor.fromRgb(43,248,253),'(156)CAN unreceived error (ITS4-FD IDM: JT2)'),
            157:(QtGui.QColor.fromRgb(44,65,38),'(157)CAN unreceived error (ITS4-FD IDM: JT1)'),
            158:(QtGui.QColor.fromRgb(44,137,79),'(158)Message counter diagnostics (ITS4-FD CDM)'),
            159:(QtGui.QColor.fromRgb(44,209,120),'(159)Checksum diagnostics (ITS4-FD CDM)'),
            160:(QtGui.QColor.fromRgb(45,25,161),'(160)CAN unreceived error (ITS1-FD VDC: JT2)'),
            160:(QtGui.QColor.fromRgb(45,25,161),'(160)CAN unreceived error (ITS1-FD VDC: JT2) (MAC)'),
            161:(QtGui.QColor.fromRgb(45,97,202),'(161)CAN unreceived error (ITS1-FD VDC: JT1)'),
            162:(QtGui.QColor.fromRgb(45,169,243),'(162)Message counter diagnosis (ITS1-FD VDC)'),
            163:(QtGui.QColor.fromRgb(45,242,28),'(163)Checksum diagnostic (ITS1-FD VDC)'),
            164:(QtGui.QColor.fromRgb(46,58,69),'(164)CAN unreceived error (ITS4-FD VDC: JT2)'),
            164:(QtGui.QColor.fromRgb(46,58,69),'(164)CAN unreceived error (ITS4-FD VDC: JT2) (MAC)'),
            164:(QtGui.QColor.fromRgb(46,58,69),'(164)CAN unreceived error (ITS4-FD VDC via CH2:JT2)'),
            165:(QtGui.QColor.fromRgb(46,130,110),'(165)CAN unreceived error (ITS4-FD VDC: JT1)'),
            165:(QtGui.QColor.fromRgb(46,130,110),'(165)CAN unreceived error (ITS4-FD VDC via CH2:JT1)'),
            166:(QtGui.QColor.fromRgb(46,202,151),'(166)Message counter diagnosis (ITS4-FD VDC)'),
            167:(QtGui.QColor.fromRgb(47,18,192),'(167)Checksum diagnostics (ITS4-FD VDC)'),
            168:(QtGui.QColor.fromRgb(47,90,233),'(168)CAN unreceived error (CH2-CAN VDC: JT2)'),
            170:(QtGui.QColor.fromRgb(47,235,59),'(170)Message counter diagnosis (CH2-CAN VDC)'),
            171:(QtGui.QColor.fromRgb(48,51,100),'(171)Checksum diagnosis (CH2-CAN VDC)'),
            172:(QtGui.QColor.fromRgb(48,123,141),'(172)CAN unreceived error (ITS1-FD ePKB:JT2)'),
            173:(QtGui.QColor.fromRgb(48,195,182),'(173)CAN unreceived error (ITS1-FD ePKB:JT1)'),
            174:(QtGui.QColor.fromRgb(49,11,223),'(174)Message counter diagnosis (ITS4-FD ePKB)'),
            175:(QtGui.QColor.fromRgb(49,84,8),'(175)Checksum diagnosis (ITS4-FD ePKB)'),
            178:(QtGui.QColor.fromRgb(50,44,132),'(178)Message counter diagnosis (CH2-CAN ePKB)'),
            179:(QtGui.QColor.fromRgb(50,116,173),'(179)Checksum diagnosis (CH2-CAN ePKB)'),
            180:(QtGui.QColor.fromRgb(50,188,214),'(180)CAN unreceived error (ITS1-FD EBA:JT2)'),
            184:(QtGui.QColor.fromRgb(51,221,122),'(184)CAN not received error (CH2-CAN EBA: JT2)'),
            186:(QtGui.QColor.fromRgb(52,109,204),'(186)Clock Fail (CH2-CAN EBA)'),
            187:(QtGui.QColor.fromRgb(52,181,245),'(187)CRC fail (CH2-CAN EBA)'),
            188:(QtGui.QColor.fromRgb(52,254,30),'(188)CAN not received error (ITS1-FD EPS:JT2)'),
            189:(QtGui.QColor.fromRgb(53,70,71),'(189)CAN unreceived error (ITS1-FD EPS:JT1)'),
            190:(QtGui.QColor.fromRgb(53,142,112),'(190)Message counter diagnosis (ITS1-FD EPS)'),
            191:(QtGui.QColor.fromRgb(53,214,153),'(191)Checksum diagnostic (ITS1-FD EPS)'),
            192:(QtGui.QColor.fromRgb(54,30,194),'(192)CAN not received error (ITS4-FD EPS: JT2)'),
            193:(QtGui.QColor.fromRgb(54,102,235),'(193)CAN not received error (ITS4-FD EPS: JT1)'),
            194:(QtGui.QColor.fromRgb(54,175,20),'(194)Message counter diagnosis (ITS4-FD EPS)'),
            195:(QtGui.QColor.fromRgb(54,247,61),'(195)Checksum diagnostic (ITS4-FD EPS)'),
            196:(QtGui.QColor.fromRgb(55,63,102),'(196)CAN not received error (CH2-CAN EPSsub:JT2)'),
            198:(QtGui.QColor.fromRgb(55,207,184),'(198)Clock fail (CH2-CAN EPSsub)'),
            199:(QtGui.QColor.fromRgb(56,23,225),'(199)CRC fail (CH2-CAN EPSsub)'),
            200:(QtGui.QColor.fromRgb(56,96,10),'(200)CAN unreceived error (ITS1-FD BCM:JT2)'),
            201:(QtGui.QColor.fromRgb(56,168,51),'(201)CAN unreceived error (ITS1-FD BCM:JT1)'),
            202:(QtGui.QColor.fromRgb(56,240,92),'(202)Message counter diagnosis (ITS1-FD BCM)'),
            203:(QtGui.QColor.fromRgb(57,56,133),'(203)Checksum diagnosis (ITS1-FD BCM)'),
            204:(QtGui.QColor.fromRgb(57,128,174),'(204)CAN unreceived error (ITS4-FD BCM:JT2)'),
            205:(QtGui.QColor.fromRgb(57,200,215),'(205)CAN unreceived error (ITS4-FD BCM:JT1)'),
            206:(QtGui.QColor.fromRgb(58,17,0),'(206)Message counter diagnosis (ITS4-FD BCM)'),
            207:(QtGui.QColor.fromRgb(58,89,41),'(207)Checksum diagnosis (ITS4-FD BCM)'),
            208:(QtGui.QColor.fromRgb(58,161,82),'(208)CAN not received error (ITS1-FD METER: JT2)'),
            212:(QtGui.QColor.fromRgb(59,193,246),'(212)CAN unreceived error (ITS4-FD METER: JT2)'),
            213:(QtGui.QColor.fromRgb(60,10,31),'(213)CAN unreceived error (ITS4-FD METER: JT1)'),
            214:(QtGui.QColor.fromRgb(60,82,72),'(214)Message counter diagnosis (ITS4-FD METER)'),
            215:(QtGui.QColor.fromRgb(60,154,113),'(215)Checksum diagnosis (ITS4-FD METER)'),
            216:(QtGui.QColor.fromRgb(60,226,154),'(216)CAN unreceived error (ITS4-FD STR:JT2)'),
            216:(QtGui.QColor.fromRgb(60,226,154),'(216)CAN unreceived error (ITS4-FD STR:JT2) (MAC)'),
            217:(QtGui.QColor.fromRgb(61,42,195),'(217)CAN unreceived error (ITS4-FD STR:JT1)'),
            218:(QtGui.QColor.fromRgb(61,114,236),'(218)Message counter diagnosis (ITS4-FD STR)'),
            219:(QtGui.QColor.fromRgb(61,187,21),'(219)Checksum diagnostic (ITS4-FD STR)'),
            220:(QtGui.QColor.fromRgb(62,3,62),'(220)CAN unreceived error (ITS1-FD HEVC:JT2)'),
            221:(QtGui.QColor.fromRgb(62,75,103),'(221)CAN unreceived error (ITS1-FD HEVC:JT1)'),
            222:(QtGui.QColor.fromRgb(62,147,144),'(222)Message counter diagnosis (ITS1-FD HEVC)'),
            223:(QtGui.QColor.fromRgb(62,219,185),'(223)Checksum diagnosis (ITS1-FD HEVC)'),
            224:(QtGui.QColor.fromRgb(63,35,226),'(224)CAN unreceived error (ITS4-FD HEVC: JT2)'),
            225:(QtGui.QColor.fromRgb(63,108,11),'(225)CAN not received error (ITS4-FD HEVC: JT1)'),
            226:(QtGui.QColor.fromRgb(63,180,52),'(226)Message counter diagnosis (ITS4-FD HEVC)'),
            227:(QtGui.QColor.fromRgb(63,252,93),'(227)Checksum diagnosis (ITS4-FD HEVC)'),
            228:(QtGui.QColor.fromRgb(64,68,134),'(228)Message counter diagnosis (ITS4-FD HCM)'),
            229:(QtGui.QColor.fromRgb(64,140,175),'(229)Checksum diagnostics (ITS4-FD HCM)'),
            230:(QtGui.QColor.fromRgb(64,212,216),'(230)Message counter diagnosis (ITS4-FD ATCU)'),
            231:(QtGui.QColor.fromRgb(65,29,1),'(231)Checksum diagnostic (ITS4-FD ATCU)'),
            232:(QtGui.QColor.fromRgb(65,101,42),'(232)Ethernet link down (Radar: JT2)'),
            233:(QtGui.QColor.fromRgb(65,173,83),'(233)Ethernet link down_2 (Radar: JT2)'),
            234:(QtGui.QColor.fromRgb(65,245,124),'(234)Ethernet not received (Radar:JT2)'),
            235:(QtGui.QColor.fromRgb(66,61,165),'(235)Ethernet not received_2 (Radar: JT2)'),
            236:(QtGui.QColor.fromRgb(66,133,206),'(236)Ethernet not received (Radar: JT1)'),
            237:(QtGui.QColor.fromRgb(66,205,247),'(237)Ethernet not received_2 (Radar: JT1)'),
            238:(QtGui.QColor.fromRgb(67,22,32),'(238)Ethernet Clock Fail (Radar)'),
            239:(QtGui.QColor.fromRgb(67,94,73),'(239)Ethernet Clock Fail_2 (Radar)'),
            240:(QtGui.QColor.fromRgb(67,166,114),'(240)Ethernet CRC failure (Radar)'),
            241:(QtGui.QColor.fromRgb(67,238,155),'(241)Ethernet CRC fail_2 (Radar)'),
            242:(QtGui.QColor.fromRgb(68,54,196),'(242)CAN unreceived error (ITS2-FD CAM: JT2)'),
            243:(QtGui.QColor.fromRgb(68,126,237),'(243)CAN unreceived error (ITS2-FD CAM: JT1)'),
            244:(QtGui.QColor.fromRgb(68,199,22),'(244)Clock Fail (ITS2-FD Camera)'),
            245:(QtGui.QColor.fromRgb(69,15,63),'(245)CRC failure (ITS2-FD FrCamera)'),
            246:(QtGui.QColor.fromRgb(69,87,104),'(246)Ethernet link down (FrCamera: JT2)'),
            247:(QtGui.QColor.fromRgb(69,159,145),'(247)Ethernet link down_2 (FrCamera: JT2)'),
            248:(QtGui.QColor.fromRgb(69,231,186),'(248)Ethernet not received (FrCamera2:JT2)'),
            249:(QtGui.QColor.fromRgb(70,47,227),'(249)Ethernet not received_2 (FrCamera2:JT2)'),
            250:(QtGui.QColor.fromRgb(70,120,12),'(250)Ethernet not received (FrCamera2:JT1)'),
            251:(QtGui.QColor.fromRgb(70,192,53),'(251)Ethernet not received_2 (FrCamera2:JT1)'),
            252:(QtGui.QColor.fromRgb(71,8,94),'(252)Ethernet Clock Fail (FrCamera2)'),
            253:(QtGui.QColor.fromRgb(71,80,135),'(253)Ethernet Clock Fail_2 (FrCamera2)'),
            254:(QtGui.QColor.fromRgb(71,152,176),'(254)Ethernet CRC failure (FrCamera2)'),
            255:(QtGui.QColor.fromRgb(71,224,217),'(255)Ethernet CRC fail_2 (FrCamera2)'),
            256:(QtGui.QColor.fromRgb(72,41,2),'(256)CAN not received error (ITS1-FD AVM: JT2)'),
            257:(QtGui.QColor.fromRgb(72,113,43),'(257)CAN unreceived error (ITS1-FD AVM: JT1)'),
            258:(QtGui.QColor.fromRgb(72,185,84),'(258)Message counter diagnosis (ITS1-FD AVM)'),
            259:(QtGui.QColor.fromRgb(73,1,125),'(259)Checksum diagnostic (ITS1-FD AVM)'),
            260:(QtGui.QColor.fromRgb(73,73,166),'(260)CAN unreceived error (ITS3-FD AVM: JT2)'),
            262:(QtGui.QColor.fromRgb(73,217,248),'(262)Message counter diagnosis (ITS3-FD AVM)'),
            263:(QtGui.QColor.fromRgb(74,34,33),'(263)Checksum diagnostics (ITS3-FD AVM)'),
            264:(QtGui.QColor.fromRgb(74,106,75),'(264)CAN unreceived error (ITS4-FD AVM: JT2)'),
            265:(QtGui.QColor.fromRgb(74,178,116),'(265)CAN unreceived error (ITS4-FD AVM: JT1)'),
            266:(QtGui.QColor.fromRgb(74,250,157),'(266)Message counter diagnostics (ITS4-FD AVM)'),
            267:(QtGui.QColor.fromRgb(75,66,198),'(267)Checksum diagnostics (ITS4-FD AVM)'),
            268:(QtGui.QColor.fromRgb(75,138,239),'(268)Ethernet link down (AVM: JT2)'),
            269:(QtGui.QColor.fromRgb(75,211,24),'(269)Ethernet link down_2 (AVM: JT2)'),
            270:(QtGui.QColor.fromRgb(76,27,65),'(270)Ethernet not received (AVM:JT2)'),
            271:(QtGui.QColor.fromRgb(76,99,106),'(271)Ethernet not received_2 (AVM:JT2)'),
            272:(QtGui.QColor.fromRgb(76,171,147),'(272)Ethernet not received (AVM: JT1)'),
            273:(QtGui.QColor.fromRgb(76,243,188),'(273)Ethernet not received_2 (AVM: JT1)'),
            274:(QtGui.QColor.fromRgb(77,59,229),'(274)Ethernet Clock Fail (AVM)'),
            275:(QtGui.QColor.fromRgb(77,132,14),'(275)Ethernet Clock Fail_2 (AVM)'),
            276:(QtGui.QColor.fromRgb(77,204,55),'(276)Ethernet CRC Fail (AVM)'),
            277:(QtGui.QColor.fromRgb(78,20,96),'(277)Ethernet CRC fail_2 (AVM)'),
            278:(QtGui.QColor.fromRgb(78,92,137),'(278)Ethernet link down_2(HDMap:JT2)'),
            279:(QtGui.QColor.fromRgb(78,164,178),'(279)Ethernet not received_2 (HDMap:JT2)'),
            280:(QtGui.QColor.fromRgb(78,236,219),'(280)Ethernet not received_2 (HDMap:JT1)'),
            281:(QtGui.QColor.fromRgb(79,53,4),'(281)CAN unreceived error (ITS3-FD SOW-RL:JT2)'),
            282:(QtGui.QColor.fromRgb(79,125,45),'(282)CAN unreceived error (ITS3-FD SOW-RL:JT1)'),
            283:(QtGui.QColor.fromRgb(79,197,86),'(283)Message counter diagnosis (ITS3-FD SR:RL)'),
            284:(QtGui.QColor.fromRgb(80,13,127),'(284)Checksum diagnosis (ITS3-FD SR:RL)'),
            285:(QtGui.QColor.fromRgb(80,85,168),'(285)CAN unreceived error (ITS3-FD SOW-RR: JT2)'),
            286:(QtGui.QColor.fromRgb(80,157,209),'(286)CAN not received error (ITS3-FD SOW-RR: JT1)'),
            287:(QtGui.QColor.fromRgb(80,229,250),'(287)Message counter diagnosis (ITS3-FD SR:RR)'),
            288:(QtGui.QColor.fromRgb(81,46,35),'(288)Checksum diagnosis (ITS3-FD SR:RR)'),
            289:(QtGui.QColor.fromRgb(81,118,76),'(289)CAN unreceived error (ITS5-FD SRad_FL:JT2)'),
            290:(QtGui.QColor.fromRgb(81,190,117),'(290)CAN unreceived error (ITS5-FD SRad_FL:JT1)'),
            291:(QtGui.QColor.fromRgb(82,6,158),'(291)Message counter diagnosis (ITS5-FD SR:FL)'),
            292:(QtGui.QColor.fromRgb(82,78,199),'(292)Checksum diagnosis (ITS5-FD SR:FL)'),
            293:(QtGui.QColor.fromRgb(82,150,240),'(293)CAN unreceived error (ITS5-FD SRad_FR:JT2)'),
            294:(QtGui.QColor.fromRgb(82,223,25),'(294)CAN unreceived error (ITS5-FD SRad_FR:JT1)'),
            295:(QtGui.QColor.fromRgb(83,39,66),'(295)Message counter diagnosis (ITS5-FD SR:FR)'),
            296:(QtGui.QColor.fromRgb(83,111,107),'(296)Checksum diagnosis (ITS5-FD SR:FR)'),
            297:(QtGui.QColor.fromRgb(83,183,148),'(297)CAN unreceived error (ITS4-FD SONAR:JT2)'),
            298:(QtGui.QColor.fromRgb(83,255,189),'(298)Message counter diagnosis (ITS4-FD SONAR)'),
            299:(QtGui.QColor.fromRgb(84,71,230),'(299)Checksum diagnostics (ITS4-FD SONAR)'),
            300:(QtGui.QColor.fromRgb(84,144,15),'(300)CAN not received error (CH2-CAN HUD: JT2)'),
            302:(QtGui.QColor.fromRgb(85,32,97),'(302)Clock Fail (CH2-CAN HUD)'),
            303:(QtGui.QColor.fromRgb(85,104,138),'(303)CRC fail (CH2-CAN HUD)'),
            304:(QtGui.QColor.fromRgb(85,176,179),'(304)CAN unreceived error (ITS2-FD DMC:JT2)'),
            306:(QtGui.QColor.fromRgb(86,65,5),'(306)Clock Fail (ITS2-FD DMC)'),
            307:(QtGui.QColor.fromRgb(86,137,46),'(307)CRC failure (ITS2-FD DMC)'),
            308:(QtGui.QColor.fromRgb(86,209,87),'(308)CAN unreceived error (ITS4-FD USM:JT2)'),
            309:(QtGui.QColor.fromRgb(87,25,128),'(309)CAN unreceived error (ITS4-FD USM:JT1)'),
            310:(QtGui.QColor.fromRgb(87,97,169),'(310)Message counter diagnostics (ITS4-FD USM)'),
            311:(QtGui.QColor.fromRgb(87,169,210),'(311)Checksum diagnostic (ITS4-FD USM)'),
            336:(QtGui.QColor.fromRgb(94,181,211),'(336)LIN bus off'),
            340:(QtGui.QColor.fromRgb(95,214,119),'(340)LIN not received (HOD: JT2)'),
            342:(QtGui.QColor.fromRgb(96,102,201),'(342)LIN Clock Fail (HOD)'),
            343:(QtGui.QColor.fromRgb(96,174,242),'(343)LIN CRC Fail (HOD)'),
            352:(QtGui.QColor.fromRgb(99,56,100),'(352)Path unavailable notification by CDM decision'),
            356:(QtGui.QColor.fromRgb(100,89,8),'(356)ICC anomaly (VDC)'),
            360:(QtGui.QColor.fromRgb(101,121,172),'(360)AEB anomaly (VDC)'),
            364:(QtGui.QColor.fromRgb(102,154,80),'(364)Steering error (EPSmain)'),
            368:(QtGui.QColor.fromRgb(103,186,244),'(368)ICC anomaly (EBA)'),
            372:(QtGui.QColor.fromRgb(104,219,152),'(372)Abnormal AEB (EBA)'),
            376:(QtGui.QColor.fromRgb(105,252,60),'(376)Abnormal Steering (EPSsub)'),
            380:(QtGui.QColor.fromRgb(107,28,224),'(380)ADAS_sub(AVM) anomaly notification from CDM'),
            384:(QtGui.QColor.fromRgb(108,61,132),'(384)Path 1 ICC NG'),
            388:(QtGui.QColor.fromRgb(109,94,40),'(388)Path1 AEB NG'),
            392:(QtGui.QColor.fromRgb(110,126,204),'(392)AEB (VDC ECU) functional fault diagnosis (Type C)'),
            396:(QtGui.QColor.fromRgb(111,159,112),'(396)ICC (VDC ECU) functional fault diagnosis (Type C)'),
            400:(QtGui.QColor.fromRgb(112,192,20),'(400)ECD (VDC ECU) Abnormal power supply voltage (Type C)'),
            404:(QtGui.QColor.fromRgb(113,224,184),'(404)EPS fail'),
            408:(QtGui.QColor.fromRgb(115,1,92),'(408)IDM CAN abnormality diagnosis result (Type C)'),
            412:(QtGui.QColor.fromRgb(116,34,0),'(412)IDM abnormality judgment'),
            416:(QtGui.QColor.fromRgb(117,66,164),'(416)Abnormal IDM torque command value'),
            420:(QtGui.QColor.fromRgb(118,99,72),'(420)ACC_ALIVE_OFF Fail'),
            424:(QtGui.QColor.fromRgb(119,131,236),'(424)ACC_ALIVE_OFF Fail (IDM)'),
            428:(QtGui.QColor.fromRgb(120,164,144),'(428)VDC system fault diagnosis result (Type C)'),
            432:(QtGui.QColor.fromRgb(121,197,52),'(432)ABS system failure diagnosis result (Type C)'),
            436:(QtGui.QColor.fromRgb(122,229,216),'(436)TCS system failure diagnosis result (Type C)'),
            440:(QtGui.QColor.fromRgb(124,6,125),'(440)LDP function abnormality diagnosis result in VDC (Type C)'),
            444:(QtGui.QColor.fromRgb(125,39,33),'(444)Judgment during VDC ECU diagnosis'),
            448:(QtGui.QColor.fromRgb(126,71,197),'(448)Front wheel wheel speed sensor mismatch failure diagnosis result (Right)'),
            449:(QtGui.QColor.fromRgb(126,143,238),'(449)Front wheel wheel speed sensor mismatch failure diagnosis result (Left)'),
            450:(QtGui.QColor.fromRgb(126,216,23),'(450)Rear wheel speed sensor mismatch failure diagnosis result (Right)'),
            451:(QtGui.QColor.fromRgb(127,32,64),'(451)Rear wheel speed sensor mismatch failure diagnosis result (Left)'),
            452:(QtGui.QColor.fromRgb(127,104,105),'(452)Vehicle speed sensor mismatch failure'),
            456:(QtGui.QColor.fromRgb(128,137,13),'(456)Wheel speed sensor UnavailableValue'),
            460:(QtGui.QColor.fromRgb(129,169,177),'(460)Wheel speed pulse signal abnormality judgment (Left)'),
            461:(QtGui.QColor.fromRgb(129,241,218),'(461)Wheel speed pulse signal abnormality judgment (Right)'),
            464:(QtGui.QColor.fromRgb(130,202,85),'(464)Brake SW failure diagnosis result'),
            468:(QtGui.QColor.fromRgb(131,234,249),'(468)Stop lamp relay OFF fixed diagnosis result'),
            472:(QtGui.QColor.fromRgb(133,11,157),'(472)Stop lamp relay diagnosis (lamp control by CDM)'),
            476:(QtGui.QColor.fromRgb(134,44,65),'(476)Stop lamp relay ON stuck diagnosis'),
            480:(QtGui.QColor.fromRgb(135,76,229),'(480)ePKB parking brake error display failure'),
            484:(QtGui.QColor.fromRgb(136,109,137),'(484)ePKB SSA Fail Flag Fail'),
            488:(QtGui.QColor.fromRgb(137,142,45),'(488)Accelerator pedal fail flag detection diagnosis result'),
            492:(QtGui.QColor.fromRgb(138,174,209),'(492)ETC fail flag detection diagnostic result'),
            496:(QtGui.QColor.fromRgb(139,207,117),'(496)ECMCANFAIL flag diagnosis result'),
            500:(QtGui.QColor.fromRgb(140,240,25),'(500)ACC command value abnormality detection diagnosis result'),
            504:(QtGui.QColor.fromRgb(142,16,189),'(504)HCM system error'),
            508:(QtGui.QColor.fromRgb(143,49,97),'(508)ECMASCD fail flag detection'),
            510:(QtGui.QColor.fromRgb(143,193,179),'(510)Loss of lane information (Eth and CAN)'),
            511:(QtGui.QColor.fromRgb(144,9,220),'(511)Lane information reception error'),
            512:(QtGui.QColor.fromRgb(144,82,5),'(512)ECMACCINH flag diagnosis'),
            516:(QtGui.QColor.fromRgb(145,114,169),'(516)Gear position mismatch detection (AT)'),
            520:(QtGui.QColor.fromRgb(146,147,77),'(520)Gear position mismatch detection (CVT)'),
            524:(QtGui.QColor.fromRgb(147,179,241),'(524)CVT system error'),
            528:(QtGui.QColor.fromRgb(148,212,150),'(528)Rudder angle sensor abnormality diagnosis result'),
            532:(QtGui.QColor.fromRgb(149,245,58),'(532)Steering switch welding diagnosis (C1N)'),
            536:(QtGui.QColor.fromRgb(151,21,222),'(536)Steering switch logic error fail (C1N)'),
            540:(QtGui.QColor.fromRgb(152,54,130),'(540)ICC main SW welding failure (C1N)'),
            544:(QtGui.QColor.fromRgb(153,87,38),'(544)Steering switch welding diagnosis (C1A)'),
            548:(QtGui.QColor.fromRgb(154,119,202),'(548)ICC main SW welding failure (C1A)'),
            552:(QtGui.QColor.fromRgb(155,152,110),'(552)Steering switch logic error fail (C1A)'),
            556:(QtGui.QColor.fromRgb(156,185,18),'(556)METER fault diagnosis'),
            560:(QtGui.QColor.fromRgb(157,217,182),'(560)ADAS_METER communication fault diagnosis'),
            564:(QtGui.QColor.fromRgb(158,250,90),'(564)Millimeter wave radar failure diagnosis result'),
            568:(QtGui.QColor.fromRgb(160,26,254),'(568)Millimeter wave radar CAN communication abnormality diagnosis result'),
            572:(QtGui.QColor.fromRgb(161,59,162),'(572)Millimeter wave radar high temperature abnormality diagnosis result'),
            576:(QtGui.QColor.fromRgb(162,92,70),'(576)Millimeter wave radar low voltage abnormality diagnosis result'),
            580:(QtGui.QColor.fromRgb(163,124,234),'(580)Millimeter-wave radar axis misalignment abnormality diagnosis result'),
            584:(QtGui.QColor.fromRgb(164,157,142),'(584)ADAS->FrontRadar communication failure'),
            588:(QtGui.QColor.fromRgb(165,190,50),'(588)FrontRadar BackUp Mode Fail'),
            592:(QtGui.QColor.fromRgb(166,222,214),'(592)FrontRadar failure fail'),
            596:(QtGui.QColor.fromRgb(167,255,122),'(596)Camera abnormality diagnosis result'),
            600:(QtGui.QColor.fromRgb(169,32,30),'(600)Diagnosis result of unimplemented camera aiming'),
            604:(QtGui.QColor.fromRgb(170,64,194),'(604)Camera high temperature detection 1 diagnosis result'),
            608:(QtGui.QColor.fromRgb(171,97,102),'(608)ADAS->FrontCamera communication failure'),
            610:(QtGui.QColor.fromRgb(171,241,184),'(610)TSR signal communication abnormality diagnosis'),
            612:(QtGui.QColor.fromRgb(172,130,10),'(612)ADAS sub->FrontCamera communication failure'),
            616:(QtGui.QColor.fromRgb(173,162,175),'(616)FrontCamera BackUp Mode Fail'),
            620:(QtGui.QColor.fromRgb(174,195,83),'(620)FrontCamera failure fail'),
            624:(QtGui.QColor.fromRgb(175,227,247),'(624)Hands-off judgment threshold not calibrated'),
            628:(QtGui.QColor.fromRgb(177,4,155),'(628)ADASsub fault diagnosis by ADASmain'),
            632:(QtGui.QColor.fromRgb(178,37,63),'(632)AD2 Sub system fail (LK prohibited)'),
            632:(QtGui.QColor.fromRgb(178,37,63),'(632)AD2 Sub system fail (AD2 prohibited)'),
            633:(QtGui.QColor.fromRgb(178,109,104),'(633)Abnormal AVM recognition status'),
            636:(QtGui.QColor.fromRgb(179,69,227),'(636)AVM status fail'),
            644:(QtGui.QColor.fromRgb(181,135,43),'(644)SOW sensor LEFT Abnormal diagnosis result'),
            648:(QtGui.QColor.fromRgb(182,167,207),'(648)SOW sensor RIGHT Abnormal diagnosis result'),
            652:(QtGui.QColor.fromRgb(183,200,115),'(652)SOW sensor LEFT CAN unreceived diagnosis result'),
            656:(QtGui.QColor.fromRgb(184,233,23),'(656)SOW sensor RIGHT CAN unreceived diagnosis result'),
            660:(QtGui.QColor.fromRgb(186,9,187),'(660)SOW sensor LEFT Abnormal judgment 2'),
            664:(QtGui.QColor.fromRgb(187,42,95),'(664)SOW sensor RIGHT Abnormal judgment 2'),
            668:(QtGui.QColor.fromRgb(188,75,3),'(668)SOW sensor FL abnormality judgment (AD2)'),
            672:(QtGui.QColor.fromRgb(189,107,167),'(672)SOW sensor FR abnormality judgment (AD2)'),
            676:(QtGui.QColor.fromRgb(190,140,75),'(676)SOW sensor RL abnormality judgment (AD2)'),
            680:(QtGui.QColor.fromRgb(191,172,239),'(680)SOW sensor RR abnormality judgment (AD2)'),
            684:(QtGui.QColor.fromRgb(192,205,147),'(684)SOW sensor LEFT Abnormal judgment 3'),
            688:(QtGui.QColor.fromRgb(193,238,55),'(688)SOW sensor RIGHT Abnormal judgment 3'),
            692:(QtGui.QColor.fromRgb(195,14,219),'(692)Sonar anomaly detection (EAP)'),
            696:(QtGui.QColor.fromRgb(196,47,127),'(696)Sonar system failure'),
            700:(QtGui.QColor.fromRgb(197,80,35),'(700)HD-MAP error message fail'),
            704:(QtGui.QColor.fromRgb(198,112,200),'(704)HUD fault diagnosis'),
            708:(QtGui.QColor.fromRgb(199,145,108),'(708)ADAS_HUD communication fault diagnosis'),
            712:(QtGui.QColor.fromRgb(200,178,16),'(712)DMS failure'),
            716:(QtGui.QColor.fromRgb(201,210,180),'(716)DMS aiming not implemented'),
            720:(QtGui.QColor.fromRgb(202,243,88),'(720)EEM failure'),
            724:(QtGui.QColor.fromRgb(204,19,252),'(724)abnormal air pressure'),
            732:(QtGui.QColor.fromRgb(206,85,68),'(732)HOD abnormality diagnosis'),
            736:(QtGui.QColor.fromRgb(207,117,232),'(736)HOD HW anomaly'),
            738:(QtGui.QColor.fromRgb(208,6,58),'(738)HOD HW anomaly'),
            739:(QtGui.QColor.fromRgb(208,78,99),'(739)HOD HW anomaly'),
            740:(QtGui.QColor.fromRgb(208,150,140),'(740)HOD HW anomaly'),
            743:(QtGui.QColor.fromRgb(209,111,7),'(743)HOD Bus Abnormal'),
            744:(QtGui.QColor.fromRgb(209,183,48),'(744)Invalid EPS motor angle value'),
            748:(QtGui.QColor.fromRgb(210,215,212),'(748)Invalid EPSsub motor angle value'),
            752:(QtGui.QColor.fromRgb(211,248,120),'(752)EPS steering torque value invalid'),
            756:(QtGui.QColor.fromRgb(213,25,28),'(756)EPSub steering torque value invalid'),
            760:(QtGui.QColor.fromRgb(214,57,192),'(760)Abnormal brake pedal signal'),
            764:(QtGui.QColor.fromRgb(215,90,100),'(764)Brake pedal signal 2 error'),
            768:(QtGui.QColor.fromRgb(216,123,8),'(768)Abnormal brake pressure sensor signal'),
            772:(QtGui.QColor.fromRgb(217,155,172),'(772)Abnormal vehicle speed sensor signal'),
            776:(QtGui.QColor.fromRgb(218,188,80),'(776)Wheel speed pulse signal error (FL)'),
            777:(QtGui.QColor.fromRgb(219,4,121),'(777)Wheel speed pulse signal error (FR)'),
            780:(QtGui.QColor.fromRgb(219,220,244),'(780)Wheel rotation direction signal error (RL)'),
            781:(QtGui.QColor.fromRgb(220,37,29),'(781)Wheel rotation direction signal error (RR)'),
            784:(QtGui.QColor.fromRgb(220,253,152),'(784)Yaw rate sensor signal error'),
            788:(QtGui.QColor.fromRgb(222,30,60),'(788)Compensated lateral acceleration signal error'),
            792:(QtGui.QColor.fromRgb(223,62,225),'(792)Compensated longitudinal acceleration signal error'),
            796:(QtGui.QColor.fromRgb(224,95,133),'(796)Abnormal steering wheel angle signal'),
            800:(QtGui.QColor.fromRgb(225,128,41),'(800)Abnormal gear position signal'),
            804:(QtGui.QColor.fromRgb(226,160,205),'(804)Abnormal accelerator sensor signal'),
            808:(QtGui.QColor.fromRgb(227,193,113),'(808)Abnormal wiper signal'),
            812:(QtGui.QColor.fromRgb(228,226,21),'(812)Abnormal outside air temperature sensor signal'),
            816:(QtGui.QColor.fromRgb(230,2,185),'(816)Wheel rotation direction signal error (FL)'),
            820:(QtGui.QColor.fromRgb(231,35,93),'(820)Wheel rotation direction signal error (FR)'),
            832:(QtGui.QColor.fromRgb(234,133,73),'(832)Abnormal lateral acceleration signal'),
            836:(QtGui.QColor.fromRgb(235,165,237),'(836)Abnormal vehicle speed signal'),
            840:(QtGui.QColor.fromRgb(236,198,145),'(840)SW1 welding failure diagnosis result'),
            844:(QtGui.QColor.fromRgb(237,231,53),'(844)SW3 welding failure diagnosis result'),
            848:(QtGui.QColor.fromRgb(239,7,217),'(848)FEB (FCA) continuous operation upper limit diagnosis result'),
            852:(QtGui.QColor.fromRgb(240,40,125),'(852)Abnormal G sensor signal'),
            856:(QtGui.QColor.fromRgb(241,73,33),'(856)SW2 welding failure diagnosis result'),
            860:(QtGui.QColor.fromRgb(242,105,197),'(860)Rudder angular velocity signal error'),
            864:(QtGui.QColor.fromRgb(243,138,105),'(864)Wheel rotation direction signal error (EBA)'),
            868:(QtGui.QColor.fromRgb(244,171,13),'(868)Wheel speed pulse signal error (EBA)'),
            872:(QtGui.QColor.fromRgb(245,203,177),'(872)Wheel speed sensor signal error (EBA)'),
            876:(QtGui.QColor.fromRgb(246,236,85),'(876)Vehicle speed signal error (EBA)'),
            880:(QtGui.QColor.fromRgb(248,12,250),'(880)Abnormal brake information signal')}
    
    if getLocal() == 'ja_JP':
        Cancel_code_symbolDic = {
            1:(QtGui.QColor.fromRgb(1,71,83),'(1)AVMSonerFail *FAP/RPKのキャンセル要因。ADは禁止されない'),
            2:(QtGui.QColor.fromRgb(2,142,166),'(2)ECMTimeout *FAP/RPKのキャンセル要因。ADは禁止されない'),
            3:(QtGui.QColor.fromRgb(3,213,249),'(3)ECMMulfunction *FAP/RPKのキャンセル要因。ADは禁止されない'),
            4:(QtGui.QColor.fromRgb(5,29,76),'(4)UnavailATCU *FAP/RPKのキャンセル要因。ADは禁止されない'),
            5:(QtGui.QColor.fromRgb(6,100,159),'(5)UnavailAVM_IPAFAP *FAP/RPKのキャンセル要因。ADは禁止されない'),
            6:(QtGui.QColor.fromRgb(7,171,242),'(6)UnavailAVM_FAP *FAP/RPKのキャンセル要因。ADは禁止されない'),
            7:(QtGui.QColor.fromRgb(8,243,69),'(7)UnavailECM *FAP/RPKのキャンセル要因。ADは禁止されない'),
            8:(QtGui.QColor.fromRgb(10,58,152),'(8)UnavailVDC1 *FAP/RPKのキャンセル要因。ADは禁止されない'),
            9:(QtGui.QColor.fromRgb(11,129,235),'(9)UnavailVDC2 *FAP/RPKのキャンセル要因。ADは禁止されない'),
            10:(QtGui.QColor.fromRgb(12,201,63),'(10)UnavailVDC3 *FAP/RPKのキャンセル要因。ADは禁止されない'),
            11:(QtGui.QColor.fromRgb(14,16,146),'(11)UnavailCDM1 *FAP/RPKのキャンセル要因。ADは禁止されない'),
            12:(QtGui.QColor.fromRgb(15,87,229),'(12)UnavailCDM2 *FAP/RPKのキャンセル要因。ADは禁止されない'),
            13:(QtGui.QColor.fromRgb(16,159,56),'(13)UnavailEBA *FAP/RPKのキャンセル要因。ADは禁止されない'),
            14:(QtGui.QColor.fromRgb(17,230,139),'(14)UnavailBCM *FAP/RPKのキャンセル要因。ADは禁止されない'),
            16:(QtGui.QColor.fromRgb(20,117,49),'(16)低電圧時ｷｬﾝｾﾙ診断結果'),
            17:(QtGui.QColor.fromRgb(21,188,132),'(17)R-Car低優先度監視'),
            20:(QtGui.QColor.fromRgb(25,146,126),'(20)CAN未受信異常(ITS4-FD SONAR:JT1)'),
            21:(QtGui.QColor.fromRgb(26,217,209),'(21)CAN未受信異常(ITS1-FD IVI:JT2)'),
            22:(QtGui.QColor.fromRgb(28,33,36),'(22)CAN未受信異常(ITS4-FD IVI:JT2)'),
            24:(QtGui.QColor.fromRgb(30,175,202),'(24)IDM CAN異常診断結果(Type A)'),
            25:(QtGui.QColor.fromRgb(31,247,29),'(25)Path1(&bis) Steering NG'),
            26:(QtGui.QColor.fromRgb(33,62,112),'(26)Path4 Steering NG'),
            27:(QtGui.QColor.fromRgb(34,133,195),'(27)AEB（VDC ECU）機能故障診断(Type A)'),
            28:(QtGui.QColor.fromRgb(35,205,22),'(28)ICC（VDC ECU）機能故障診断(Type A)'),
            29:(QtGui.QColor.fromRgb(37,20,105),'(29)ECD(VDC ECU) 電源電圧異常(Type A)'),
            30:(QtGui.QColor.fromRgb(38,91,189),'(30)VDCシステム故障診断結果(Type A)'),
            31:(QtGui.QColor.fromRgb(39,163,16),'(31)ABSシステム故障診断結果(Type A)'),
            32:(QtGui.QColor.fromRgb(40,234,99),'(32)TCSｼｽﾃﾑ故障診断結果(Type A)'),
            33:(QtGui.QColor.fromRgb(42,49,182),'(33)VDC内LDP機能異常診断結果(Type A)'),
            34:(QtGui.QColor.fromRgb(43,121,9),'(34)車速センサ不整合故障(キャンセル：異常判断時)'),
            35:(QtGui.QColor.fromRgb(44,192,92),'(35)車輪速ｾﾝｻ不整合(ｷｬﾝｾﾙ)'),
            36:(QtGui.QColor.fromRgb(46,7,175),'(36)ACC_ENABLE_OFFキャンセル'),
            37:(QtGui.QColor.fromRgb(47,79,2),'(37)AD2_BRK_ACTR_STATUSキャンセル'),
            38:(QtGui.QColor.fromRgb(48,150,85),'(38)ePKB SSA作動可能状態フラグ キャンセル'),
            39:(QtGui.QColor.fromRgb(49,221,169),'(39)ePKB ePKB非作動'),
            39:(QtGui.QColor.fromRgb(49,221,169),'(39)ePKB系統(ﾊﾟｰｷﾝｸﾞﾌﾞﾚｰｷ異常表示)(ｷｬﾝｾﾙ)'),
            40:(QtGui.QColor.fromRgb(51,36,252),'(40)ePKB SSAフェールフラグ キャンセル'),
            41:(QtGui.QColor.fromRgb(52,108,79),'(41)ﾌﾞﾚｰｷ液圧指令値異常出力'),
            42:(QtGui.QColor.fromRgb(53,179,162),'(42)ECM ASCDｷｬﾝｾﾙ'),
            43:(QtGui.QColor.fromRgb(54,250,245),'(43)ｽﾃｱﾘﾝｸﾞ SW 論理異常キャンセル（C1N）'),
            44:(QtGui.QColor.fromRgb(56,66,72),'(44)ｽﾃｱﾘﾝｸﾞ SW 論理異常キャンセル(C1A）'),
            45:(QtGui.QColor.fromRgb(57,137,155),'(45)GセンサーUnavailableValue'),
            46:(QtGui.QColor.fromRgb(58,208,238),'(46)ﾚｰﾀﾞｰ初期化判定'),
            47:(QtGui.QColor.fromRgb(60,24,65),'(47)カメラリセットキャンセル'),
            48:(QtGui.QColor.fromRgb(61,95,148),'(48)ミリ波レーダーカメラフュージョン異常'),
            49:(QtGui.QColor.fromRgb(62,166,232),'(49)SR Alignment未調整'),
            50:(QtGui.QColor.fromRgb(63,238,59),'(50)SideRadar電圧低下'),
            51:(QtGui.QColor.fromRgb(65,53,142),'(51)初期化未了'),
            52:(QtGui.QColor.fromRgb(66,124,225),'(52)HD-MAPライセンス切れ'),
            53:(QtGui.QColor.fromRgb(67,196,52),'(53)HD-MAPエラーメッセージキャンセル'),
            55:(QtGui.QColor.fromRgb(70,82,218),'(55)EPSキャンセル'),
            56:(QtGui.QColor.fromRgb(71,154,45),'(56)AVM認識状態キャンセル'),
            57:(QtGui.QColor.fromRgb(72,225,128),'(57)ｸﾗｯﾁ不整合'),
            58:(QtGui.QColor.fromRgb(74,40,211),'(58)CDM判断によるPath使用不可通知(キャンセル)'),
            59:(QtGui.QColor.fromRgb(75,112,39),'(59)CDMからのADAS_sub(AVM)異常通知(キャンセル)'),
            80:(QtGui.QColor.fromRgb(102,73,248),'(80)ABS作動ｷｬﾝｾﾙ(w/o ACC) 診断結果'),
            80:(QtGui.QColor.fromRgb(102,73,248),'(80)ABS作動ｷｬﾝｾﾙ'),
            81:(QtGui.QColor.fromRgb(103,145,75),'(81)VDC作動ｷｬﾝｾﾙ(w/o ACC) 診断結果'),
            81:(QtGui.QColor.fromRgb(103,145,75),'(81)VDC作動ｷｬﾝｾﾙ'),
            81:(QtGui.QColor.fromRgb(103,145,75),'(81)VDC作動ｷｬﾝｾﾙ'),
            82:(QtGui.QColor.fromRgb(104,216,158),'(82)TCS作動ｷｬﾝｾﾙ'),
            82:(QtGui.QColor.fromRgb(104,216,158),'(82)TCS作動ｷｬﾝｾﾙ'),
            83:(QtGui.QColor.fromRgb(106,31,241),'(83)ABSﾗﾝﾌﾟ点灯'),
            84:(QtGui.QColor.fromRgb(107,103,68),'(84)ECM ACCキャンセル'),
            85:(QtGui.QColor.fromRgb(108,174,151),'(85)ACC禁止信号ON(ECMACCINHﾌﾗｸﾞ診断)'),
            86:(QtGui.QColor.fromRgb(109,245,234),'(86)FCA本制動作動'),
            87:(QtGui.QColor.fromRgb(111,61,61),'(87)FCA予備制動作動'),
            88:(QtGui.QColor.fromRgb(112,132,145),'(88)車間連動DBA作動ｷｬﾝｾﾙ'),
            89:(QtGui.QColor.fromRgb(113,203,228),'(89)EAP作動キャンセル'),
            90:(QtGui.QColor.fromRgb(115,19,55),'(90)CBA作動ｷｬﾝｾﾙ'),
            91:(QtGui.QColor.fromRgb(116,90,138),'(91)FAP作動キャンセル'),
            91:(QtGui.QColor.fromRgb(116,90,138),'(91)IPA作動'),
            96:(QtGui.QColor.fromRgb(122,191,41),'(96)ﾐﾘ波ﾚｰﾀﾞﾌﾞﾛｯｸ診断結果'),
            96:(QtGui.QColor.fromRgb(122,191,41),'(96)ﾐﾘ波ﾚｰﾀﾞﾌﾞﾛｯｸ診断結果(ICC)'),
            97:(QtGui.QColor.fromRgb(124,6,125),'(97)ﾐﾘ波ﾚｰﾀﾞ電波干渉診断結果'),
            98:(QtGui.QColor.fromRgb(125,77,208),'(98)SCAM3　ﾌﾙﾌﾞﾛｯｸ(Full blockage)判定診断結果'),
            99:(QtGui.QColor.fromRgb(126,149,35),'(99)SCAM3　部分ﾌﾞﾛｯｸ(Partial blockage)判定診断結果'),
            100:(QtGui.QColor.fromRgb(127,220,118),'(100)カメラYaw方向ｽﾞﾚ判定診断結果'),
            101:(QtGui.QColor.fromRgb(129,35,201),'(101)カメラPitch方向ｽﾞﾚ判定診断結果'),
            102:(QtGui.QColor.fromRgb(130,107,28),'(102)カメラﾌｫｰｶｽｽﾞﾚ判定診断結果'),
            103:(QtGui.QColor.fromRgb(131,178,111),'(103)カメラ自動補正Yaw方向閾値外判定診断結果'),
            104:(QtGui.QColor.fromRgb(132,249,194),'(104)カメラ自動補正Pitch方向閾値外判定診断結果'),
            105:(QtGui.QColor.fromRgb(134,65,21),'(105)カメラ太陽光判定診断結果'),
            106:(QtGui.QColor.fromRgb(135,136,104),'(106)カメラ悪天候判定(SCAM3)診断結果'),
            107:(QtGui.QColor.fromRgb(136,207,188),'(107)TJPｶﾒﾗ　不鮮明判定（ICC）'),
            108:(QtGui.QColor.fromRgb(138,23,15),'(108)TJPｶﾒﾗ　悪天候判定（ICC）'),
            109:(QtGui.QColor.fromRgb(139,94,98),'(109)TJPｶﾒﾗ　ｽﾌﾟﾗｯｼｭ判定（ICC）'),
            110:(QtGui.QColor.fromRgb(140,165,181),'(110)TJPｶﾒﾗ　太陽光縦線判定（ICC）'),
            111:(QtGui.QColor.fromRgb(141,237,8),'(111)TJPｶﾒﾗ　夜間霧判定（ICC）'),
            112:(QtGui.QColor.fromRgb(143,52,91),'(112)短時間太陽光判定'),
            113:(QtGui.QColor.fromRgb(144,123,174),'(113)雨判定'),
            114:(QtGui.QColor.fromRgb(145,195,1),'(114)カメラ不鮮明判定診断結果'),
            115:(QtGui.QColor.fromRgb(147,10,84),'(115)カメラスプラッシュ判定診断結果'),
            116:(QtGui.QColor.fromRgb(148,81,167),'(116)カメラ太陽光縦線判定診断結果'),
            117:(QtGui.QColor.fromRgb(149,152,251),'(117)カメラ夜間霧判定診断結果'),
            118:(QtGui.QColor.fromRgb(150,224,78),'(118)カメラ夜間雨判定診断結果'),
            119:(QtGui.QColor.fromRgb(152,39,161),'(119)カメラウィンドウ氷結判定診断結果'),
            120:(QtGui.QColor.fromRgb(153,110,244),'(120)カメラ夜間雨_M判定診断結果'),
            121:(QtGui.QColor.fromRgb(154,182,71),'(121)ｶﾒﾗﾒｯｾｰｼﾞ出力判定'),
            122:(QtGui.QColor.fromRgb(155,253,154),'(122)SideRadar電波干渉'),
            123:(QtGui.QColor.fromRgb(157,68,237),'(123)閉塞状態'),
            124:(QtGui.QColor.fromRgb(158,140,64),'(124)距離推定信頼度低下'),
            125:(QtGui.QColor.fromRgb(159,211,147),'(125)距離推定不可'),
            126:(QtGui.QColor.fromRgb(161,26,230),'(126)EEMキャンセル'),
            127:(QtGui.QColor.fromRgb(162,98,58),'(127)車線形状比較診断'),
            128:(QtGui.QColor.fromRgb(163,169,141),'(128)AVM性能低下キャンセル'),
            129:(QtGui.QColor.fromRgb(164,240,224),'(129)センサステータスキャンセル'),
            130:(QtGui.QColor.fromRgb(166,56,51),'(130)ASILD対応操舵補正作動'),
            144:(QtGui.QColor.fromRgb(184,30,190),'(144)車輪速ｾﾝｻ電磁ﾉｲｽﾞ'),
            145:(QtGui.QColor.fromRgb(185,102,17),'(145)車輪ｽﾘｯﾌﾟｷｬﾝｾﾙ'),
            145:(QtGui.QColor.fromRgb(185,102,17),'(145)車輪ｽﾘｯﾌﾟｷｬﾝｾﾙ'),
            146:(QtGui.QColor.fromRgb(186,173,101),'(146)急坂路判定'),
            147:(QtGui.QColor.fromRgb(187,244,184),'(147)ｲﾝﾁﾝｸﾞﾛｽﾄｷｬﾝｾﾙ　(クルーズ中)'),
            148:(QtGui.QColor.fromRgb(189,60,11),'(148)ｲﾝﾁﾝｸﾞﾛｽﾄｷｬﾝｾﾙ'),
            149:(QtGui.QColor.fromRgb(190,131,94),'(149)車速低下'),
            150:(QtGui.QColor.fromRgb(191,202,177),'(150)ASCD車速異常'),
            151:(QtGui.QColor.fromRgb(193,18,4),'(151)停止制御ｷｬﾝｾﾙ ロスト（ACC)'),
            152:(QtGui.QColor.fromRgb(194,89,87),'(152)停止保持制御3分経過'),
            153:(QtGui.QColor.fromRgb(195,160,170),'(153)動的ePKBｷｬﾝｾﾙ'),
            154:(QtGui.QColor.fromRgb(196,231,253),'(154)ePKB系統(ePKB制動状態)'),
            155:(QtGui.QColor.fromRgb(198,47,80),'(155)System Ready OFF ｷｬﾝｾﾙ'),
            156:(QtGui.QColor.fromRgb(199,118,164),'(156)ｴﾝｽﾄ時ｷｬﾝｾﾙ'),
            160:(QtGui.QColor.fromRgb(204,147,240),'(160)降車判断（TJP)'),
            160:(QtGui.QColor.fromRgb(204,147,240),'(160)降車判断（ACC+LKA)'),
            161:(QtGui.QColor.fromRgb(205,219,67),'(161)運転席以外のドア開時アクセル発進操作'),
            162:(QtGui.QColor.fromRgb(207,34,150),'(162)実ｷﾞﾔ・ｼﾌﾄ位置ｷｬﾝｾﾙ'),
            163:(QtGui.QColor.fromRgb(208,105,233),'(163)PKB SW ONｷｬﾝｾﾙ'),
            164:(QtGui.QColor.fromRgb(209,177,60),'(164)操作SWのﾀﾞﾌﾞﾙ押し'),
            165:(QtGui.QColor.fromRgb(210,248,144),'(165)操作,解除SW同時押し'),
            166:(QtGui.QColor.fromRgb(212,63,227),'(166)HDCONｷｬﾝｾﾙ'),
            167:(QtGui.QColor.fromRgb(213,135,54),'(167)DCTDowngradeModeキャンセル'),
            168:(QtGui.QColor.fromRgb(214,206,137),'(168)TCS(VDC) OFF SW 操作ｷｬﾝｾﾙ(ACC以外)診断結果'),
            168:(QtGui.QColor.fromRgb(214,206,137),'(168)TCS(VDC) OFF SW 操作キャンセル(ACC)診断結果'),
            169:(QtGui.QColor.fromRgb(216,21,220),'(169)FEB MAIN SW OFF診断結果'),
            170:(QtGui.QColor.fromRgb(217,93,47),'(170)ATｼﾌﾄ位置がD以外ｷｬﾝｾﾙ'),
            171:(QtGui.QColor.fromRgb(218,164,130),'(171)ETSﾓｰﾄﾞｷｬﾝｾﾙ'),
            172:(QtGui.QColor.fromRgb(219,235,213),'(172)ｵﾌﾛｰﾄﾞSWｷｬﾝｾﾙ'),
            173:(QtGui.QColor.fromRgb(221,51,40),'(173)ｽﾉｰﾓｰﾄﾞSW ONｷｬﾝｾﾙ'),
            174:(QtGui.QColor.fromRgb(222,122,123),'(174)ﾄﾞﾗｲﾊﾞｸﾗｯﾁ操作ｷｬﾝｾﾙ'),
            175:(QtGui.QColor.fromRgb(223,193,207),'(175)ブレーキ/アクセル同時操作'),
            176:(QtGui.QColor.fromRgb(225,9,34),'(176)ドライバ操舵キャンセル'),
            177:(QtGui.QColor.fromRgb(226,80,117),'(177)ﾜｲﾊﾟｰｷｬﾝｾﾙ'),
            178:(QtGui.QColor.fromRgb(227,151,200),'(178)ワイパーLo作動キャンセル'),
            179:(QtGui.QColor.fromRgb(228,223,27),'(179)ドライバ離席判断'),
            192:(QtGui.QColor.fromRgb(245,126,83),'(192)ACC MAIN SW OFFキャンセル'),
            193:(QtGui.QColor.fromRgb(246,197,166),'(193)キャンセルSW ONキャンセル'),
            194:(QtGui.QColor.fromRgb(248,12,250),'(194)ﾄﾞﾗｲﾊﾞﾌﾞﾚｰｷ操作（TJP)')}
        
    else:
        Cancel_code_symbolDic = {
            1:(QtGui.QColor.fromRgb(1,71,83),'(1)AVMSonerFail * FAP/RPK cancellation factor. AD will not prohibited'),
            2:(QtGui.QColor.fromRgb(2,142,166),'(2)ECMTimeout * FAP/RPK cancellation factor. AD will not prohibited'),
            3:(QtGui.QColor.fromRgb(3,213,249),'(3)ECMMulfunction * FAP/RPK cancellation factor. AD will not prohibited'),
            4:(QtGui.QColor.fromRgb(5,29,76),'(4)UnavailATCU * FAP/RPK cancellation factor. AD will not prohibited'),
            5:(QtGui.QColor.fromRgb(6,100,159),'(5)UnavailAVM_IPAFAP * FAP/RPK cancellation factor. AD will not prohibited'),
            6:(QtGui.QColor.fromRgb(7,171,242),'(6)UnavailAVM_FAP * FAP/RPK cancellation factor. AD will not prohibited'),
            7:(QtGui.QColor.fromRgb(8,243,69),'(7)UnavailECM * FAP/RPK cancellation factor. AD will not prohibited'),
            8:(QtGui.QColor.fromRgb(10,58,152),'(8)UnavailVDC1 * FAP/RPK cancellation factor. AD will not prohibited'),
            9:(QtGui.QColor.fromRgb(11,129,235),'(9)UnavailVDC2 * FAP/RPK cancellation factor. AD will not prohibited'),
            10:(QtGui.QColor.fromRgb(12,201,63),'(10)UnavailVDC3 * FAP/RPK cancellation factor. AD will not banned'),
            11:(QtGui.QColor.fromRgb(14,16,146),'(11)UnavailCDM1 * FAP/RPK cancellation factor. AD will not banned'),
            12:(QtGui.QColor.fromRgb(15,87,229),'(12)UnavailCDM2 * FAP/RPK cancellation factor. AD will not prohibited'),
            13:(QtGui.QColor.fromRgb(16,159,56),'(13)UnavailEBA *Cancellation factor for FAP/RPK. AD will not prohibited'),
            14:(QtGui.QColor.fromRgb(17,230,139),'(14)UnavailBCM * FAP/RPK cancellation factor. AD will not prohibited'),
            16:(QtGui.QColor.fromRgb(20,117,49),'(16)Low voltage cancellation diagnosis result'),
            17:(QtGui.QColor.fromRgb(21,188,132),'(17)R-Car low priority monitoring'),
            20:(QtGui.QColor.fromRgb(25,146,126),'(20)CAN unreceived error (ITS4-FD SONAR:JT1)'),
            21:(QtGui.QColor.fromRgb(26,217,209),'(21)CAN unreceived error (ITS1-FD IVI: JT2)'),
            22:(QtGui.QColor.fromRgb(28,33,36),'(22)CAN unreceived error (ITS4-FD IVI: JT2)'),
            24:(QtGui.QColor.fromRgb(30,175,202),'(24)IDM CAN abnormality diagnosis result (Type A)'),
            25:(QtGui.QColor.fromRgb(31,247,29),'(25)Path1(&bis) Steering NG'),
            26:(QtGui.QColor.fromRgb(33,62,112),'(26)Path4 Steering NG'),
            27:(QtGui.QColor.fromRgb(34,133,195),'(27)AEB (VDC ECU) functional fault diagnosis (Type A)'),
            28:(QtGui.QColor.fromRgb(35,205,22),'(28)ICC (VDC ECU) functional fault diagnosis (Type A)'),
            29:(QtGui.QColor.fromRgb(37,20,105),'(29)ECD (VDC ECU) Abnormal power supply voltage (Type A)'),
            30:(QtGui.QColor.fromRgb(38,91,189),'(30)VDC system fault diagnosis result (Type A)'),
            31:(QtGui.QColor.fromRgb(39,163,16),'(31)ABS system failure diagnosis result (Type A)'),
            32:(QtGui.QColor.fromRgb(40,234,99),'(32)TCS system failure diagnosis result (Type A)'),
            33:(QtGui.QColor.fromRgb(42,49,182),'(33)LDP function abnormality diagnosis result in VDC (Type A)'),
            34:(QtGui.QColor.fromRgb(43,121,9),'(34)Vehicle speed sensor mismatch failure (cancellation: when an abnormality is determined)'),
            35:(QtGui.QColor.fromRgb(44,192,92),'(35)Wheel speed sensor mismatch (cancel)'),
            36:(QtGui.QColor.fromRgb(46,7,175),'(36)ACC_ENABLE_OFF cancel'),
            37:(QtGui.QColor.fromRgb(47,79,2),'(37)AD2_BRK_ACTR_STATUS cancel'),
            38:(QtGui.QColor.fromRgb(48,150,85),'(38)ePKB SSA Ready Flag Cancel'),
            39:(QtGui.QColor.fromRgb(49,221,169),'(39)ePKB ePKB inactive'),
            39:(QtGui.QColor.fromRgb(49,221,169),'(39)ePKB system (parking brake error display) (cancel)'),
            40:(QtGui.QColor.fromRgb(51,36,252),'(40)ePKB SSA Fail Flag Cancel'),
            41:(QtGui.QColor.fromRgb(52,108,79),'(41)Brake fluid pressure command value error output'),
            42:(QtGui.QColor.fromRgb(53,179,162),'(42)ECM ASCD cancel'),
            43:(QtGui.QColor.fromRgb(54,250,245),'(43)Steering switch logic error cancel (C1N)'),
            44:(QtGui.QColor.fromRgb(56,66,72),'(44)Steering switch logic error cancel (C1A)'),
            45:(QtGui.QColor.fromRgb(57,137,155),'(45)G-sensor Unavailable Value'),
            46:(QtGui.QColor.fromRgb(58,208,238),'(46)Radar initialization judgment'),
            47:(QtGui.QColor.fromRgb(60,24,65),'(47)camera reset cancel'),
            48:(QtGui.QColor.fromRgb(61,95,148),'(48)Millimeter-wave radar camera fusion anomaly'),
            49:(QtGui.QColor.fromRgb(62,166,232),'(49)SR Alignment unadjusted'),
            50:(QtGui.QColor.fromRgb(63,238,59),'(50)SideRadar voltage drop'),
            51:(QtGui.QColor.fromRgb(65,53,142),'(51)Not initialized'),
            52:(QtGui.QColor.fromRgb(66,124,225),'(52)HD-MAP license expired'),
            53:(QtGui.QColor.fromRgb(67,196,52),'(53)HD-MAP error message cancellation'),
            55:(QtGui.QColor.fromRgb(70,82,218),'(55)EPS cancel'),
            56:(QtGui.QColor.fromRgb(71,154,45),'(56)Cancel AVM recognition status'),
            57:(QtGui.QColor.fromRgb(72,225,128),'(57)Clutch mismatch'),
            58:(QtGui.QColor.fromRgb(74,40,211),'(58)Path unusable notification (cancellation) by CDM decision'),
            59:(QtGui.QColor.fromRgb(75,112,39),'(59)ADAS_sub(AVM) error notification (cancellation) from CDM'),
            80:(QtGui.QColor.fromRgb(102,73,248),'(80)ABS operation cancellation (w/o ACC) Diagnosis result'),
            80:(QtGui.QColor.fromRgb(102,73,248),'(80)ABS operation cancel'),
            81:(QtGui.QColor.fromRgb(103,145,75),'(81)VDC operation cancellation (w/o ACC) Diagnosis result'),
            81:(QtGui.QColor.fromRgb(103,145,75),'(81)VDC operation cancel'),
            81:(QtGui.QColor.fromRgb(103,145,75),'(81)VDC operation cancel'),
            82:(QtGui.QColor.fromRgb(104,216,158),'(82)Cancel TCS operation'),
            82:(QtGui.QColor.fromRgb(104,216,158),'(82)Cancel TCS operation'),
            83:(QtGui.QColor.fromRgb(106,31,241),'(83)ABS lamp lit'),
            84:(QtGui.QColor.fromRgb(107,103,68),'(84)ECM ACC cancel'),
            85:(QtGui.QColor.fromRgb(108,174,151),'(85)ACC disable signal ON (ECMACCINH flag diagnosis)'),
            86:(QtGui.QColor.fromRgb(109,245,234),'(86)FCA main braking operation'),
            87:(QtGui.QColor.fromRgb(111,61,61),'(87)FCA pre-braking activation'),
            88:(QtGui.QColor.fromRgb(112,132,145),'(88)Inter-vehicle DBA operation cancellation'),
            89:(QtGui.QColor.fromRgb(113,203,228),'(89)EAP activation cancellation'),
            90:(QtGui.QColor.fromRgb(115,19,55),'(90)Cancel CBA operation'),
            91:(QtGui.QColor.fromRgb(116,90,138),'(91)FAP operation cancel'),
            91:(QtGui.QColor.fromRgb(116,90,138),'(91)IPA activated'),
            96:(QtGui.QColor.fromRgb(122,191,41),'(96)Millimeter-wave radar block diagnosis result'),
            96:(QtGui.QColor.fromRgb(122,191,41),'(96)Millimeter wave radar block diagnosis result (ICC)'),
            97:(QtGui.QColor.fromRgb(124,6,125),'(97)Millimeter-wave radar interference diagnostic result'),
            98:(QtGui.QColor.fromRgb(125,77,208),'(98)SCAM3 Full blockage diagnosis result'),
            99:(QtGui.QColor.fromRgb(126,149,35),'(99)SCAM3 Partial block judgment diagnosis result'),
            100:(QtGui.QColor.fromRgb(127,220,118),'(100)Camera yaw direction misalignment diagnosis result'),
            101:(QtGui.QColor.fromRgb(129,35,201),'(101)Camera Pitch Direction Deviation Judgment Diagnosis Result'),
            102:(QtGui.QColor.fromRgb(130,107,28),'(102)Camera focus deviation judgment diagnosis result'),
            103:(QtGui.QColor.fromRgb(131,178,111),'(103)Camera automatic correction Yaw direction out-of-threshold judgment diagnosis result'),
            104:(QtGui.QColor.fromRgb(132,249,194),'(104)Camera automatic correction Pitch direction out-of-threshold determination diagnostic result'),
            105:(QtGui.QColor.fromRgb(134,65,21),'(105)Camera sunlight judgment diagnosis result'),
            106:(QtGui.QColor.fromRgb(135,136,104),'(106)Camera bad weather judgment (SCAM3) diagnosis result'),
            107:(QtGui.QColor.fromRgb(136,207,188),'(107)TJP camera blurred judgment (ICC)'),
            108:(QtGui.QColor.fromRgb(138,23,15),'(108)TJP camera bad weather judgment (ICC)'),
            109:(QtGui.QColor.fromRgb(139,94,98),'(109)TJP camera splash judgment (ICC)'),
            110:(QtGui.QColor.fromRgb(140,165,181),'(110)TJP camera sunlight vertical line judgment (ICC)'),
            111:(QtGui.QColor.fromRgb(141,237,8),'(111)TJP camera nighttime fog judgment (ICC)'),
            112:(QtGui.QColor.fromRgb(143,52,91),'(112)Short time sunlight judgment'),
            113:(QtGui.QColor.fromRgb(144,123,174),'(113)rain judgment'),
            114:(QtGui.QColor.fromRgb(145,195,1),'(114)Camera blur judgment diagnosis result'),
            115:(QtGui.QColor.fromRgb(147,10,84),'(115)Camera splash judgment diagnosis result'),
            116:(QtGui.QColor.fromRgb(148,81,167),'(116)Camera sunlight vertical line judgment diagnosis result'),
            117:(QtGui.QColor.fromRgb(149,152,251),'(117)Diagnosis result of camera nighttime fog determination'),
            118:(QtGui.QColor.fromRgb(150,224,78),'(118)Diagnosis result of camera nighttime rain determination'),
            119:(QtGui.QColor.fromRgb(152,39,161),'(119)Camera window freeze judgment diagnosis result'),
            120:(QtGui.QColor.fromRgb(153,110,244),'(120)Camera night rain _M judgment diagnosis result'),
            121:(QtGui.QColor.fromRgb(154,182,71),'(121)Camera message output judgment'),
            122:(QtGui.QColor.fromRgb(155,253,154),'(122)SideRadar radio interference'),
            123:(QtGui.QColor.fromRgb(157,68,237),'(123)blockage'),
            124:(QtGui.QColor.fromRgb(158,140,64),'(124)Decrease in distance estimation reliability'),
            125:(QtGui.QColor.fromRgb(159,211,147),'(125)Distance estimation not possible'),
            126:(QtGui.QColor.fromRgb(161,26,230),'(126)EEM cancel'),
            127:(QtGui.QColor.fromRgb(162,98,58),'(127)Lane shape comparison diagnosis'),
            128:(QtGui.QColor.fromRgb(163,169,141),'(128)Cancel AVM performance degradation'),
            129:(QtGui.QColor.fromRgb(164,240,224),'(129)Sensor status cancel'),
            130:(QtGui.QColor.fromRgb(166,56,51),'(130)Steering correction operation for ASILD'),
            144:(QtGui.QColor.fromRgb(184,30,190),'(144)Wheel speed sensor electromagnetic noise'),
            145:(QtGui.QColor.fromRgb(185,102,17),'(145)wheel slip cancel'),
            145:(QtGui.QColor.fromRgb(185,102,17),'(145)wheel slip cancel'),
            146:(QtGui.QColor.fromRgb(186,173,101),'(146)Steep slope judgment'),
            147:(QtGui.QColor.fromRgb(187,244,184),'(147)Inching Lost Cancellation (during cruise)'),
            148:(QtGui.QColor.fromRgb(189,60,11),'(148)Inching Lost Cancel'),
            149:(QtGui.QColor.fromRgb(190,131,94),'(149)Decrease in vehicle speed'),
            150:(QtGui.QColor.fromRgb(191,202,177),'(150)ASCD vehicle speed error'),
            151:(QtGui.QColor.fromRgb(193,18,4),'(151)Stop control cancel lost (ACC)'),
            152:(QtGui.QColor.fromRgb(194,89,87),'(152)Stop hold control 3 minutes elapsed'),
            153:(QtGui.QColor.fromRgb(195,160,170),'(153)Dynamic ePKB cancellation'),
            154:(QtGui.QColor.fromRgb(196,231,253),'(154)ePKB system (ePKB braking state)'),
            155:(QtGui.QColor.fromRgb(198,47,80),'(155)System Ready OFF Cancel'),
            156:(QtGui.QColor.fromRgb(199,118,164),'(156)Cancel at engine stall'),
            160:(QtGui.QColor.fromRgb(204,147,240),'(160)Driver getting off judgment (TJP)'),
            160:(QtGui.QColor.fromRgb(204,147,240),'(160)Driver getting off judgment (ACC+LKA)'),
            161:(QtGui.QColor.fromRgb(205,219,67),'(161)Accelerator start operation when the door other driver seat is opened'),
            162:(QtGui.QColor.fromRgb(207,34,150),'(162)Actual gear/shift position cancel'),
            163:(QtGui.QColor.fromRgb(208,105,233),'(163)PKB SW ON cancel'),
            164:(QtGui.QColor.fromRgb(209,177,60),'(164)Double press of operation switch'),
            165:(QtGui.QColor.fromRgb(210,248,144),'(165)Simultaneous press of operation and release switches'),
            166:(QtGui.QColor.fromRgb(212,63,227),'(166)HDCON cancel'),
            167:(QtGui.QColor.fromRgb(213,135,54),'(167)DCTDowngradeMode Cancel'),
            168:(QtGui.QColor.fromRgb(214,206,137),'(168)TCS(VDC) OFF SW Operation cancellation (other than ACC) diagnosis result'),
            168:(QtGui.QColor.fromRgb(214,206,137),'(168)TCS(VDC) OFF SW Operation cancel (ACC) diagnosis result'),
            169:(QtGui.QColor.fromRgb(216,21,220),'(169)FEB MAIN SW OFF diagnosis result'),
            170:(QtGui.QColor.fromRgb(217,93,47),'(170)Cancel AT shift position other than D'),
            171:(QtGui.QColor.fromRgb(218,164,130),'(171)ETS mode cancel'),
            172:(QtGui.QColor.fromRgb(219,235,213),'(172)Off-road switch cancel'),
            173:(QtGui.QColor.fromRgb(221,51,40),'(173)Snow mode SW ON cancel'),
            174:(QtGui.QColor.fromRgb(222,122,123),'(174)Driver clutch operation cancellation'),
            175:(QtGui.QColor.fromRgb(223,193,207),'(175)Brake/accelerator simultaneous operation'),
            176:(QtGui.QColor.fromRgb(225,9,34),'(176)driver steering cancel'),
            177:(QtGui.QColor.fromRgb(226,80,117),'(177)wiper cancel'),
            178:(QtGui.QColor.fromRgb(227,151,200),'(178)Wiper Low operation cancellation'),
            179:(QtGui.QColor.fromRgb(228,223,27),'(179)Judgment of driver leaving seat'),
            192:(QtGui.QColor.fromRgb(245,126,83),'(192)ACC MAIN SW OFF Cancel'),
            193:(QtGui.QColor.fromRgb(246,197,166),'(193)Cancel SW ON Cancel'),
            194:(QtGui.QColor.fromRgb(248,12,250),'(194)Driver brake operation (TJP)')}

    if getLocal() == 'ja_JP':
        The_reason_that_Hands_off_is_prohibited_Dic = [[64, 1088, 1345, 1536, 2048, 2208, 2560, 3072, 3584, 3648, 3712, 4095],
                                                       ['', 'HandsOff禁止-故障系','HandsOff禁止-システム異常系','HandsOff禁止-道路環境系','HandsOff禁止-システム介入系',
                                                        'HandsOff禁止-センサ性能低下系','HandsOff禁止-性能限界系','HandsOff禁止-車両状態系','HandsOff禁止-ドライバ操作(ブザーあり)系',
                                                        'HandsOff禁止-ドライバ操作(ブザーなし)系','HandsOff禁止-ドライバ要因系','HandsOff禁止-AutoLC系','Hands off禁止要因なし']]
    else:
        The_reason_that_Hands_off_is_prohibited_Dic = [[64, 1088, 1345, 1536, 2048, 2208, 2560, 3072, 3584, 3648, 3712, 4095],
                                                       ['', 'HandsOff Prohibit(defect)','HandsOff Prohibit(system error)','HandsOff Prohibit(load condition)','HandsOff Prohibit(system intervention)',
                                                        'HandsOff Prohibit(low sensor reliability)','HandsOff Prohibit(performance)','HandsOff Prohibit(vehicle condition)','HandsOff Prohibit(driver control with buzzer)',
                                                        'HandsOff Prohibit(driver control w/o buzzer)','HandsOff Prohibit(driver)','HandsOff Prohibit(AutoLC)','Hands off Prohibit(no reason)']]
        
    RDRinfo_symbolDic = {
             1:(QtGui.QColor.fromRgb(255,0,255),'Winker'),
             2:(QtGui.QColor.fromRgb(255,0,255),'P2P_state'),
             3:(QtGui.QColor.fromRgb(255,0,255),'Consistency_between_camera_vision_and_hdmap'),
             4:(QtGui.QColor.fromRgb(255,0,255),'Status_of_data_receiving_from_IVI'),
             5:(QtGui.QColor.fromRgb(255,0,255),'Linkage_status_between_SDmap_and_HDmap'),
             6:(QtGui.QColor.fromRgb(255,0,255),'Status_transition_of_ADAS'),
             7:(QtGui.QColor.fromRgb(255,0,255),'Wiper_mode'),
             8:(QtGui.QColor.fromRgb(255,0,255),'Check_latest_version'),
             9:(QtGui.QColor.fromRgb(255,0,255),'P2P_giveup_information'),
            10:(QtGui.QColor.fromRgb(255,0,255),'AD2_emergency_stop_flag'),
            11:(QtGui.QColor.fromRgb(255,0,255),'License_state'),
            12:(QtGui.QColor.fromRgb(255,0,255),'Deviation_warning'),
            13:(QtGui.QColor.fromRgb(255,0,255),'Approch_warning'),
            14:(QtGui.QColor.fromRgb(255,0,255),'LDP_BSI_operation_status'),
            15:(QtGui.QColor.fromRgb(255,0,255),'Steering_SW'),
            16:(QtGui.QColor.fromRgb(255,0,255),'Hands_on_demand_reason_from_Lateral'),
            17:(QtGui.QColor.fromRgb(255,0,255),'Wide_control_permission_judgment_in_the_map_information'),
            18:(QtGui.QColor.fromRgb(255,0,255),'Hands_off_permission_condition'),
            19:(QtGui.QColor.fromRgb(255,0,255),'EDR_Trigger'),
            20:(QtGui.QColor.fromRgb(255,0,255),'The_reason_that_Hands_off_is_prohibited'),
            21:(QtGui.QColor.fromRgb(255,0,255),'HDMAP_output_situation'),
            22:(QtGui.QColor.fromRgb(255,0,255),'Lane_recommendation_degree_MapECU'),
            23:(QtGui.QColor.fromRgb(255,0,255),'Lane_recommendation_degree_MakeLabel'),
            24:(QtGui.QColor.fromRgb(255,0,255),'LC cancellation reason')}
    
    AD_status_symbolDic = {
         0:(QtGui.QColor.fromRgb(200,200,200),'AD OFF'),
         1:(QtGui.QColor.fromRgb(100,255,100),'AD1'),
         2:(QtGui.QColor.fromRgb(100,100,255),'AD2')}
    
    HDMAP_freshness_symbolDic = {
         0:(QtGui.QColor.fromRgb(255,255,255),'(0) New'),
         1:(QtGui.QColor.fromRgb(0,0,0),'(1) Old')}
    
    WithWithoutHDMAP_symbolDic = {
         0:(QtGui.QColor.fromRgb(0,0,0),'(0) Invalid'),
         1:(QtGui.QColor.fromRgb(255,255,0),'(1) Valid')}
    
    LaneProjectionState_symbolDic = {
         0:(QtGui.QColor.fromRgb(0,0,0),'(0) OFF'),
         1:(QtGui.QColor.fromRgb(0,0,255),'(1) ON')}
    
    Wide_control_state_symbolDic = {
         0:(QtGui.QColor.fromRgb(0,0,0),'(0) OFF'),
         1:(QtGui.QColor.fromRgb(50,100,250),'(1) AD2 StabilityPermit'),
         2:(QtGui.QColor.fromRgb(50,250,100),'(2) map valid'),
         3:(QtGui.QColor.fromRgb(100,100,250),'(3) control point Hdmap'),
         4:(QtGui.QColor.fromRgb(100,250,100),'(4) LKA Active'),
         5:(QtGui.QColor.fromRgb(250,100,250),'(5) SteerCntrol2'),
         6:(QtGui.QColor.fromRgb(250,250,100),'(6) DivergingCondiOn'),
         7:(QtGui.QColor.fromRgb(50,50,250),'(7) lka_com_irregular_LC')}
    
    Long_control_state_symbolDic = {
         0:(QtGui.QColor.fromRgb(50,50,50),'(0) Temp'),
         1:(QtGui.QColor.fromRgb(50,50,100),'(1) Normal Status'),
         2:(QtGui.QColor.fromRgb(50,50,250),'(2) Brake Fail'),
         3:(QtGui.QColor.fromRgb(50,100,50),'(3) Cancel Status'),
         4:(QtGui.QColor.fromRgb(50,100,100),'(4) Wait Status'),
         5:(QtGui.QColor.fromRgb(50,100,250),'(5) Override Status'),
         6:(QtGui.QColor.fromRgb(50,250,50),'(6) Reserve'),
         7:(QtGui.QColor.fromRgb(50,250,100),'(7) Fail Status'),
         8:(QtGui.QColor.fromRgb(50,250,250),'(8) Off Status'),
         9:(QtGui.QColor.fromRgb(100,50,50),'(9) Reset Status'),
         10:(QtGui.QColor.fromRgb(100,50,100),'(10) Gear Shift Status'),
         11:(QtGui.QColor.fromRgb(100,50,250),'(11) Over taking Status'),
         12:(QtGui.QColor.fromRgb(100,100,50),'(12) Stop Status'),
         13:(QtGui.QColor.fromRgb(100,100,250),'(13) Brake FF Start'),
         14:(QtGui.QColor.fromRgb(100,250,50),'(14) Brake FF End'),
         15:(QtGui.QColor.fromRgb(100,250,100),'(15) Brake Cancel')}
    
    AF_Camera_unstable_symbolDic = {
         1:(QtGui.QColor.fromRgb(0,0,0),'(1) restricted')}
    
    AF_MAP_freshness_symbolDic = {
         1:(QtGui.QColor.fromRgb(150,0,205),'(1) Inhibit Auto L/C'),
         2:(QtGui.QColor.fromRgb(0,255,0),'(2) Inhibit AD2')}
    
    AF_Dependancy_of_road_symbolDic = {
         1:(QtGui.QColor.fromRgb(50,50,50),'(1) Inhibit exit'),
         2:(QtGui.QColor.fromRgb(250,50,50),'(2) Inhibit Auto L/C'),
         3:(QtGui.QColor.fromRgb(250,50,100),'(3) Inhibit Hands OFF in high speed'),
         4:(QtGui.QColor.fromRgb(250,50,250),'(4) Inhibit Hands OFF'),
         5:(QtGui.QColor.fromRgb(250,100,50),'(5) Inhibit HDMAP LK'),
         6:(QtGui.QColor.fromRgb(250,100,100),'(6) Inhibit LK')}
    
    AF_Dependancy_of_software_symbolDic = {
         1:(QtGui.QColor.fromRgb(50,50,50),'(1) Inhibit exit'),
         2:(QtGui.QColor.fromRgb(250,50,50),'(2) Inhibit Auto L/C'),
         3:(QtGui.QColor.fromRgb(250,50,100),'(3) Inhibit Hands OFF'),
         4:(QtGui.QColor.fromRgb(250,50,250),'(4) Inhibit HDMAP LK'),
         5:(QtGui.QColor.fromRgb(250,100,50),'(5) Inhibit LK')}
    
    AF_Type_of_construction_symbolDic = {
         1:(QtGui.QColor.fromRgb(50,50,50),'(1) In construction'),
         2:(QtGui.QColor.fromRgb(250,50,50),'(2) 120㎞ division'),
         3:(QtGui.QColor.fromRgb(250,50,100),'(3) Other type'),
         4:(QtGui.QColor.fromRgb(250,50,250),'(4) Other')}
    
    GPS_symbolDic = {
         0:(QtGui.QColor.fromRgb(250,000,000),'< 1 m'),
         1:(QtGui.QColor.fromRgb(230,000,000),'< 2 m'),
         2:(QtGui.QColor.fromRgb(210,000,000),'< 3 m'),
         3:(QtGui.QColor.fromRgb(190,000,000),'< 4 m'),
         4:(QtGui.QColor.fromRgb(170,000,000),'< 5 m'),
         5:(QtGui.QColor.fromRgb(150,000,000),'< 6 m'),
         6:(QtGui.QColor.fromRgb(130,000,000),'< 7 m'),
         7:(QtGui.QColor.fromRgb(110,000,000),'< 8 m'),
         8:(QtGui.QColor.fromRgb(90,000,000),'< 9 m'),
         9:(QtGui.QColor.fromRgb(70,000,000),'< 10 m'),
         10:(QtGui.QColor.fromRgb(50,000,000),'< 11 m'),
         11:(QtGui.QColor.fromRgb(30,000,000),'< 12 m'),
         12:(QtGui.QColor.fromRgb(10,000,000),'< 13 m')}
    
    WinkerInfoDic = {1:'Turn SW Left is ON', 2:'Turn SW Right is ON'}
    P2PStateDic = {0:'P2P OFF', 1:'P2P ON'}
    P2PGiveupDic = {2: 'Give up to go to recommended lane'}
    
    if getLocal() == 'ja_JP':
        LC_cancellation_reason_Dic = {0:'LCキャンセルなし', 1:'道路形状が理由で出るべき分岐に対し分岐Seqをやらない', 2:'隣接車両検知', 3:'P2P GiveUp', 4:'LC車速範囲外', 5:'左右両側車線変更不可の道路形状区間'}
    else:
        LC_cancellation_reason_Dic = {0:'Not happened LC cancel', 1:'Cancel LC to exit lane sequence, cause of road shapes', 2:'Detected nearby vehicle', 3:'P2P GiveUp', 4:'LC Out of vehicle speed limit', 5:'Left right both lane borderline was prohibited lane change line area'}
        
    Consistency_between_camera_vision_and_hdmap_Dic = {0:'CAM Invalid', 1:'CAM Intermediate', 2:'CAM Not used', 3:'CAM Valid'}
    Status_of_data_receiving_from_IVI_Dic = {0: 'IVIData Normal', 1: 'IVIData Failure'}
    Linkage_status_between_SDmap_and_HDmap_Dic = {0: 'Not yet linkaged', 1: 'Linkage suceed', 2: 'Linkage failed'}
    Status_transition_of_ADAS_Dic = {0: 'SafetyShieldOff', 10: 'SafetyShieldOn', 11: 'ICCStandby', 20: 'ICCOn_lat_inh', 21: 'ICCOn_lat_allowed', 22: 'ICCOffNotice', 30: 'HandsOffProhibited', 31: 'HandsOff_Alert', 
                                     32: 'SteerReqHandsOn', 33: 'PreTD_AD1', 34: 'TD_AD1', 35: 'MRM_AD1', 37: 'HandsOnReqLC1', 38: 'HandsOffProhibitedLC', 39: 'HandsOffAlertLC', 40: 'HandsOffAllowed',
                                     41: 'DM1', 42: 'HandsOnReqLC', 43: 'HandsOnReq', 44: 'SteerReq', 45: 'PreTD', 50: 'TD', 51: 'TDwithBrake', 60: 'MRM_AD2'}
    Wiper_mode_low_Dic = {0x00: 'Low Inactive', 0x01: 'Low Active'}
    Wiper_mode_high_Dic = {0x00: 'High Inactive', 0x02: 'High Active'}
    Check_latest_version_Dic = {0: '(HDMAP-Version-Check) Latest version', 1: '(HDMAP-Version-Check) Not latest version'}
    AD2_emergency_stop_flag_Dic = {1: 'AD2 emergency stop'}
    License_state_Dic = {0: 'License Available', 1: 'License Unavailable'}
    Deviation_warning_Dic = {1: 'Deviation warning ON'}
    Approch_warning_Dic = {1: 'Approach warning ON'}
    LDP_BSI_operation_status_Dic = {1: 'LDP/BSI under operation'}
    Steering_SW_Dic = {1: 'MainSw ON', 2: 'SetButton ON', 3: 'ResumeButton ON', 4: 'CancelButton ON', 5: 'DistButton ON', 6: 'ALCButton ON', 
                       7: 'Set ON', 8: 'Resume/- ON', 9: 'Resume/+ ON', 10: 'Resume/++ ON'}
    Hands_on_demand_reason_from_Lateral_Dic = {1:'Hdmap use', 2: 'approacing_to_CAM_unstable_area', 3: 'approacing_to_Exit_recog_incorrect', 4: 'nolane_inc_approaching_warning', 5: 'lanewidth_extend',
                                               6: 'HandsOffInh_LowServoGain', 7: 'nolane_dec_approaching_warning', 8:'AD2InhByLostInIntWiper'}
    Wide_control_permission_judgment_in_the_map_information_Dic = {1: 'Wide control ON by map'}
    Hands_off_permission_condition_Dic_0 =  {0: '(HD-map-unavailable) Available', 0x0001: '(HD-map-unavailable) Unavailable'}
    Hands_off_permission_condition_Dic_1 =  {0x0002: '(TD-Condition-happen) TD Condition'}
    Hands_off_permission_condition_Dic_2 =  {0x0004: '(Steer-Request-happen) Request'}
    Hands_off_permission_condition_Dic_3 =  {0x0008: '(HandsOn-Request-happen) Request'}
    Hands_off_permission_condition_Dic_4 =  {0: '(AutoLC-active) Not active', 0x0010: '(AutoLC-active) Active'}
    Hands_off_permission_condition_Dic_5 =  {0x0020: '(small-curve-detect) Detect'}
    Hands_off_permission_condition_Dic_6 =  {0: '(Map-Information-none) Exist', 0x0040: '(Map-Information-none) None'}
    Hands_off_permission_condition_Dic_7 =  {0: '(LK-inhibited-Area-by-Map-Info) Not inhibitited', 0x0080: '(LK-inhibited-Area-by-Map-Info) Inhibited'}
    Hands_off_permission_condition_Dic_8 =  {0x0100: '(Marge-area-is-less-than-50m) Less than 50m'}
    Hands_off_permission_condition_Dic_9 =  {0: '(LDP-active) Not active', 0x0200: '(LDP-active) Active'}
    Hands_off_permission_condition_Dic_10 = {0: '(LK-Gain-under-0.95) Not under 0.95', 0x0400: '(LK-Gain-under-0.95) Under 0.95'}
    Hands_off_permission_condition_Dic_11 = {0: '(IVI-Invalid-Position) Valid', 0x0800: '(IVI-Invalid-Position) Invalid'}
    Hands_off_permission_condition_Dic_12 = {0x1000: '(Main-Road-is-less-than-1.3km) Less than 1.3km'}
    Hands_off_permission_condition_Dic_13 = {0x2000: '(AD2-inhibit-by-FailSafe) Inhibit'}
    Hands_off_permission_condition_Dic_14 = {0x4000: '(Junction-or-Ramp-or-Other) Either'}
    Hands_off_permission_condition_Dic_15 = {0x8000: '(Branch-Area-is-less-than-30m) Less than 30m'}
    HDMAP_output_situation_Dic_0 = {0: '(IVI route) Less than 900m', 0x0001: '(IVI route) Not less than 900m'}
    HDMAP_output_situation_Dic_1 = {0: '(AD route) Less than 900m', 0x0002: '(AD route) Not less than 900m'}
    HDMAP_output_situation_Dic_2 = {0: '(MPU route) Less than 900m', 0x0004: '(MPU route) Not less than 900m'}
    
    Lane_recommendation_degree_MapECU_Dic = {0: 'Invalid', 1: 'Out from recommended route', 2: 'On Not-recommended lane', 3: 'On recommended lane'}
    Lane_recommendation_degree_MakeLabel_Dic_0 = {0x0: 'Invalid', 0x1: 'Disable to go straight', 0x2: 'Not recommend to go straight', 0x3: 'Recommended to go straight'}
    Lane_recommendation_degree_MakeLabel_Dic_2 = {0x0: 'Invalid', 0x4: 'Disable to go left lane', 0x8: 'Not recommend to go left lane', 0xc: 'Recommended to go left lane'}
    Lane_recommendation_degree_MakeLabel_Dic_4 = {0x00: 'Invalid', 0x10: 'Disable to go right lane', 0x20: 'Not recommend to go right lane', 0x30: 'Recommended to go right lane'}
                                                
    EDR_Trigger_Dic = {0x01: 'Detect Air bag', 0x02: 'Detect Sudden Brake', 0x04: 'Detect defect', 0x08: 'Detect Front Collision Avoidance',
                       0x10: 'Detect Brake Alarm', 0x20: 'Detect Sudden Stopping Gravity', 0x40: 'Detect Sudden Turn'}
    
    Gamma_OnOffDic = CaseInsensitiveDict({'OFF':0, 'ON':1})
    Gamma_YesNoDic = CaseInsensitiveDict({'No':0, 'Yes':1})
    Gamma_OKNGDic = CaseInsensitiveDict({'NG':0, 'OK':1})
    Gamma_ActiveInactiveDic = CaseInsensitiveDict({'Inactive':0, 'Active':1})
    Gamma_ValidInvalidDic = CaseInsensitiveDict({'Invalid':0, 'Valid':1, 'Inalid':0})
    Gamma_AvailableUnavailableDic = CaseInsensitiveDict({'Unavailable':0, 'Available':1})
    
    Gamma_OnOffDic_reverse = CaseInsensitiveDict({'OFF':1, 'ON':0})
    Gamma_YesNoDic_reverse = CaseInsensitiveDict({'No':1, 'Yes':0})
    Gamma_OKNGDic_reverse = CaseInsensitiveDict({'NG':1, 'OK':0})
    Gamma_ActiveInactiveDic_reverse = CaseInsensitiveDict({'Inactive':1, 'Active':0})
    Gamma_ValidInvalidDic_reverse = CaseInsensitiveDict({'Invalid':1, 'Valid':0, 'Inalid':1})
    Gamma_AvailableUnavailableDic_reverse = CaseInsensitiveDict({'Unavailable':1, 'Available':0})
    
    Gamma_Status_transition_of_ADAS_Dic = CaseInsensitiveDict({'SafetyShieldOff':0, 'SafetyShieldOn':10, 'ICCStandby':11, 'ICCOn_lat_inh':20, 'ICCOn_lat_allowed':21, 'ICCOffNotice':22,
                                        'HandsOffProhibited':30, 'HandsOff_Alert':31, 'SteerReqHandsOn':32, 'PreTD_AD1':33, 'TD_AD1':34, 'MRM_AD1':35, 'HandsOnReqLC1':37, 'HandsOffProhibitedLC':38, 'HandsOffAlertLC':39,
                                        'HandsOffAllowed':40, 'DM1':41, 'HandsOnReqLC':42, 'HandsOnReq':43, 'SteerReq':44, 'PreTD':45,
                                        'TD':50, 'TDwithBrake':51, 'MRM_AD2':60, 'No match':63})
    Gamma_WinkerInfoDic = CaseInsensitiveDict({'Turn SW Left Right are OFF':0, 'Turn SW Left is ON':1, 'Turn SW Right is ON':2, 'Null':3})
    Gamma_Consistency_between_camera_vision_and_hdmap_Dic = CaseInsensitiveDict({'Invalid':0, 'Intermediate':1, 'Not used':2, 'Valid':3})
    Gamma_Status_of_data_receiving_from_IVI_Dic = CaseInsensitiveDict({'Normal':0, 'Failure':1})
    Gamma_Linkage_status_between_SDmap_and_HDmap_Dic = CaseInsensitiveDict({'Not yet linkaged':0, 'Linkage suceed':1, 'Linkage failed':2, 'No match':3})
    Gamma_Check_latest_version_Dic = CaseInsensitiveDict({'Latest version':0, 'Not latest version':1})
    Gamma_Deviation_warning_Dic = CaseInsensitiveDict({'OFF':0, 'Deviation warning ON':1})
    Gamma_Approch_warning_Dic = CaseInsensitiveDict({'OFF':0, 'Approach warning ON':1})
    Gamma_PKB_control_command_Dic = CaseInsensitiveDict({'OFF':0, 'PKB control command ON':1})
    Gamma_LDP_BSI_operation_status_Dic = CaseInsensitiveDict({'OFF':0, 'LDP/BSI under operation':1})
    Gamma_Brake_lamp_command_Dic = CaseInsensitiveDict({'OFF':0, 'Brake lamp command ON':1})
    Gamma_Steering_SW_Dic = CaseInsensitiveDict({
        'All SW OFF':0, 'MainSw ON':1, 'SetButton ON':2, 'ResumeButton ON':3, 'CancelButton ON':4, 
        'DistButton ON':5, 'ALCButton ON':6, 'Set ON':7, 'Resume/- ON':8, 'Resume/+ ON':9, 'Resume/++ ON':10, 
        'No match':15})
    Gamma_Hands_on_demand_reason_from_Lateral_Dic = CaseInsensitiveDict({'Normal':0, 'Hdmap use':1, 'approacing_to_CAM_unstable_area':2, 'approacing_to_Exit_recog_incorrect':3,
                                                    'nolane_inc_approaching_warning':4, 'lanewidth_extend':5, 'HandsOffInh_LowServoGain':6,
                                                    'nolane_dec_approaching_warning':7, 'AD2InhByLostInIntWiper':8, 'No match':15})
    Gamma_Hands_off_permission_condition_Dic_0 = CaseInsensitiveDict({'Available':0, 'Unavailable':1})
    Gamma_Hands_off_permission_condition_Dic_1 = CaseInsensitiveDict({'No TD Condition':0 , 'TD Condition':1})
    Gamma_Hands_off_permission_condition_Dic_2 = CaseInsensitiveDict({'No request':0, 'Request':1})
    Gamma_Hands_off_permission_condition_Dic_3 = CaseInsensitiveDict({'No request':0, 'Request':1})
    Gamma_Hands_off_permission_condition_Dic_4 = CaseInsensitiveDict({'Not active':0, 'Active':1})
    Gamma_Hands_off_permission_condition_Dic_5 = CaseInsensitiveDict({'No detect':0, 'Detect':1})
    Gamma_Hands_off_permission_condition_Dic_6 = CaseInsensitiveDict({'Exist':0, 'None':1})
    Gamma_Hands_off_permission_condition_Dic_7 = CaseInsensitiveDict({'Not inhibitited':0, 'inhibitited':1})
    Gamma_Hands_off_permission_condition_Dic_8 = CaseInsensitiveDict({'Not less than 50m':0, 'Less than 50m':1})
    Gamma_Hands_off_permission_condition_Dic_9 = CaseInsensitiveDict({'Not active':0, 'Active':1})
    Gamma_Hands_off_permission_condition_Dic_10 = CaseInsensitiveDict({'Not under 0.95':0, 'Under 0.95':1})
    Gamma_Hands_off_permission_condition_Dic_11 = CaseInsensitiveDict({'Valid':0, 'Invalid':1})
    Gamma_Hands_off_permission_condition_Dic_12 = CaseInsensitiveDict({'Not less than 1.3km':0, 'Less than 1.3km':1})
    Gamma_Hands_off_permission_condition_Dic_13 = CaseInsensitiveDict({'No inhibit':0, 'Inhibit':1})
    Gamma_Hands_off_permission_condition_Dic_14 = CaseInsensitiveDict({'None':0, 'Either':1})
    Gamma_Hands_off_permission_condition_Dic_15 = CaseInsensitiveDict({'Not less than 30m':0, 'Less than 30m':1})
    Gamma_Privacy_mode_Dic = CaseInsensitiveDict({'Normal Mode':0, 'Privacy Mode':1})
    Gamma_Detection_of_hands_on_by_Steering_torque_Dic = CaseInsensitiveDict({'Hands Off':0, 'Hands On':1})
    Gamma_Presence_absence_of_camera_correction_information_Dic = CaseInsensitiveDict({'OFF':0, 'Camera correction ON':1})
    Gamma_Navi_settings_Traffic_signs_recognition_Dic = CaseInsensitiveDict({'OFF':0, 'Auto':2, 'Manual':3})
    Gamma_Navi_settings_TSR_vehicle_speed_adjustment_Dic = CaseInsensitiveDict({'---':0, '-10':1, '-5':2, '0':3, '5':4, '10':5, 'Not used':6, 'No match':7})
    Gamma_Sheet_belt_Dic = CaseInsensitiveDict({'sheet belt buckle switch on':0, 'sheet belt buckle switch off':1})
    Gamma_Shift_position_Dic = CaseInsensitiveDict({'P':0, 'R':1, 'N':2, 'D':3})
    Gamma_Switch_of_door_Dic = CaseInsensitiveDict({'Closed':0, 'Open':1})
    Gamma_Turn_signal_switch_Dic = CaseInsensitiveDict({'OFF':0, '3Flasher Left':1, 'Lock Left':2, '3Flasher Right':3, 'Lock Right':4, 'No match':7})
    Gamma_Engine_RPM_Dic = CaseInsensitiveDict({'Engin OFF':0, 'Engin ON':1})
    Gamma_Closure_status_of_eye_Dic = CaseInsensitiveDict({'invalid':0, 'Open':1, 'Close':2, 'Undefined':3})
    Gamma_Sleepiness_Dic = CaseInsensitiveDict({'Normal':0, 'Continuous open':1, 'Continuous close':2, 'Not used':3, 'No match':3})
    Gamma_DMS1_Multiple_face_detection_Dic = CaseInsensitiveDict({'Under 1 people':0, 'More than 2 people':1})
    Gamma_Motion_status_Dic = CaseInsensitiveDict({'NONE':0, 'STANDING':1, 'STOPPED':2, 'MOVING':3, 'ONCOME':4, 'CROSS':5, 'FALSE':6, 'No match':7})
    Gamma_Camera_motion_status_Dic = CaseInsensitiveDict({'UNDECIDED':0, 'STANDING':1, 'PARKED':2, 'STOPPED':3, 'MOVABLE':4, 'MOVING':5, 'STOPPED_ON_COM':6, 'UNKNOWN_ON_COM':7, 'MOVING_ON_COM':8, 'CROSS_BICYCLE':9, 'No match':15})
    Gamma_ON_OFF_of_driver_brakes_working_conditions_Dic = CaseInsensitiveDict({'Brake pedal not pressed':0, 'Brake pedal pressed':1})
    Gamma_PKB_control_state_Dic = CaseInsensitiveDict({'Released':0, 'Applying':1, 'Releasing':2, 'Applied':3})
    Gamma_Own_car_position_reliability_flag_information_Dic_0 = CaseInsensitiveDict({'No restricted':0, 'restricted':1})
    Gamma_Own_car_position_reliability_flag_information_Dic_1 = CaseInsensitiveDict({'No restricted':0, 'Inhibit Auto L/C':1, 'Inhibit HDMAP LK':2, 'Reserve':3, 'No match':3})
    Gamma_Own_car_position_reliability_flag_information_Dic_3 = CaseInsensitiveDict({'No restricted':0, 'Inhibit exit':1, 'Inhibit Auto L/C':2, 'Inhibit Hands OFF in high speed':3, 'Inhibit Hands OFF':4, 'Inhibit HDMAP LK':5, 'Inhibit LK':6, 'Reserve':7, 'No match':7})
    Gamma_Own_car_position_reliability_flag_information_Dic_6 = CaseInsensitiveDict({'No restricted':0, 'Inhibit exit':1, 'Inhibit Auto L/C':2, 'Inhibit Hands OFF':3, 'Inhibit HDMAP LK':4, 'Inhibit LK':5, 'Reserve':6, 'No match':7})
    Gamma_Own_car_position_reliability_flag_information_Dic_16 = CaseInsensitiveDict({'No restricted':0, 'In construction':1, '120㎞ division':2, 'Other type':3, 'Other':4, 'No match':7})
    Gamma_Wide_control_internal_control_state_Dic = CaseInsensitiveDict({'OFF':0, 'AD2 StabilityPermit':1, 'map valid':2, 'control point Hdmap':3, 'LKA Active':4, 'SteerCntrol2':5, 'DivergingCondiOn':6, 'lka_com_irregular_LC':7})
    Gamma_Long_control_internal_control_state_Dic = CaseInsensitiveDict({'Temp':0, 'Normal Status':1, 'Brake Fail':2, 'Cancel Status':3, 'Wait Status':4, 'Override Status':5, 'Fail Status':7, 'Off Status':8, 'Reset Status':9, 'Gear Shift Status':10, 'Over taking Status':11, 'Stop Status':12, 'Brake FF Start':13, 'Brake FF End':14, 'Brake Cancel':15, 'No match':6})
    Gamma_HDMAP_output_situation_Dic_0_1_2 = CaseInsensitiveDict({'Less than 900m':0, 'Not less than 900m':1})
    Gamma_HDMAP_output_situation_Dic_3 = CaseInsensitiveDict({'IVI route':0, 'AD route':1, 'MPU route':2, 'Others':3})
    Gamma_HDMAP_output_situation_Dic_5 = CaseInsensitiveDict({'Consistent':0, 'Inconsisitent':1, 'Inconsistent':1})
    Gamma_Camera_object_identification_Dic = CaseInsensitiveDict({'NODETECTION':0, 'CAR':1, 'BUS':2, 'TRUCK':3, 'MOTORCYCLE':4, 'BICYCLE':5, 'PEDESTRIAN':6, 'ANIMAL':7, 'OTHER':8, 'No match':15})
    Gamma_Stop_maintenance_control_state_Dic = CaseInsensitiveDict({'No stophold':0, 'Stophold':1})
    Gamma_Radar_object_identification_Dic = CaseInsensitiveDict({'No detection':0, 'Car':1, 'Bus':2, 'Truck':3, 'Motorcycle':4, 'Bicycle':5, 'Pedestrian':6, 'Animal':7})
    Gamma_Setting_inter_vehicular_Dic = CaseInsensitiveDict({'No Distance Display':0, 'Short Distance Display':1, 'Middle Distance Display':2, 'Long Distance Display':3})
    Gamma_Navi_settings_with_or_without_Hands_off_permission_Dic = CaseInsensitiveDict({'Hands off drive off':0, 'Hands off drive on':1})
    Gamma_Fixed_recognition_information_of_lane_Dic = CaseInsensitiveDict({'Lost':0, 'Left':1, 'Right':2, 'Both':3})
    Gamma_Own_car_position_safety_zone_information_Dic = CaseInsensitiveDict({'None':0, 'Guard fence':1, 'Car stopping fence':2, 'Wire rope':3, 'Barricade block':4, 'Median strip area':5,
                                                                              'Rubber pole':6, 'Curb block':7, 'Cushion drum':8, 'Road cone':9, 'Road tack':10, 'No structure':11,
                                                                              'Tollhouse Median strip area':12, 'Median strip':13, 'No match':15})
    Gamma_Sensor_of_sitting_dowm_Dic = CaseInsensitiveDict({'OFF':0, 'Driver sitting':1})
    Gamma_Detection_of_hands_on_or_off_by_touch_sensor_Dic = CaseInsensitiveDict({'Hands Off':0, 'Hands On':1})
    Gamma_Expressway_judgment_Dic = CaseInsensitiveDict({'Not in expressway':0, 'In expressway':1})
    Gamma_ICC_Inter_vehicular_distance_information_of_witch_Sensor_Dic = CaseInsensitiveDict({'No Target':0, 'Front Radar':1, 'Front Camera':2, 'Invalid':3, 'Left Cutin':4, 'Right Cutin':5, 'Left Side Object':6, 'Right Side Object':7})
    Gamma_Lane_changing_direction_Dic = CaseInsensitiveDict({'None':0, 'Left':1, 'Right':2, 'Invalid':3})
    Gamma_ADAS_blinker_control_flag_Dic = CaseInsensitiveDict({'Not request':0, 'request':1})
    Gamma_ADAS_blinker_demand_level_Dic = CaseInsensitiveDict({'OFF':0, '3flasher request right':1, '3flasher request left':2, 'Invalid':3, 'Turn lamp request right':5, 'Turn lamp request left':6, 'No match':7})
    Gamma_Road_classification_of_navi_Dic = CaseInsensitiveDict({'not highway':0, 'highway':1})
    Gamma_With_or_without_nearest_LaneLinkID_revision_Dic = CaseInsensitiveDict({'Lane link ID without compensation':0, 'Lane link ID with compensation':1})
    Gamma_ALC_approval_state_Dic = CaseInsensitiveDict({'OFF':0, 'waiting with Notification':1, 'waiting without Notification':2, 'Invalid':3, 'Accept':4, 'Reject':5, 'No match':7})
    Gamma_Control_source_choice_result_Dic = CaseInsensitiveDict({'OFF':0, 'Lane':1, 'HPP':2, 'REM':3, 'HDMAP route 1':4, 'HDMAP route 2':5, 'reserved':6, 'No match':7})
    Gamma_Lane_recommendation_degree_MapECU_calculation_result_Dic = CaseInsensitiveDict({'Invalid':0, 'Out from recommended route':1, 'On Not-recommended lane':2, 'On recommended lane':3})
    Gamma_Lane_recommendation_degree_MakeLabel_calculation_result_Dic_0 = CaseInsensitiveDict({'Invalid':0, 'Disable to go straight':1, 'Not recommend to go straight':2, 'Recommended to go straight':3})
    Gamma_Lane_recommendation_degree_MakeLabel_calculation_result_Dic_2 = CaseInsensitiveDict({'Invalid':0, 'Disable to go left lane':1, 'Not recommend to go left lane':2, 'Recommended to go left lane':3})
    Gamma_Lane_recommendation_degree_MakeLabel_calculation_result_Dic_4 = CaseInsensitiveDict({'Invalid':0, 'Disable to go right lane':1, 'Not recommend to go right lane':2, 'Recommended to go right lane':3})
    Gamma_eCall_Dic = CaseInsensitiveDict({'Call Not Requested':0, 'Call Requested':1})
    Gamma_HDMAP_run_route_addition_information_Dic_0 = CaseInsensitiveDict({'Others':0, 'NRD route':1, 'Straight route':2, 'BOTH of NRD and staright route':3})
    Gamma_HDMAP_run_route_addition_information_Dic_4 = CaseInsensitiveDict({'No Exit':0, 'Cannot go to Exit':1, 'Can go to Exit with Successive ALC mode':2, 'Can go to Exit with all ALC mode':3})
    Gamma_HDMAP_run_route_addition_information_Dic_6 = CaseInsensitiveDict({'No request':0, 'Request to go to Left Exit':1, 'Request to go to Right Exit':2, 'reserved':3, 'No match':3})
    Gamma_HDMAP_run_route_addition_information_Dic_8 = CaseInsensitiveDict({'No request':0, 'Request':1})
    Gamma_Path_information_diagnosis_result_of_the_ICI_Mayor_of_course_Dic = CaseInsensitiveDict({'Path information sufficient':0, 'Path information not sufficient':1})
    Gamma_PathPlanner_map_pp_status_Dic_0 = CaseInsensitiveDict({'MPU':0, 'IVI':1})
    Gamma_PathPlanner_map_pp_status_Dic_1 = CaseInsensitiveDict({'No IVI route':0, 'IVI route':1})
    Gamma_PathPlanner_map_pp_status_Dic_2 = CaseInsensitiveDict({'Not running':0, 'Running':1})
    Gamma_PathPlanner_map_pp_status_Dic_3 = CaseInsensitiveDict({'Not deviated':0, 'Deviated':1})
    Gamma_PathPlanner_map_pp_status_Dic_4 = CaseInsensitiveDict({'Not branched':0, 'Branched':1})
    Gamma_PathPlanner_map_pp_status_Dic_5 = CaseInsensitiveDict({'Not detected':0, 'Detected':1})
    Gamma_Lane_changing_reason_Dic = CaseInsensitiveDict({'OFF':0, 'P2P normal':1, 'Pass':2, 'Return':3, 'P2P Lane merge OR lane decrease':4, 'Invalid':5, 'P2P diverge':6, 'Invalid':7, 'Driver trigger':8, 'reserved':9, 'No match':15})
    Gamma_Passing_prohibition_information_Dic = CaseInsensitiveDict({'Invalid':0, 'Left side lane prohibited':1, 'Right side lane prohibited':2, 'Both side lane prohibited':3})
    Gamma_Driver_Guidance_Dic = CaseInsensitiveDict({'No Display':0, 'Press to Start Cruise Control':1, 'Press to Set Cruise Speed':2, 'Press to Restart Cruise Control':3, 'OK Menu':4, 'No match':7})
    Gamma_LC_internal_control_state_Dic = CaseInsensitiveDict({'OFF':0, 'Notice':1, 'TurnLamp':2, 'AutoLC Part1':3, 'AutoLC Part2':4, 'AutoLC Finish':5, 'Idle':6, 'AutoLC Cancel':7, 'AutoLC Cancel NotReturn':8, 'Wait':9, 'AutoLC Cancel NoMove':10, 'No match':15})
    Gamma_FEB_Warning_cyclist_Dic = CaseInsensitiveDict({'No AEB cyclist alert':0, 'AEB cyclist alert':1})
    Gamma_FEB_Warning_Pedestrian_Dic = CaseInsensitiveDict({'No AEB PEDESTRIAN alert':0, 'AEB PEDESTRIAN alert':1})
    Gamma_FEB_Malfunction_OFF_indicator_Dic = CaseInsensitiveDict({'No display':0, 'AEB Off':1, 'operation':2, 'Not operation':3, 'Temporary failure':4, 'Permanent failure':5, 'Not Used':6, 'No match':7})
    Gamma_FEB_Temporary_Failure_Dic = CaseInsensitiveDict({'No display':0, 'Clean Front Camera Message':1, 'Camera High Temp':2, 'Front Radar Blocked':3, 'Bad Weather':4, 'Pedal High Temp':5, 'No match':7})
    Gamma_RrAEB_Malfunction_Dic = CaseInsensitiveDict({'No display':0, 'RAEB Malfunction Display':1})
    Gamma_TSR_Temporary_Failure_Dic = CaseInsensitiveDict({'No display':0, 'Camera High Temp':1})
    Gamma_LDP_Temporary_Failure_Dic = CaseInsensitiveDict({'No display':0, 'VDC Off':1, 'VDC Of':1, 'SlippyRoad':2, 'No match':3})
    Gamma_LDP_Temporary_Failure_Camera_Dic = CaseInsensitiveDict({'No display':0, 'Camera High Temp':1})
    Gamma_LDW_Temporary_Failure_Dic = CaseInsensitiveDict({'No display':0, 'Camera High Temp':1})
    Gamma_LDP_Malfunction_Dic = CaseInsensitiveDict({'No display':0, 'LDP icon warning':1, 'LDP Malfunction Display':2, 'No match':3})
    Gamma_LDW_Malfunction_Dic = CaseInsensitiveDict({'No display':0, 'LDW Status Indicator ON':1, 'LDW icon warning blink':2, 'LDW Malfunction Display':3})
    Gamma_BSI_Tempprary_Failure_SideRadar_Dic = CaseInsensitiveDict({'No display':0, 'Side Radar Blocked Message':1})
    Gamma_BSI_Tempprary_Failure_Dic = CaseInsensitiveDict({'No display':0, 'VDC Off':1, 'VDC Of':1, 'SlippyRoad':2, 'No match':3})
    Gamma_BSI_Tempprary_Failure_Camera_Dic = CaseInsensitiveDict({'No display':0, 'Camera High Temp':1})
    Gamma_BSI_Malfunction_Dic = CaseInsensitiveDict({'No display':0, 'BSI icon OFF mask':1, 'BSI Malfunction Display':2, 'No match':3})
    Gamma_ACC_Malfunction_Dic = CaseInsensitiveDict({'No display':0, 'Malfunction Display':1})
    Gamma_ACC_Temporary_Failure_Dic = CaseInsensitiveDict({'No display':0, 'Slippy Road':2, 'ePKB Active':3, 'SeatBelt Open':4, 'ACC Not Operate':7, 'FrRadar Blocked':9, 'Press Brake':11, 'Detect Obstacle':13, 'VDC Off':16, 'VDC Of':16, 'Bad Weather':20, 'No match':31})
    Gamma_LCA_Malfunction_Dic = CaseInsensitiveDict({'No display':0, 'Malfunction Display':1})
    Gamma_LCA_Message_HW_Dic = CaseInsensitiveDict({'No display':0, 'Steering Assist ON Message':1, 'Steering Assist OFF Message':2, 'Steering Assist unusable':3})
    Gamma_LCA_Temporary_Failure_Dic = CaseInsensitiveDict({'No display':0, 'Camera High Temp':1, 'Clean FrCamera':2, 'Bad Weather':3, 'LCA Not Operate':4, 'No match':7})
    Gamma_DAA_Warning_Dic = CaseInsensitiveDict({'No display':0, 'Alert display':1})
    Gamma_EAP_Warning_Dic = CaseInsensitiveDict({'No display':0, 'Alert display':1})
    Gamma_P2P_giveup_information_Dic = CaseInsensitiveDict({'Invalid':0, 'reserved':1, 'Give up to go to recommended lane':2, 'Not give up':3})
    Gamma_Priority_of_number_of_MaleLabel_suggestion_routes_Dic = CaseInsensitiveDict({'Invalid':0, 'prior Route 1':1, 'prior Route 2':2, 'Route 1 AND 2 have same priority':3})
    Gamma_TD_MRM_indication_for_AD2_Dic = CaseInsensitiveDict({'No display':0,
                                                               'Alert Eyes on road level1':1,
                                                               'Alert Eyes on road level2':2,
                                                               'Alert Eyes on road level3':3,
                                                               'Alert Eyes on road level4':4,
                                                               'Alert Eyes on road level5':5,
                                                               'Alert Eyes on road level6':6,
                                                               'Alert Eyes on road level7':7,
                                                               'Alert Eyes on road level8':8,
                                                               'Alert Eyes on road level9':9,
                                                               'Alert Eyes on road level10':10,
                                                               'Alert Eyes on road level11':11,
                                                               'Alert Eyes on road level12':12,
                                                               'Alert Eyes on road level13':13,
                                                               'Alert Eyes on road level14':14,
                                                               'Alert Eyes on road level15':15,
                                                               'Alert Eyes not on road level1':16,
                                                               'Alert Eyes not on road level2':17,
                                                               'Alert Eyes not on road level3':18,
                                                               'Alert Eyes not on road level4':19,
                                                               'Alert Eyes not on road level5':20,
                                                               'Alert Eyes not on road level6':21,
                                                               'Alert Eyes not on road level7':22,
                                                               'Alert Eyes not on road level8':23,
                                                               'Alert Eyes not on road level9':24,
                                                               'Alert Eyes not on road level10':25,
                                                               'Alert Eyes not on road level11':26,
                                                               'Alert Eyes not on road level12':27,
                                                               'Alert Eyes not on road level13':28,
                                                               'Alert Eyes not on road level14':29,
                                                               'Alert Eyes not on road level15':30,
                                                               'Alert Eyes not on road level16':31})
    Gamma_Announcement_sound_for_AD2_Group1_Dic = CaseInsensitiveDict({'No Sound':0, 'CTA Alert':1, 'MOD　Alert':2, 'AccelOverride Alert':3, 'BSI Alert':4, 'LDW Alert':5, 'ALC Cancel':6, 'LateralCancelBuz':7})
    Gamma_Announcement_sound_for_AD2_Group2_Dic = CaseInsensitiveDict({'No Sound':0, 'Cut in Alert':1, 'FCW Alert':2, 'NoEntry Sound':3, 'ApproachWarning':4, 'PFCW Buz':5, 'LongitudeCancelBuz':6, 'No match':7})
    Gamma_Announcement_sound_for_AD2_Group3_Dic = CaseInsensitiveDict({'No Sound':0, 'EAP Sound':1, 'MRM Sound':2, 'AEB Sound':3, 'No match':7})
    Gamma_Announcement_sound_for_AD2_Group4_Dic = CaseInsensitiveDict({'No Sound':0, 'LK Start Sound':1, 'LK Finish Sound':2, 'No match':3})
    Gamma_Announcement_sound_for_AD2_Group5_Dic = CaseInsensitiveDict({'No Sound':0, 'DMW':1, 'TD Immediate Sound':2, 'PreTD Sound':3, 'TD Sound':4, 'Merged Sound':5, 'HandsOnReq Sound':6, 'No match':7})
    Gamma_Target_recognition_state_of_EAP2_Dic = CaseInsensitiveDict({'Not detected':0, 'Detected':1})
    Gamma_Full_auto_parking_operational_status_Dic = CaseInsensitiveDict({'Not in operation':0, 'In operation':1})
    Gamma_Remote_parking_operational_status_Dic = CaseInsensitiveDict({'Not in operation':0, 'In operation':1})
    Gamma_MakeLabel_suggestion_route_modification_situation_Dic = CaseInsensitiveDict({'No change':0, 'Route 1 changed':1, 'Route 2 changed':2, 'Route 1 AND 2 changed':3})
    Gamma_Precedent_car_recognition_state_of_FEB_EAP_Dic = CaseInsensitiveDict({'No target':0, 'Target locked':1})
    Gamma_Expressway_judgment_NAVI_Dic = CaseInsensitiveDict({'Not in expressway':0, 'In expressway':1})
    # = CaseInsensitiveDict({})
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data) 
        self.infoPosition = None
    
    def parseWithGammaFrame(self, rowValues, oldMessage = None):
        self.Privacy_mode_IVI_ = int(SendADstatus.Gamma_Privacy_mode_Dic[rowValues['PRVCY_MD_IVI_CD']])
        self.Privacy_mode_HDMap_ = int(SendADstatus.Gamma_Privacy_mode_Dic[rowValues['PRVCY_MD_HDMP_CD']])
        self.Inter_vehicular_distance_front_ = float(rowValues['INTR_VHCL_DSTNC_FRNT_NMBR'])
        self.Inter_vehicular_distance_right_front_ = float(rowValues['INTR_VHCL_DSTNC_RGHT_FRNT_NMBR'])
        self.Inter_vehicular_distance_left_front_ = float(rowValues['INTR_VHCL_DSTNC_LFT_FRNT_NMBR'])
        self.Inter_vehicular_distance_right_rear_ = float(rowValues['INTR_VHCL_DSTNC_RGHT_RR_NMBR'])
        self.Inter_vehicular_distance_left_rear_ = float(rowValues['INTR_VHCL_DSTNC_LFT_RR_NMBR'])
        self.Yaw_angle = float(rowValues['YW_ANGL_NMBR'])
        self.Localization_confidence = float(rowValues['LCLZTN_CNFDNC_NMBR'])
        self.Drive_force_control_command = float(rowValues['DRV_FRC_CNTRL_CMMND_NMBR'])
        self.Brake_fluid_pressure_control_command_AEB_ = float(rowValues['BRK_FLD_PRSSR_CNTRL_CMMND_AEB_NMBR'])
        self.Steering_angle_control_command = float(rowValues['STRNG_ANGL_CNTRL_CMMND_NMBR'])
        self.Fault_Status_of_Mapecu = int(rowValues['FLT_STTS_OF_MP_ECU_NMBR'])
        self.Detection_of_hands_on_by_Steering_torque = int(SendADstatus.Gamma_Detection_of_hands_on_by_Steering_torque_Dic[rowValues['HNDS_ON_OR_OFF_BY_STRNG_TRQ_TXT']])
        self.Steering_override = int(SendADstatus.Gamma_OnOffDic[rowValues['STRNG_OVRRD_CD']])
        self.P2P_state = int(SendADstatus.Gamma_OnOffDic[rowValues['P2PSTT_CD']])
        self.Auto_overtaking_function = int(SendADstatus.Gamma_OnOffDic[rowValues['AT_OVRTK_FNCTN_CD']])
        self.Auto_Lanechanging_function = int(SendADstatus.Gamma_OnOffDic[rowValues['AT_LN_CHNG_FNCTN_CD']])
        self.Presence_absence_of_camera_correction_information = int(SendADstatus.Gamma_Presence_absence_of_camera_correction_information_Dic[rowValues['IS_CMR_CRRCTN_INFRMTN_PRSNT_CD']])
        self.Consistency_between_camera_vision_and_hdmap = int(SendADstatus.Gamma_Consistency_between_camera_vision_and_hdmap_Dic[rowValues['CMR_DTCTN_CNSSTNCY_TXT']])
        self.Localization = int(rowValues['LCLZTN_NMBR'])
        self.Path_planner = int(rowValues['PTH_PLNNR_NMBR'])
        self.Route_planner = int(rowValues['RT_PLNNR_NMBR'])
        self.Map_for_HMI = int(rowValues['MP_FR_HMI_NMBR'])
        self.Map_for_OD = int(rowValues['MP_FR_OD_NMBR'])
        self.Navi_settings_Rear_Automatic_Braking = int(SendADstatus.Gamma_OnOffDic[rowValues['RR_ATMTC_BRKNG_NV_STTNGS_CD']])
        self.Navi_settings_Driver_monitor = int(SendADstatus.Gamma_OnOffDic[rowValues['DRVR_MNTR_NV_STTNGS_CD']])
        self.Navi_settings_Lane_departure_warning = int(SendADstatus.Gamma_OnOffDic[rowValues['LN_DPRTR_WRNNG_NV_STTNGS_CD']])
        self.Navi_settings_Lane_departure_prevention = int(SendADstatus.Gamma_OnOffDic[rowValues['LN_DPRTR_PRVNTN_NV_STTNGS_CD']])
        self.Navi_settings_Blind_spot_warning = int(SendADstatus.Gamma_OnOffDic[rowValues['BLND_SPT_WRNNG_NV_STTNGS_CD']])
        self.Navi_settings_Blind_spot_intervention = int(SendADstatus.Gamma_OnOffDic[rowValues['BLND_SPT_INTRVNTN_NV_STTNGS_CD']])
        self.Navi_settings_Traffic_signs_recognition = int(SendADstatus.Gamma_Navi_settings_Traffic_signs_recognition_Dic[rowValues['TRFFC_SGNS_RCGNTN_NV_STTNGS_CD']])
        self.Navi_settings_Steering_assist = int(SendADstatus.Gamma_OnOffDic[rowValues['STRNG_ASSST_NV_STTNGS_CD']])
        self.Navi_settings_Forward_emergency_braking = int(SendADstatus.Gamma_OnOffDic[rowValues['FRWRD_EMRGNCY_BRKNG_NV_STTNG_CD']])
        self.Navi_settings_TSR_vehicle_speed_adjustment = int(SendADstatus.Gamma_Navi_settings_TSR_vehicle_speed_adjustment_Dic[str(rowValues['TSR_VHCL_SPD_ADJSTMNT_CD'])])
        self.Navi_settings_Sequence_exit = int(SendADstatus.Gamma_OnOffDic[rowValues['EXT_SQNC_NV_STTNGS_CD']])
        self.Which_lane_number_running = int(rowValues['LN_NMBR_RNNNG_NMBR'])
        self.Number_of_lane = int(rowValues['NMBR_OF_LNS_NMBR'])
        self.Status_of_data_receiving_from_IVI = int(SendADstatus.Gamma_Status_of_data_receiving_from_IVI_Dic[rowValues['DT_RCVNG_STTS_FRM_IVI_TXT']])
        self.Linkage_status_between_SDmap_and_HDmap = int(SendADstatus.Gamma_Linkage_status_between_SDmap_and_HDmap_Dic[rowValues['LNKG_STTS_BT_SDMP_AND_HDMP_TXT']])
        self.CP_longi = float(rowValues['CPLNG_NMBR'])
        self.CP_lat = float(rowValues['CPLT_NMBR'])
        self.InterVehicularDistanceICC = float(rowValues['INTR_VHCLR_DSTNC_ICC_NMBR'])
        self.Cancel_code = int(rowValues['CD_CNCL_NMBR'])
        self.ND2_code = int(rowValues['CD_ND2_NMBR'])
        self.Status_transition_of_ADAS = int(SendADstatus.Gamma_Status_transition_of_ADAS_Dic[rowValues['STTS_TRNSTN_OF_ADAS_CD']])
        self.Curvature = float(rowValues['CRVTR_NMBR'])
        self.Wiper_mode = (int(SendADstatus.Gamma_ActiveInactiveDic[rowValues['WPR_MD_LW_CD']]) << 0) + \
                          (int(SendADstatus.Gamma_ActiveInactiveDic[rowValues['WPR_MD_HGH_CD']]) << 1)
        self.Check_latest_version = int(SendADstatus.Gamma_Check_latest_version_Dic[rowValues['CHCK_LTST_VRSN_CD']])
        self.HDMAP_freshness_information = int(SendADstatus.Gamma_OnOffDic[rowValues['HDMP_FRSHNSS_INFRMTN_CD']])
        self.AD2_emergency_stop_flag = int(SendADstatus.Gamma_ValidInvalidDic_reverse[rowValues['AD2_EMRGNCY_STP_FLG_CD']])
        self.Sheet_belt = int(SendADstatus.Gamma_Sheet_belt_Dic[rowValues['ST_BLT_BCKL_STTS_CD']])
        self.Lane_projection_state = int(SendADstatus.Gamma_OnOffDic[rowValues['LN_PRJCTN_STT_CD']])
        self.With_or_without_HDMAP_flag = int(SendADstatus.Gamma_ValidInvalidDic[rowValues['IS_WTH_HDMP_FLG_CD']])
        self.License_state = int(SendADstatus.Gamma_AvailableUnavailableDic_reverse[rowValues['LCNS_STT_CD']])
        self.GPS_Latitude = float(rowValues['GPS_LTTD_NMBR'])
        self.GPS_Longitude = float(rowValues['GPS_LNGTD_NMBR'])
        self.GPS_UTC_Timestamp_Year_ = int(rowValues['GPS_YR_UTC_NMBR'])
        self.Shift_position = int(SendADstatus.Gamma_Shift_position_Dic[rowValues['SHFT_PSTN_CD']])
        self.GPS_UTC_Timestamp_Month_ = int(rowValues['GPS_MNTH_UTC_NMBR'])
        self.Winker = int(SendADstatus.Gamma_WinkerInfoDic[rowValues['WNKR_CD']])
        self.Deviation_warning = int(SendADstatus.Gamma_Deviation_warning_Dic[rowValues['DVTN_WRNNG_CD']])
        self.Approch_warning = int(SendADstatus.Gamma_Approch_warning_Dic[rowValues['APPRCH_WRNNG_CD']])
        self.GPS_UTC_Timestamp_Day_ = int(rowValues['GPS_DY_UTC_NMBR'])
        self.PKB_control_command = int(SendADstatus.Gamma_PKB_control_command_Dic[rowValues['PKB_CNTRL_CMMND_CD']])
        self.Brake_lamp_command = int(SendADstatus.Gamma_Brake_lamp_command_Dic[rowValues['BRK_LMP_CMMND_CD']])
        self.LDP_BSI_operation_status = int(SendADstatus.Gamma_LDP_BSI_operation_status_Dic[rowValues['OPRTN_STTS_LDPBS_CD']])
        self.GPS_UTC_Timestamp_Hour_ = int(rowValues['GPS_HR_UTC_NMBR'])
        self.Steering_SW = int(SendADstatus.Gamma_Steering_SW_Dic[rowValues['STRNG_SW_CD']])
        self.GPS_UTC_Timestamp_Minute_ = int(rowValues['GPS_MNT_UTC_NMBR'])
        self.Switch_of_door = (int(SendADstatus.Gamma_Switch_of_door_Dic[rowValues['FRNT_RGHT_DRS_WTCH_CD']]) << 0) + \
                              (int(SendADstatus.Gamma_Switch_of_door_Dic[rowValues['OTHR_DRS_SWTCH_CD']]) << 1)
        self.Turn_signal_switch = int(SendADstatus.Gamma_Turn_signal_switch_Dic[rowValues['TRN_SGNL_SWTCH_CD']])
        self.Relative_velocity_of_ICC_target = float(rowValues['RLTV_VLCTY_OF_ICC_TRGT_NMBR'])
        self.Flag_of_jyro = int(SendADstatus.Gamma_ValidInvalidDic_reverse[rowValues['FLG_OF_GYR_CD']])
        self.Flag_of_accelerometer = int(SendADstatus.Gamma_ValidInvalidDic_reverse[rowValues['FLG_OF_ACCLRMTR_CD']])
        self.Flag_of_GNSS = int(SendADstatus.Gamma_ValidInvalidDic_reverse[rowValues['FLG_OF_GNSS_CD']])
        self.Press_degree_of_accelerator = float(rowValues['ACCLRTR_DVRGNC_NMBR'])
        self.Steering_torque_sensor = float(rowValues['STRNG_TRQ_SNSR_NMBR'])
        self.Brake_pedal_stroke = float(rowValues['BRK_PDL_STRK_NMBR'])
        self.Engine_RPM = int(SendADstatus.Gamma_Engine_RPM_Dic[rowValues['ENGN_RPM_CD']])
        self.AD_Localization_Latitude = float(rowValues['AD_LTTD_NMBR']) * 1.0000003783795208 #サーバー側のresolution係数の桁落ちにより、間違った結果となっているので、描画時に補正。
        self.AD_Localization_Longitude = float(rowValues['AD_LNGTD_NMBR']) * 1.0000003783795208 #サーバー側のresolution係数の桁落ちにより、間違った結果となっているので、描画時に補正。
        self.Target_vehicle_speed_for_AD2 = float(rowValues['TRGT_VHCL_SPD_FR_AD2_NMBR'])
        self.Real_Vehicle_speed = float(rowValues['RL_VHCL_SPD_NMBR'])
        self.Lateral_acceleration = float(rowValues['LTRL_ACCLRTN_NMBR'])
        self.Steering_angle = float(rowValues['STRNG_ANGL_NMBR'])
        self.Yaw_rate = float(rowValues['YWRT_NMBR'])
        self.Face_direction_Yaw_ = float(rowValues['FC_DRCTN_YW_NMBR'])
        self.Face_direction_Pitch_ = float(rowValues['FC_DRCTN_PTCH_NMBR'])
        self.Flag_of_car_position_message = int(SendADstatus.Gamma_ValidInvalidDic_reverse[rowValues['FLG_OF_CR_PSTN_MSSG_CD']])
        self.Face_direction_Roll_ = float(rowValues['FC_DRCTN_RLL_NMBR'])
        self.The_preceding_vehicle_determination_flag_TJP_stopping_item_ = int(SendADstatus.Gamma_OnOffDic[rowValues['PRCDNG_VHCL_STPPNG_DTRMNTN_FLG_CD']])
        self.Closure_status_of_right_eye = int(SendADstatus.Gamma_Closure_status_of_eye_Dic[rowValues['CLSR_STTS_OF_RGHT_EY_DMS1_CD']])
        self.distraction = (int(SendADstatus.Gamma_YesNoDic[rowValues['YW_DSTRCTN_BFR_CLBRTN_CD']]) << 0) + \
                           (int(SendADstatus.Gamma_YesNoDic[rowValues['YW_DSTRCTN_AFTR_CLBRTN_CD']]) << 1) + \
                           (int(SendADstatus.Gamma_YesNoDic[rowValues['PTCH_DSTRCTN_CD']]) << 2) + \
                           (int(SendADstatus.Gamma_YesNoDic[rowValues['FRZ_DTCTN_CD']]) << 3) + \
                           (int(SendADstatus.Gamma_YesNoDic[rowValues['FC_OFF_RDRT_CD']]) << 4) + \
                           (int(SendADstatus.Gamma_YesNoDic[rowValues['RLL_DSTRCTN_CD']]) << 5)
        self.Closure_status_of_left_eye = int(SendADstatus.Gamma_Closure_status_of_eye_Dic[rowValues['CLSR_STTS_OF_LFT_EY_DMS1_CD']])
        self.Sleepiness = (int(SendADstatus.Gamma_Sleepiness_Dic[rowValues['SLPNSS_CD']]) << 0) + \
                          (int(SendADstatus.Gamma_YesNoDic[rowValues['SLPNSS_HGH_EY_CLSRRT_FLG_CD']]) << 2) + \
                          (int(SendADstatus.Gamma_YesNoDic[rowValues['SLPNSS_OT_OF_NRML_FCR_FLG_CD']]) << 3) + \
                          (int(SendADstatus.Gamma_YesNoDic[rowValues['SLPNSS_FC_UNDTCTD_FLG_CD']]) << 4) + \
                          (int(SendADstatus.Gamma_YesNoDic[rowValues['SLPNSS_EY_UNDTCTD_FLG_CD']]) << 5)
        self.Driver_monitoring = (int(SendADstatus.Gamma_YesNoDic[rowValues['DRVR_MNTRNG_SRFC_DRTD_DTCTN_CD']]) << 0) + \
                                 (int(SendADstatus.Gamma_YesNoDic[rowValues['DRVR_MNTRNG_BLCKG_CD']]) << 1) + \
                                 (int(SendADstatus.Gamma_YesNoDic[rowValues['DRVR_MNTRNG_BRGHTNSS_STRTN_CD']]) << 2) + \
                                 (int(SendADstatus.Gamma_DMS1_Multiple_face_detection_Dic[rowValues['DRVR_MNTRNG_MLTPL_FC_DTCTN_CD']]) << 3)
        self.The_preceding_vehicle_determination_flag_TJP_moving_item_ = int(SendADstatus.Gamma_OnOffDic[rowValues['PRCDNG_VHCL_MVNG_DTRMNTN_FLG_CD']])
        self.Master_cylinder_fluid_pressure = float(rowValues['MSTR_CYLNDR_FLD_PRSSR_NMBR'])
        self.Motion_status = int(SendADstatus.Gamma_Motion_status_Dic[rowValues['MTN_STTS_CD']])
        self.Camera_motion_status = int(SendADstatus.Gamma_Camera_motion_status_Dic[rowValues['CMR_MTN_STTS_CD']])
        self.ON_OFF_of_driver_brakes_working_conditions = int(SendADstatus.Gamma_ON_OFF_of_driver_brakes_working_conditions_Dic[rowValues['DRVR_BRK_CNDTN_CD']])
        self.OFF_ON_of_stop_lamp_lighting_state = int(SendADstatus.Gamma_OnOffDic[rowValues['STP_LMP_LGHTNG_STT_CD']])
        self.PKB_control_state = int(SendADstatus.Gamma_PKB_control_state_Dic[rowValues['PKB_CNTRL_STT_CD']])
        self.Inter_vehicular_distance_Camera_ = float(rowValues['CMR_INTR_VHCL_DSTNC_NMBR'])
        self.Camera_lateral_position = float(rowValues['CMR_LTRL_PSTN_NMBR'])
        self.Camera_relative_speed = float(rowValues['CMR_RLTV_SPD_NMBR'])
        self.Camera_object_identification = int(SendADstatus.Gamma_Camera_object_identification_Dic[rowValues['CMR_OBJCT_IDNTFCTN_CD']])
        self.Stop_maintenance_control_state = int(SendADstatus.Gamma_Stop_maintenance_control_state_Dic[rowValues['STP_MNTNNC_CNTRL_STT_CD']])
        self.Radar_object_identification = int(SendADstatus.Gamma_Radar_object_identification_Dic[rowValues['RDR_OBJCT_IDNTFCTN_CD']])
        self.ON_OFF_of_meter_illuminations_demand = int(SendADstatus.Gamma_OnOffDic[rowValues['MTR_ILLMNTN_DMND_STTS_CD']])
        self.Inter_vehicular_distance_Radar_ = float(rowValues['RDR_INTR_VHCL_DSTNC_NMBR'])
        self.Radar_lateral_position = float(rowValues['RDR_LTRL_PSTN_NMBR'])
        self.Radar_relative_speed = float(rowValues['RDR_RLTV_SPD_NMBR'])
        self.Setting_inter_vehicular = int(SendADstatus.Gamma_Setting_inter_vehicular_Dic[rowValues['INTR_VHCLLR_DSTNC_DSPLY_STTNG_CD']])
        self.Brake_fluid_pressure_control_command_ICC_ = float(rowValues['BRK_FLD_PRSSR_CNTRL_CMMND_ICC_NMBR'])
        self.Navi_settings_with_or_without_Hands_off_permission = int(SendADstatus.Gamma_Navi_settings_with_or_without_Hands_off_permission_Dic[rowValues['HNDS_OFF_PRMSSN_NV_STTNGS_CD']])
        self.The_reason_that_Hands_off_is_prohibited = int(rowValues['HNDS_OFF_PRHBTD_RSN_NMBR'])
        self.Time_to_control_point = float(rowValues['TM_TO_CNTRL_PNT_NMBR'])
        self.Status_of_lane_changing_possibility = (int(SendADstatus.Gamma_OKNGDic_reverse[rowValues['LN_CHNGNG_PSSBLTY_STTS_RT0_NLN_CD']]) << 0) + \
                                                   (int(SendADstatus.Gamma_OKNGDic_reverse[rowValues['LN_CHNGNG_PSSBLTY_STTS_RT0_CNTRL_CD']]) << 1) + \
                                                   (int(SendADstatus.Gamma_OKNGDic_reverse[rowValues['LN_CHNGNG_PSSBLTY_STTS_RT0_RGLTRY_CD']]) << 2) + \
                                                   (int(SendADstatus.Gamma_OKNGDic_reverse[rowValues['LN_CHNGNG_PSSBLTY_STTS_RT0_CRVTR_CD']]) << 3) + \
                                                   (int(SendADstatus.Gamma_OKNGDic_reverse[rowValues['LN_CHNGNG_PSSBLTY_STTS_RT0_NXT_MRGLN_CD']]) << 4) + \
                                                   (int(SendADstatus.Gamma_OKNGDic_reverse[rowValues['LN_CHNGNG_PSSBLTY_STTS_RT0_RLBLTY_CD']]) << 5) + \
                                                   (int(SendADstatus.Gamma_OKNGDic_reverse[rowValues['LN_CHNGNG_PSSBLTY_STTS_RT1_NLN_CD']]) << 6) + \
                                                   (int(SendADstatus.Gamma_OKNGDic_reverse[rowValues['LN_CHNGNG_PSSBLTY_STTS_RT1_CNTRL_CD']]) << 7) + \
                                                   (int(SendADstatus.Gamma_OKNGDic_reverse[rowValues['LN_CHNGNG_PSSBLTY_STTS_RT1_RGLTRY_CD']]) << 8) + \
                                                   (int(SendADstatus.Gamma_OKNGDic_reverse[rowValues['LN_CHNGNG_PSSBLTY_STTS_RT1_CRVTR_CD']]) << 9) + \
                                                   (int(SendADstatus.Gamma_OKNGDic_reverse[rowValues['LN_CHNGNG_PSSBLTY_STTS_RT1_NXT_MRGLN_CD']]) << 10) + \
                                                   (int(SendADstatus.Gamma_OKNGDic_reverse[rowValues['LN_CHNGNG_PSSBLTY_STTS_RT1_RLBLTY_CD']]) << 11)
        self.Fixed_recognition_information_of_lane = int(SendADstatus.Gamma_Fixed_recognition_information_of_lane_Dic[rowValues['FXD_RCGNTN_LN_INF_TXT']])
        self.Own_car_position_safety_zone_information = int(SendADstatus.Gamma_Own_car_position_safety_zone_information_Dic[rowValues['OWN_CR_SFTY_ZN_INF_CD']])
        self.Sensor_of_sitting_dowm = int(SendADstatus.Gamma_Sensor_of_sitting_dowm_Dic[rowValues['SNSR_OF_STTNG_DWN_TXT']])
        self.Detection_of_hands_on_or_off_by_touch_sensor = int(SendADstatus.Gamma_Detection_of_hands_on_or_off_by_touch_sensor_Dic[rowValues['HNDS_ON_OR_OFF_BY_TCH_SNSR_TXT']])
        self.Expressway_judgment = int(SendADstatus.Gamma_Expressway_judgment_Dic[rowValues['EXPRSS_WY_JDGMNT_CD']])
        self.ICC_Inter_vehicular_distance_information_of_witch_Sensor = int(SendADstatus.Gamma_ICC_Inter_vehicular_distance_information_of_witch_Sensor_Dic[rowValues['ICC_INTR_VHCLR_DSTNC_INF_BY_SNSR_CD']])
        self.Lane_changing_direction = int(SendADstatus.Gamma_Lane_changing_direction_Dic[rowValues['LN_CHNGNG_DRCTN_CD']])
        self.Right_lane_position = float(rowValues['RGHT_LN_PSTN_NMBR'])
        self.Left_lane_position = float(rowValues['LFT_LN_PSTN_NMBR'])
        self.GPS_precision_information = float(rowValues['GPS_PRCSN_INFRMTN_NMBR'])
        self.ADAS_blinker_control_flag = int(SendADstatus.Gamma_ADAS_blinker_control_flag_Dic[rowValues['ADAS_BLNKR_CNTRL_FLG_CD']])
        self.ADAS_blinker_demand_level = int(SendADstatus.Gamma_ADAS_blinker_demand_level_Dic[rowValues['ADAS_BLNKR_DMND_LVL_CD']])
        self.AD_Localization_Altitude = float(rowValues['AD_LCLZTN_ALTTD_NMBR'])
        self.AD_Localization_Yaw_angle = float(rowValues['AD_LCLZTN_YW_ANGL_NMBR'])
        self.IVI_Speed_Limit = float(rowValues['IVI_SPD_LMT_NMBR'])
        self.IVI_Curvature = float(rowValues['IVI_CRVTR_NMBR'])
        self.IVI_Dist_Exit = float(rowValues['IVI_DSTNC_TO_EXT_NMBR'])
        self.IVI_Dist_TG = float(rowValues['IVI_DSTNC_TO_TLLGT_NMBR'])
        self.Road_classification_of_navi = int(SendADstatus.Gamma_Road_classification_of_navi_Dic[rowValues['RD_CLSSFCTNN_NV_CD']])
        self.With_or_without_nearest_LaneLinkID_revision = int(SendADstatus.Gamma_With_or_without_nearest_LaneLinkID_revision_Dic[rowValues['LN_LNKD_CMPNSTN_STTS_CD']])
        self.ALC_approval_state = int(SendADstatus.Gamma_ALC_approval_state_Dic[rowValues['ALC_APPRVL_STTS_CD']])
        self.Control_source_choice_result = int(SendADstatus.Gamma_Control_source_choice_result_Dic[rowValues['CNTRL_SRC_CHC_RSLT_CD']])
        self.Lane_recommendation_degree_MapECU_calculation_result_ = int(SendADstatus.Gamma_Lane_recommendation_degree_MapECU_calculation_result_Dic[rowValues['LN_RCMMNDTN_STTS_CD']])
        self.Lane_recommendation_degree_MakeLabel_calculation_result_ = (int(SendADstatus.Gamma_Lane_recommendation_degree_MakeLabel_calculation_result_Dic_0[rowValues['LN_RCMMNDTN_STRGHT_DRCTN_CD']]) << 0) + \
                                                                        (int(SendADstatus.Gamma_Lane_recommendation_degree_MakeLabel_calculation_result_Dic_2[rowValues['LN_RCMMNDTN_LFT_DRCTN_CD']]) << 2) + \
                                                                        (int(SendADstatus.Gamma_Lane_recommendation_degree_MakeLabel_calculation_result_Dic_4[rowValues['LN_RCMMNDTN_RGHT_DRCTN_CD']]) << 4)
        self.eCall = int(SendADstatus.Gamma_eCall_Dic[rowValues['E_CLL_CD']])
        self.TSR_Last_choice_level_ = float(rowValues['TSR_LST_CHC_LVL_NMBR'])
        self.TSR_HDMAP_level_ = float(rowValues['TSR_HDMP_LVL_NMBR'])
        self.TSR_Camera_ = float(rowValues['TSR_CMR_NMBR'])
        self.HDMAP_run_route_addition_information = (int(SendADstatus.Gamma_HDMAP_run_route_addition_information_Dic_0[rowValues['HDMP_ADDTNL_INF_RT1_ATTRBT_CD']]) << 0) + \
                                                    (int(SendADstatus.Gamma_HDMAP_run_route_addition_information_Dic_0[rowValues['HDMP_ADDTNL_INF_RT2_ATTRBT_CD']]) << 2) + \
                                                    (int(SendADstatus.Gamma_HDMAP_run_route_addition_information_Dic_4[rowValues['HDMP_ADDTNL_INF_CNTRL_AT_EXT_CD']]) << 4) + \
                                                    (int(SendADstatus.Gamma_HDMAP_run_route_addition_information_Dic_6[rowValues['HDMP_ADDTNL_INF_EXT_SQNC_RQST_CD']]) << 6) + \
                                                    (int(SendADstatus.Gamma_HDMAP_run_route_addition_information_Dic_8[rowValues['HDMP_ADDTNL_INF_FLSH_BLNKR_RQST_CD']]) << 8) + \
                                                    (int(SendADstatus.Gamma_HDMAP_run_route_addition_information_Dic_8[rowValues['HDMP_CNTRL_RQST_IN_BRNCH_ON_RT1_CD']]) << 9) + \
                                                    (int(SendADstatus.Gamma_HDMAP_run_route_addition_information_Dic_8[rowValues['HDMP_CNTRL_RQST_IN_BRNCH_ON_RT2_CD']]) << 10) + \
                                                    (int(SendADstatus.Gamma_HDMAP_run_route_addition_information_Dic_8[rowValues['HDMP_CNTRL_RQST_IN_NLN_SCTN_ON_RT1_CD']]) << 11) + \
                                                    (int(SendADstatus.Gamma_HDMAP_run_route_addition_information_Dic_8[rowValues['HDMP_CNTRL_RQST_IN_NLN_SCTN_ON_RT2_CD']]) << 12) + \
                                                    (int(SendADstatus.Gamma_ValidInvalidDic[rowValues['HDMP_ADDTNL_INF_RT1_VLDTN_CD']]) << 13) + \
                                                    (int(SendADstatus.Gamma_ValidInvalidDic[rowValues['HDMP_ADDTNL_INF_RT2_VLDTN_CD']]) << 14) + \
                                                    (int(SendADstatus.Gamma_YesNoDic[rowValues['HDMP_ADDTNL_INF_EXT_SQNC_CNCLLTN_CS_CD']]) << 15)
        self.HDMAP_output_situation = (int(SendADstatus.Gamma_HDMAP_output_situation_Dic_0_1_2[rowValues['IVI_RT_RMNNG_DSTNC_CD']]) << 0) + \
                                      (int(SendADstatus.Gamma_HDMAP_output_situation_Dic_0_1_2[rowValues['AD_RT_RMNNG_DSTNC_CD']]) << 1) + \
                                      (int(SendADstatus.Gamma_HDMAP_output_situation_Dic_0_1_2[rowValues['MPU_RT_RMNNG_DSTNC_CD']]) << 2) + \
                                      (int(SendADstatus.Gamma_HDMAP_output_situation_Dic_3[rowValues['BSC_RT_FR_MRGNG_CD']]) << 3) + \
                                      (int(SendADstatus.Gamma_HDMAP_output_situation_Dic_5[rowValues['CNSSTNCY_OF_MRGNG_RT_CD']]) << 5)
        self.Path_information_diagnosis_result_of_the_ICI_Mayor_of_course = int(SendADstatus.Gamma_Path_information_diagnosis_result_of_the_ICI_Mayor_of_course_Dic[rowValues['PTH_INFRMTN_DGNSS_RSLT_CD']])
        self.On_Off_of_NAVI_ICC = int(SendADstatus.Gamma_OnOffDic[rowValues['NV_ICC_STTS_CD']])
        self.NAVI_ICC_target_speed = float(rowValues['NV_ICC_TRGT_SPD_NMBR'])
        self.ICC_target_speed = float(rowValues['ICC_TRGT_SPD_NMBR'])
        self.InterVehicularDistanceICC_Target = float(rowValues['INTR_VHCLR_DSTNC_ICC_TRGT_NMBR'])
        self.Steering_angle_servo_gain = float(rowValues['STRNG_ANGL_SRVGN_NMBR'])
        self.LC_cancellation_reason = int(rowValues['LC_CNCLLTN_RSN_NMBR'])
        self.Aim_Control_Point_side_position = float(rowValues['AM_CNTRL_PNTS_IDE_PSTN_NMBR'])
        self.PathPlanner_map_pp_status = (int(SendADstatus.Gamma_PathPlanner_map_pp_status_Dic_0[rowValues['PTH_PLNNR_LN_INF_SRC_CD']]) << 0) + \
                                         (int(SendADstatus.Gamma_PathPlanner_map_pp_status_Dic_1[rowValues['PTH_PLNNR_MK_LBL_PCR_CD']]) << 1) + \
                                         (int(SendADstatus.Gamma_PathPlanner_map_pp_status_Dic_2[rowValues['PTH_PLNNR_IS_IVI_SB_PTH_RNNNG_CD']]) << 2) + \
                                         (int(SendADstatus.Gamma_PathPlanner_map_pp_status_Dic_3[rowValues['PTH_PLNNR_DVTN_OF_IVI_LCTR_CD']]) << 3) + \
                                         (int(SendADstatus.Gamma_PathPlanner_map_pp_status_Dic_4[rowValues['PTH_PLNNR_IS_BRNCHD_CD']]) << 4) + \
                                         (int(SendADstatus.Gamma_PathPlanner_map_pp_status_Dic_5[rowValues['PTH_PLNNR_IS_NRML_RD_CD']]) << 5)
        self.PathPlanner_flags = (int(SendADstatus.Gamma_OnOffDic[rowValues['PTH_PLNNR_CRV_LSS_THN_177R_FLG_CD']]) << 0) + \
                                 (int(SendADstatus.Gamma_OnOffDic[rowValues['PTH_PLNNR_CRV_LSS_THN_100R_FLG_CD']]) << 1) + \
                                 (int(SendADstatus.Gamma_OnOffDic[rowValues['PTH_PLNNR_EXT_HRD_TO_JDG_FLG_CD']]) << 2) + \
                                 (int(SendADstatus.Gamma_OnOffDic[rowValues['PTH_PLNNR_TNNL_LSS_THN_500M_FLG_CD']]) << 3) + \
                                 (int(SendADstatus.Gamma_OnOffDic[rowValues['PTH_PLNNR_GPSLWQ_FLG_CD']]) << 4) + \
                                 (int(SendADstatus.Gamma_OnOffDic[rowValues['PTH_PLNNR_TNNL_FLG_CD']]) << 5) + \
                                 (int(SendADstatus.Gamma_OnOffDic[rowValues['PTH_PLNNR_ENTRNC_OR_EXT_OF_TNNL_FLG_CD']]) << 6) + \
                                 (int(SendADstatus.Gamma_OnOffDic[rowValues['PTH_PLNNR_CMR_UNSTBL_AR_FLG_CD']]) << 7)
        self.Lane_changing_reason = int(SendADstatus.Gamma_Lane_changing_reason_Dic[rowValues['LN_CHNGNG_RSN_CD']])
        self.Passing_prohibition_information = int(SendADstatus.Gamma_Passing_prohibition_information_Dic[rowValues['PSSNG_PRHBTN_INFRMTN_CD']])
        self.Number_of_MaleLabel_suggestion_routes = int(rowValues['MK_LBL_RT_SGGSTN_CNT_NMBR'])
        self.Remaining_distance_of_lane_changing_possibility = float(rowValues['RMNNG_DSTNC_TO_LN_CHNG_NMBR'])
        self.Driver_Guidance = int(SendADstatus.Gamma_Driver_Guidance_Dic[rowValues['DRVR_GDNC_NMBR']])
        self.Hands_on_demand_reason_from_Lateral = int(SendADstatus.Gamma_Hands_on_demand_reason_from_Lateral_Dic[rowValues['HND_ON_RQST_RSN_LTRL_CD']])
        self.LC_internal_control_state = int(SendADstatus.Gamma_LC_internal_control_state_Dic[rowValues['LC_INTRNL_CNTRL_STT_CD']])
        self.Wide_control_internal_control_state = int(SendADstatus.Gamma_Wide_control_internal_control_state_Dic[rowValues['WD_CNTRL_INTRNL_CNTRL_STT_CD']])
        self.Long_control_internal_control_state = int(SendADstatus.Gamma_Long_control_internal_control_state_Dic[rowValues['LNG_CNTRL_INTRNL_CNTRL_STT_CD']])
        self.FEB_Warning_cyclist = int(SendADstatus.Gamma_FEB_Warning_cyclist_Dic[rowValues['FEB_WRNNG_FR_CYCLST_CD']])
        self.FEB_Warning_Pedestrian = int(SendADstatus.Gamma_FEB_Warning_Pedestrian_Dic[rowValues['FEB_WRNNG_FR_PDSTRN_CD']])
        self.FEB_Malfunction_OFF_indicator = int(SendADstatus.Gamma_FEB_Malfunction_OFF_indicator_Dic[rowValues['FEB_MLFNCTN_CD']])
        self.FEB_Temporary_Failure = int(SendADstatus.Gamma_FEB_Temporary_Failure_Dic[rowValues['FEB_TMPRRY_FLR_CD']])
        self.FEB_Warning_Vehicle = int(SendADstatus.Gamma_OnOffDic[rowValues['FEB_WRNNG_VHCL_CD']])
        self.RrAEB_Malfunction = int(SendADstatus.Gamma_RrAEB_Malfunction_Dic[rowValues['RR_AEB_MLFNCTN_CD']])
        self.RrAEB_OFF_indicator = int(SendADstatus.Gamma_OnOffDic[rowValues['RR_AEB_OFF_INDCTR_CD']])
        self.RrAEB_warning = int(SendADstatus.Gamma_OnOffDic[rowValues['RR_AEB_WRNNG_CD']])
        self.TSR_Temporary_Failure = int(SendADstatus.Gamma_TSR_Temporary_Failure_Dic[rowValues['TSR_TMPRRY_FLR_CD']])
        self.LDP_Temporary_Failure = int(SendADstatus.Gamma_LDP_Temporary_Failure_Dic[rowValues['LDP_TMPRRY_FLR_CD']])
        self.LDP_Temporary_Failure_Camera_ = int(SendADstatus.Gamma_LDP_Temporary_Failure_Camera_Dic[rowValues['LDP_TMPRRY_FLR_OF_CMR_CD']])
        self.LDW_Temporary_Failure = int(SendADstatus.Gamma_LDW_Temporary_Failure_Dic[rowValues['LDW_TMPRRY_FLR_CD']])
        self.LDP_Malfunction = int(SendADstatus.Gamma_LDP_Malfunction_Dic[rowValues['LDP_MLFNCTN_CD']])
        self.LDW_Malfunction = int(SendADstatus.Gamma_LDW_Malfunction_Dic[rowValues['LDW_MLFNCTN_CD']])
        self.BSI_Tempprary_Failure_SideRadar_ = int(SendADstatus.Gamma_BSI_Tempprary_Failure_SideRadar_Dic[rowValues['BSI_TMPRRY_FLR_OF_SDRDR_CD']])
        self.BSI_Tempprary_Failure = int(SendADstatus.Gamma_BSI_Tempprary_Failure_Dic[rowValues['BSI_TMPRRY_FLR_CD']])
        self.BSI_Tempprary_Failure_Camera_ = int(SendADstatus.Gamma_BSI_Tempprary_Failure_Camera_Dic[rowValues['BSI_TMPRRY_FLR_OF_CMR_CD']])
        self.BSI_Malfunction = int(SendADstatus.Gamma_BSI_Malfunction_Dic[rowValues['BSI_MLFNCTN_CD']])
        self.ACC_Malfunction = int(SendADstatus.Gamma_ACC_Malfunction_Dic[rowValues['ACC_MLFNCTN_CD']])
        self.ACC_Temporary_Failure = int(SendADstatus.Gamma_ACC_Temporary_Failure_Dic[rowValues['ACC_TMPRRY_FLR_CD']])
        self.LCA_Malfunction = int(SendADstatus.Gamma_LCA_Malfunction_Dic[rowValues['LCA_MLFNCTN_CD']])
        self.LCA_Message_HW_ = int(SendADstatus.Gamma_LCA_Message_HW_Dic[rowValues['LCA_MSSG_CD']])
        self.LCA_Temporary_Failure = int(SendADstatus.Gamma_LCA_Temporary_Failure_Dic[rowValues['LCA_TMPRRY_FLR_CD']])
        self.DAA_Warning = int(SendADstatus.Gamma_DAA_Warning_Dic[rowValues['DAA_WRNNG_CD']])
        self.EAP_Warning = int(SendADstatus.Gamma_EAP_Warning_Dic[rowValues['EAP_WRNNG_CD']])
        self.Current_Form_Of_Way = int(rowValues['CRRNT_FRM_OF_WY_NMBR'])
        self.TSR_Status_ = int(rowValues['TSR_STTS_NMBR'])
        self.Own_car_position_reliability_flag_information = (int(SendADstatus.Gamma_Own_car_position_reliability_flag_information_Dic_0[rowValues['CR_PSTN_RLBLTY_CMR_UNSTBL_FLG_CD']]) << 0) + \
                                                             (int(SendADstatus.Gamma_Own_car_position_reliability_flag_information_Dic_1[rowValues['CR_PSTN_RLBLTY_MP_FRSHNSS_FLG_CD']]) << 1) + \
                                                             (int(SendADstatus.Gamma_Own_car_position_reliability_flag_information_Dic_3[rowValues['CR_PSTN_RLBLTY_RD_FRM_DPNDNCY_FLG_CD']]) << 3) + \
                                                             (int(SendADstatus.Gamma_Own_car_position_reliability_flag_information_Dic_6[rowValues['CR_PSTN_RLBLTY_SFTWR_VRSN_DPNDNCY_FLG_CD']]) << 6) + \
                                                             (int(rowValues['CR_PSTN_RLBLTY_SFTWR_VRSN_FLG_CD']) << 9) + \
                                                             (int(SendADstatus.Gamma_Own_car_position_reliability_flag_information_Dic_16[rowValues['CR_PSTN_RLBLTY_CNSTRCTN_TYP_FLG_CD']]) << 16)
        self.P2P_giveup_information = int(SendADstatus.Gamma_P2P_giveup_information_Dic[rowValues['P2P_GV_UP_INFRMTN_CD']])
        self.Priority_of_number_of_MaleLabel_suggestion_routes = int(SendADstatus.Gamma_Priority_of_number_of_MaleLabel_suggestion_routes_Dic[rowValues['PRRTY_OF_MK_LBL_SGGSTD_RT_CD']])
        self.Wide_control_permission_judgment_in_the_map_information = int(SendADstatus.Gamma_OnOffDic[rowValues['WD_CNTRL_PRMSSN_FRM_MP_CD']])
        self.Warning_indication_for_AD2 = int(rowValues['AD2_WRNNG_INDCTN_NMBR'])
        self.Notice_of_driver_for_AD2 = int(rowValues['AD2_DRVR_NTC_NMBR'])
        self.Notice_of_cancellation_for_AD2 = int(rowValues['AD2_CNCLLTN_NTC_NMBR'])
        self.TD_MRM_indication_for_AD2 = int(SendADstatus.Gamma_TD_MRM_indication_for_AD2_Dic[rowValues['TD_MRM_INDCTN_FR_AD2_CD']])
        self.Announcement_sound_for_AD2_Group1_ = int(SendADstatus.Gamma_Announcement_sound_for_AD2_Group1_Dic[rowValues['ANNNCMNT_SND_AD2_FR_GRP1_NMBR']])
        self.Announcement_sound_for_AD2_Group2_ = int(SendADstatus.Gamma_Announcement_sound_for_AD2_Group2_Dic[rowValues['ANNNCMNT_SND_AD2_FR_GRP2_NMBR']])
        self.Announcement_sound_for_AD2_Group3_ = int(SendADstatus.Gamma_Announcement_sound_for_AD2_Group3_Dic[rowValues['ANNNCMNT_SND_AD2_FR_GRP3_NMBR']])
        self.Announcement_sound_for_AD2_Group4_ = int(SendADstatus.Gamma_Announcement_sound_for_AD2_Group4_Dic[rowValues['ANNNCMNT_SND_AD2_FR_GRP4_NMBR']])
        self.Announcement_sound_for_AD2_Group5_ = int(SendADstatus.Gamma_Announcement_sound_for_AD2_Group5_Dic[rowValues['ANNNCMNT_SND_AD2_FR_GRP5_NMBR']])
        self.Hands_off_permission_condition = (int(SendADstatus.Gamma_Hands_off_permission_condition_Dic_0[rowValues['HDMP_UNVLBL_CD']]) << 0) + \
                                              (int(SendADstatus.Gamma_Hands_off_permission_condition_Dic_1[rowValues['TD_CNDTN_STTS_CD']]) << 1) + \
                                              (int(SendADstatus.Gamma_Hands_off_permission_condition_Dic_2[rowValues['STRR_QST_STTS_CD']]) << 2) + \
                                              (int(SendADstatus.Gamma_Hands_off_permission_condition_Dic_3[rowValues['HNDS_ON_RQST_STTS_CD']]) << 3) + \
                                              (int(SendADstatus.Gamma_Hands_off_permission_condition_Dic_4[rowValues['IS_AT_LCCTV_CD']]) << 4) + \
                                              (int(SendADstatus.Gamma_Hands_off_permission_condition_Dic_5[rowValues['SMLL_CRV_DTCTD_CD']]) << 5) + \
                                              (int(SendADstatus.Gamma_Hands_off_permission_condition_Dic_6[rowValues['MP_INFRMTN_NN_CD']]) << 6) + \
                                              (int(SendADstatus.Gamma_Hands_off_permission_condition_Dic_7[rowValues['LK_INHBTD_AR_BY_MP_INF_CD']]) << 7) + \
                                              (int(SendADstatus.Gamma_Hands_off_permission_condition_Dic_8[rowValues['MRG_AR_IS_LSS_THN_50M_CD']]) << 8) + \
                                              (int(SendADstatus.Gamma_Hands_off_permission_condition_Dic_9[rowValues['IS_LDP_ACTV_CD']]) << 9) + \
                                              (int(SendADstatus.Gamma_Hands_off_permission_condition_Dic_10[rowValues['IS_LK_GN_UNDR0_95_CD']]) << 10) + \
                                              (int(SendADstatus.Gamma_Hands_off_permission_condition_Dic_11[rowValues['IVI_INVLD_PSTN_CD']]) << 11) + \
                                              (int(SendADstatus.Gamma_Hands_off_permission_condition_Dic_12[rowValues['IS_MN_RD_LSS_THN_13KM_CD']]) << 12) + \
                                              (int(SendADstatus.Gamma_Hands_off_permission_condition_Dic_13[rowValues['AD2_INHBT_BY_FL_SF_CD']]) << 13) + \
                                              (int(SendADstatus.Gamma_Hands_off_permission_condition_Dic_14[rowValues['IS_JNCTN_OR_RMP_OR_OTHR_CD']]) << 14) + \
                                              (int(SendADstatus.Gamma_Hands_off_permission_condition_Dic_15[rowValues['IS_BRNCH_AR_LSS_THN_30M_CD']]) << 15)
        self.Target_Relative_speed_FCA_ = float(rowValues['TRGT_RLTV_SPD_FCA_NMBR'])
        self.LeftEyeCenterPosition_X = float(rowValues['LFT_EY_CNTR_PSTN_X_NMBR'])
        self.RightEyeCenterPosition_X = float(rowValues['RGHT_EY_CNTR_PSTN_X_NMBR'])
        self.LeftEyeCenterPosition_Y = float(rowValues['LFT_EY_CNTR_PSTN_Y_NMBR'])
        self.RightEyeCenterPosition_Y = float(rowValues['RGHT_EY_CNTR_PSTN_Y_NMBR'])
        self.LeftEyeCenterPosition_Z = float(rowValues['LFT_EY_CNTR_PSTN_Z_NMBR'])
        self.Target_recognition_state_of_EAP2 = int(SendADstatus.Gamma_Target_recognition_state_of_EAP2_Dic[rowValues['TRGT_RCGNTN_STT_OF_EAP2_CD']])
        self.Full_auto_parking_operational_status = int(SendADstatus.Gamma_Full_auto_parking_operational_status_Dic[rowValues['FLL_AT_PRKNG_OPRTNL_STTS_CD']])
        self.Remote_parking_operational_status = int(SendADstatus.Gamma_Remote_parking_operational_status_Dic[rowValues['RMT_PRKNG_OPRTNL_STTS_CD']])
        self.MakeLabel_suggestion_route_modification_situation = int(SendADstatus.Gamma_MakeLabel_suggestion_route_modification_situation_Dic[rowValues['MK_LBL_SGGSTD_RT_MDFCTN_CD']])
        self.RightEyeCenterPosition_Z = float(rowValues['RGHT_EY_CNTR_PSTN_Z_NMBR'])
        self.EyesDirection_Yaw = float(rowValues['EYS_DRCTN_YW_NMBR'])
        self.EyesDirection_Pitch = float(rowValues['EYS_DRCTN_PTCH_NMBR'])
        self.Precedent_car_recognition_state_of_FEB_EAP = (int(SendADstatus.Gamma_Precedent_car_recognition_state_of_FEB_EAP_Dic[rowValues['PRCDNT_CR_RCGNTN_FEB_TRGT_LCK_CD']]) << 0) + \
                                                          (int(SendADstatus.Gamma_Precedent_car_recognition_state_of_FEB_EAP_Dic[rowValues['PRCDNT_CR_RCGNTN_EAP_TRGT_LCK_CD']]) << 1)
        self.Expressway_judgment_NAVI_ = int(SendADstatus.Gamma_Expressway_judgment_NAVI_Dic[rowValues['EXPRSS_WY_JDGMNT_NV_CD']])
        self.CRC = int(rowValues['CRC_CD_NMBR'])
        self.mileage = int(rowValues['MLG_NMBR'])
        self.EDR_Trigger = (int(rowValues['EDR_TRGGR_ARBG_CD']) << 0) + \
                           (int(rowValues['EDR_TRGGR_SDDN_BRK_CD']) << 1) + \
                           (int(rowValues['EDR_TRGGR_DFCT_CD']) << 2) + \
                           (int(rowValues['EDR_TRGGR_BRK_ALRM_CD']) << 3) + \
                           (int(rowValues['EDR_TRGGR_FRNT_CLLSN_AVDNC_CD']) << 4) + \
                           (int(rowValues['EDR_TRGGR_SDDN_STPPNG_GRVTY_CD']) << 5) + \
                           (int(rowValues['EDR_TRGGR_SDDN_TRN_CD']) << 6)
        self._sequenceAfterParse()
        
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.Privacy_mode_IVI_ = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Privacy_mode_HDMap_ = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Inter_vehicular_distance_front_ = readFunc(int,10,readFromLSB=True,endian='little') * (0.125) + (0)
        self.Inter_vehicular_distance_right_front_ = readFunc(int,10,True,readFromLSB=True,endian='little') * (0.125) + (0)
        self.Inter_vehicular_distance_left_front_ = readFunc(int,10,True,readFromLSB=True,endian='little') * (0.125) + (0)
        self.Inter_vehicular_distance_right_rear_ = readFunc(int,10,True,readFromLSB=True,endian='little') * (0.125) + (-20)
        self.Inter_vehicular_distance_left_rear_ = readFunc(int,10,True,readFromLSB=True,endian='little') * (0.125) + (-20)
        self.Yaw_angle = readFunc(int,4,True,readFromLSB=True,endian='little') * (0.625) + (0.625)
        self.Localization_confidence = readFunc(int,4,readFromLSB=True,endian='little') * (6.6666666) + (0)
        self.Drive_force_control_command = readFunc(int,4,True,readFromLSB=True,endian='little') * (375) + (375)
        self.Brake_fluid_pressure_control_command_AEB_ = readFunc(int,7,readFromLSB=True,endian='little') * (95) + (0)
        self.Steering_angle_control_command = readFunc(int,9,True,readFromLSB=True,endian='little') * (0.5) + (0)
        self.Fault_Status_of_Mapecu = readFunc(int,8,readFromLSB=True,endian='little') * (1) + (0)
        self.Detection_of_hands_on_by_Steering_torque = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Steering_override = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.P2P_state = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Auto_overtaking_function = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Auto_Lanechanging_function = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Presence_absence_of_camera_correction_information = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Consistency_between_camera_vision_and_hdmap = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Localization = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Path_planner = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Route_planner = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Map_for_HMI = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Map_for_OD = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Navi_settings_Rear_Automatic_Braking = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Navi_settings_Driver_monitor = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Navi_settings_Lane_departure_warning = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Navi_settings_Lane_departure_prevention = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Navi_settings_Blind_spot_warning = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Navi_settings_Blind_spot_intervention = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Navi_settings_Traffic_signs_recognition = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Navi_settings_Steering_assist = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Navi_settings_Forward_emergency_braking = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Navi_settings_TSR_vehicle_speed_adjustment = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.Navi_settings_Sequence_exit = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Which_lane_number_running = readFunc(int,4,readFromLSB=True,endian='little') * (1) + (0)
        self.Number_of_lane = readFunc(int,4,readFromLSB=True,endian='little') * (1) + (0)
        self.Status_of_data_receiving_from_IVI = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Linkage_status_between_SDmap_and_HDmap = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.CP_longi = readFunc(int,5,readFromLSB=True,endian='little') * (2) + (0)
        self.CP_lat = readFunc(int,8,True,readFromLSB=True,endian='little') * (0.1625) + (0)
        self.InterVehicularDistanceICC = readFunc(int,8,readFromLSB=True,endian='little') * (0.5) + (0)
        self.Cancel_code = readFunc(int,8,readFromLSB=True,endian='little') * (1) + (0)
        self.ND2_code = readFunc(int,10,readFromLSB=True,endian='little') * (1) + (0)
        self.Status_transition_of_ADAS = readFunc(int,6,readFromLSB=True,endian='little') * (1) + (0)
        self.Curvature = readFunc(int,8,True,readFromLSB=True,endian='little') * (39.0625) + (39.0625)
        self.Wiper_mode = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Check_latest_version = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.HDMAP_freshness_information = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.AD2_emergency_stop_flag = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Sheet_belt = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Lane_projection_state = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.With_or_without_HDMAP_flag = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.License_state = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.GPS_Latitude = readFunc(int,31,True,readFromLSB=True,endian='little') * (0.0000001) + (0)
        self.GPS_Longitude = readFunc(int,32,True,readFromLSB=True,endian='little') * (0.0000001) + (0)
        self.GPS_UTC_Timestamp_Year_ = readFunc(int,6,readFromLSB=True,endian='little') * (1) + (2000)
        self.Shift_position = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.GPS_UTC_Timestamp_Month_ = readFunc(int,4,readFromLSB=True,endian='little') * (1) + (0)
        self.Winker = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Deviation_warning = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Approch_warning = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.GPS_UTC_Timestamp_Day_ = readFunc(int,5,readFromLSB=True,endian='little') * (1) + (0)
        self.PKB_control_command = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Brake_lamp_command = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.LDP_BSI_operation_status = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.GPS_UTC_Timestamp_Hour_ = readFunc(int,5,readFromLSB=True,endian='little') * (1) + (0)
        self.Steering_SW = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.GPS_UTC_Timestamp_Minute_ = readFunc(int,6,readFromLSB=True,endian='little') * (1) + (0)
        self.Switch_of_door = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Turn_signal_switch = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.Relative_velocity_of_ICC_target = readFunc(int,4,True,readFromLSB=True,endian='little') * (1.56) + (-7.8)
        self.Flag_of_jyro = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Flag_of_accelerometer = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Flag_of_GNSS = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Press_degree_of_accelerator = readFunc(int,5,readFromLSB=True,endian='little') * (3.25) + (0)
        self.Steering_torque_sensor = readFunc(int,5,True,readFromLSB=True,endian='little') * (0.25) + (0)
        self.Brake_pedal_stroke = readFunc(int,4,readFromLSB=True,endian='little') * (3.5) + (-3.5)
        self.Engine_RPM = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.AD_Localization_Latitude = readFunc(int,31,True,readFromLSB=True,endian='little') * (360/((2**32)-1)) + (0)
        self.AD_Localization_Longitude = readFunc(int,32,True,readFromLSB=True,endian='little') * (360/((2**32)-1)) + (0)
        self.Target_vehicle_speed_for_AD2 = readFunc(int,8,readFromLSB=True,endian='little') * (1) + (0)
        self.Real_Vehicle_speed = readFunc(int,8,readFromLSB=True,endian='little') * (0.784313725) + (0)
        self.Lateral_acceleration = readFunc(int,6,True,readFromLSB=True,endian='little') * (0.04) + (0)
        self.Steering_angle = readFunc(int,10,True,readFromLSB=True,endian='little') * (0.375) + (0)
        self.Yaw_rate = readFunc(int,8,True,readFromLSB=True,endian='little') * (0.4) + (0)
        self.Face_direction_Yaw_ = readFunc(int,8,readFromLSB=True,endian='little') * (1) + (-90)
        self.Face_direction_Pitch_ = readFunc(int,7,readFromLSB=True,endian='little') * (1) + (-45)
        self.Flag_of_car_position_message = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Face_direction_Roll_ = readFunc(int,7,readFromLSB=True,endian='little') * (1) + (-64)
        self.The_preceding_vehicle_determination_flag_TJP_stopping_item_ = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Closure_status_of_right_eye = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.distraction = readFunc(int,6,readFromLSB=True,endian='little') * (1) + (0)
        self.Closure_status_of_left_eye = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Sleepiness = readFunc(int,6,readFromLSB=True,endian='little') * (1) + (0)
        self.Driver_monitoring = readFunc(int,4,readFromLSB=True,endian='little') * (1) + (0)
        self.The_preceding_vehicle_determination_flag_TJP_moving_item_ = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Master_cylinder_fluid_pressure = readFunc(int,8,readFromLSB=True,endian='little') * (1) + (0)
        self.Motion_status = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.Camera_motion_status = readFunc(int,4,readFromLSB=True,endian='little') * (1) + (0)
        self.ON_OFF_of_driver_brakes_working_conditions = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.OFF_ON_of_stop_lamp_lighting_state = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.PKB_control_state = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Inter_vehicular_distance_Camera_ = readFunc(int,12,readFromLSB=True,endian='little') * (0.05) + (0)
        self.Camera_lateral_position = readFunc(int,12,True,readFromLSB=True,endian='little') * (0.05) + (0)
        self.Camera_relative_speed = readFunc(int,12,True,readFromLSB=True,endian='little') * (0.05) + (0)
        self.Camera_object_identification = readFunc(int,4,readFromLSB=True,endian='little') * (1) + (0)
        self.Stop_maintenance_control_state = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Radar_object_identification = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.ON_OFF_of_meter_illuminations_demand = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Inter_vehicular_distance_Radar_ = readFunc(int,11,readFromLSB=True,endian='little') * (0.1) + (0)
        self.Radar_lateral_position = readFunc(int,10,True,readFromLSB=True,endian='little') * (0.1) + (0)
        self.Radar_relative_speed = readFunc(int,13,True,readFromLSB=True,endian='little') * (0.025) + (0)
        self.Setting_inter_vehicular = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Brake_fluid_pressure_control_command_ICC_ = readFunc(int,7,readFromLSB=True,endian='little') * (25) + (0)
        self.Navi_settings_with_or_without_Hands_off_permission = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.The_reason_that_Hands_off_is_prohibited = readFunc(int,12,readFromLSB=True,endian='little') * (1) + (0)
        self.Time_to_control_point = readFunc(int,5,readFromLSB=True,endian='little') * (0.05) + (0)
        self.Status_of_lane_changing_possibility = readFunc(int,12,readFromLSB=True,endian='little') * (1) + (0)
        self.Fixed_recognition_information_of_lane = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Own_car_position_safety_zone_information = readFunc(int,4,readFromLSB=True,endian='little') * (1) + (0)
        self.Sensor_of_sitting_dowm = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Detection_of_hands_on_or_off_by_touch_sensor = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Expressway_judgment = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.ICC_Inter_vehicular_distance_information_of_witch_Sensor = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.Lane_changing_direction = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Right_lane_position = readFunc(int,6,True,readFromLSB=True,endian='little') * (0.1) + (0)
        self.Left_lane_position = readFunc(int,6,True,readFromLSB=True,endian='little') * (0.1) + (0)
        self.GPS_precision_information = readFunc(int,7,readFromLSB=True,endian='little') * (0.1) + (0)
        self.ADAS_blinker_control_flag = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.ADAS_blinker_demand_level = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.AD_Localization_Altitude = readFunc(int,13,readFromLSB=True,endian='little') * (1) + (-400)
        self.AD_Localization_Yaw_angle = readFunc(int,16,readFromLSB=True,endian='little') * (0.0001) + (0)
        self.IVI_Speed_Limit = readFunc(int,6,readFromLSB=True,endian='little') * (1) + (0)
        self.IVI_Curvature = readFunc(int,10,readFromLSB=True,endian='little') * (1) + (0)
        self.IVI_Dist_Exit = readFunc(int,8,readFromLSB=True,endian='little') * (10) + (0)
        self.IVI_Dist_TG = readFunc(int,8,readFromLSB=True,endian='little') * (10) + (0)
        self.Road_classification_of_navi = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.With_or_without_nearest_LaneLinkID_revision = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.ALC_approval_state = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.Control_source_choice_result = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.Lane_recommendation_degree_MapECU_calculation_result_ = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Lane_recommendation_degree_MakeLabel_calculation_result_ = readFunc(int,6,readFromLSB=True,endian='little') * (1) + (0)
        self.eCall = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.TSR_Last_choice_level_ = readFunc(int,5,readFromLSB=True,endian='little') * (5) + (0)
        self.TSR_HDMAP_level_ = readFunc(int,5,readFromLSB=True,endian='little') * (5) + (0)
        self.TSR_Camera_ = readFunc(int,5,readFromLSB=True,endian='little') * (5) + (0)
        self.HDMAP_run_route_addition_information = readFunc(int,16,readFromLSB=True,endian='little') * (1) + (0)
        self.HDMAP_output_situation = readFunc(int,6,readFromLSB=True,endian='little') * (1) + (0)
        self.Path_information_diagnosis_result_of_the_ICI_Mayor_of_course = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.On_Off_of_NAVI_ICC = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.NAVI_ICC_target_speed = readFunc(int,8,readFromLSB=True,endian='little') * (0.784313725) + (0)
        self.ICC_target_speed = readFunc(int,8,readFromLSB=True,endian='little') * (0.784313725) + (0)
        self.InterVehicularDistanceICC_Target = readFunc(int,8,readFromLSB=True,endian='little') * (0.5) + (0)
        self.Steering_angle_servo_gain = readFunc(int,5,readFromLSB=True,endian='little') * (0.0625) + (0)
        self.LC_cancellation_reason = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.Aim_Control_Point_side_position = readFunc(int,8,True,readFromLSB=True,endian='little') * (0.1625) + (0)
        self.PathPlanner_map_pp_status = readFunc(int,8,readFromLSB=True,endian='little') * (1) + (0)
        self.PathPlanner_flags = readFunc(int,8,readFromLSB=True,endian='little') * (1) + (0)
        self.Lane_changing_reason = readFunc(int,4,readFromLSB=True,endian='little') * (1) + (0)
        self.Passing_prohibition_information = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Number_of_MaleLabel_suggestion_routes = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Remaining_distance_of_lane_changing_possibility = readFunc(int,5,readFromLSB=True,endian='little') * (100) + (0)
        self.Driver_Guidance = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.Hands_on_demand_reason_from_Lateral = readFunc(int,4,readFromLSB=True,endian='little') * (1) + (0)
        self.LC_internal_control_state = readFunc(int,4,readFromLSB=True,endian='little') * (1) + (0)
        self.Wide_control_internal_control_state = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.Long_control_internal_control_state = readFunc(int,4,readFromLSB=True,endian='little') * (1) + (0)
        self.FEB_Warning_cyclist = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.FEB_Warning_Pedestrian = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.FEB_Malfunction_OFF_indicator = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.FEB_Temporary_Failure = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.FEB_Warning_Vehicle = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.RrAEB_Malfunction = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.RrAEB_OFF_indicator = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.RrAEB_warning = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.TSR_Temporary_Failure = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.LDP_Temporary_Failure = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.LDP_Temporary_Failure_Camera_ = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.LDW_Temporary_Failure = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.LDP_Malfunction = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.LDW_Malfunction = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.BSI_Tempprary_Failure_SideRadar_ = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.BSI_Tempprary_Failure = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.BSI_Tempprary_Failure_Camera_ = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.BSI_Malfunction = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.ACC_Malfunction = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.ACC_Temporary_Failure = readFunc(int,5,readFromLSB=True,endian='little') * (1) + (0)
        self.LCA_Malfunction = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.LCA_Message_HW_ = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.LCA_Temporary_Failure = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.DAA_Warning = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.EAP_Warning = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Current_Form_Of_Way = readFunc(int,4,readFromLSB=True,endian='little') * (1) + (0)
        self.TSR_Status_ = readFunc(int,4,readFromLSB=True,endian='little') * (1) + (0)
        self.Own_car_position_reliability_flag_information = readFunc(int,19,readFromLSB=True,endian='little') * (1) + (0)
        self.P2P_giveup_information = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Priority_of_number_of_MaleLabel_suggestion_routes = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Wide_control_permission_judgment_in_the_map_information = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Warning_indication_for_AD2 = readFunc(int,8,readFromLSB=True,endian='little') * (1) + (0)
        self.Notice_of_driver_for_AD2 = readFunc(int,8,readFromLSB=True,endian='little') * (1) + (0)
        self.Notice_of_cancellation_for_AD2 = readFunc(int,8,readFromLSB=True,endian='little') * (1) + (0)
        self.TD_MRM_indication_for_AD2 = readFunc(int,5,readFromLSB=True,endian='little') * (1) + (0)
        self.Announcement_sound_for_AD2_Group1_ = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.Announcement_sound_for_AD2_Group2_ = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.Announcement_sound_for_AD2_Group3_ = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.Announcement_sound_for_AD2_Group4_ = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Announcement_sound_for_AD2_Group5_ = readFunc(int,3,readFromLSB=True,endian='little') * (1) + (0)
        self.Hands_off_permission_condition = readFunc(int,16,readFromLSB=True,endian='little') * (1) + (0)
        self.Target_Relative_speed_FCA_ = readFunc(int,6,True,readFromLSB=True,endian='little') * (0.78) + (-15.6)
        self.LeftEyeCenterPosition_X = readFunc(int,7,readFromLSB=True,endian='little') * (10) + (800)
        self.RightEyeCenterPosition_X = readFunc(int,7,readFromLSB=True,endian='little') * (10) + (800)
        self.LeftEyeCenterPosition_Y = readFunc(int,7,True,readFromLSB=True,endian='little') * (10) + (0)
        self.RightEyeCenterPosition_Y = readFunc(int,7,True,readFromLSB=True,endian='little') * (10) + (0)
        self.LeftEyeCenterPosition_Z = readFunc(int,6,readFromLSB=True,endian='little') * (10) + (800)
        self.Target_recognition_state_of_EAP2 = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Full_auto_parking_operational_status = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.Remote_parking_operational_status = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.MakeLabel_suggestion_route_modification_situation = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.RightEyeCenterPosition_Z = readFunc(int,6,readFromLSB=True,endian='little') * (10) + (800)
        self.EyesDirection_Yaw = readFunc(int,8,True,readFromLSB=True,endian='little') * (1) + (0)
        self.EyesDirection_Pitch = readFunc(int,7,True,readFromLSB=True,endian='little') * (1) + (0)
        self.Precedent_car_recognition_state_of_FEB_EAP = readFunc(int,2,readFromLSB=True,endian='little') * (1) + (0)
        self.Expressway_judgment_NAVI_ = readFunc(int,1,readFromLSB=True,endian='little') * (1) + (0)
        self.CRC = readFunc(int,8,readFromLSB=True,endian='little') * (1) + (0)
        self.mileage = readFunc(int,24,readFromLSB=True,endian='little') * (1) + (0)
        self.EDR_Trigger = readFunc(int,8,readFromLSB=True,endian='little') * (1) + (0)
        self.assertMessageSize()
        
        # P61Q車両から、self.Navi_settings_Blind_spot_warning　を、Steering SWの上位bitとして使うようになった。
        # そもそもself.Navi_settings_Blind_spot_warningは、常に0で使ってなかったので、全ての車種において、これをSteering SWの上位bitとしてみなす処理をしても良いと思われmる。
        # また、Gamma側から取得するレコードについては、既に、Navi_settings_Blind_spot_warningの値を、Steering SWに入れる処理がされているので、そのparse処理には追加する必要なく、このbinaryからのparseでのみ行う。
        self.Steering_SW = self.Navi_settings_Blind_spot_warning * 8 + self.Steering_SW
        
        self._sequenceAfterParse()
    
    def _sequenceAfterParse(self):
        if self.Status_transition_of_ADAS >= 40 and self.Status_transition_of_ADAS <= 45:
            self.ad_status_group = 2
        elif (self.Status_transition_of_ADAS >= 30 and self.Status_transition_of_ADAS <= 39) or (self.Status_transition_of_ADAS >= 50 and self.Status_transition_of_ADAS <= 60):
            self.ad_status_group = 1
        else:
            self.ad_status_group = 0
            
        SendADstatus.Summery_TotalRecordCount += 1
        if self.ad_status_group in SendADstatus.Summery_ADStatusGroup:
            SendADstatus.Summery_ADStatusGroup[self.ad_status_group]['count'] += 1
        else:
            SendADstatus.Summery_ADStatusGroup[self.ad_status_group] = {}
            SendADstatus.Summery_ADStatusGroup[self.ad_status_group]['count'] = 1
            SendADstatus.Summery_ADStatusGroup[self.ad_status_group]['length'] = 0
            
        if self.ND2_code in SendADstatus.Summery_ND2Code:
            SendADstatus.Summery_ND2Code[self.ND2_code]['count'] += 1
        else:
            SendADstatus.Summery_ND2Code[self.ND2_code] = {}
            SendADstatus.Summery_ND2Code[self.ND2_code]['count'] = 1
            SendADstatus.Summery_ND2Code[self.ND2_code]['length'] = 0
            
        if self.Cancel_code in SendADstatus.Summery_CancelCode:
            SendADstatus.Summery_CancelCode[self.Cancel_code]['count'] += 1
        else:
            SendADstatus.Summery_CancelCode[self.Cancel_code] = {}
            SendADstatus.Summery_CancelCode[self.Cancel_code]['count'] = 1
            SendADstatus.Summery_CancelCode[self.Cancel_code]['length'] = 0
            
        if self.The_reason_that_Hands_off_is_prohibited in SendADstatus.Summery_HandOffProhibit:
            SendADstatus.Summery_HandOffProhibit[self.The_reason_that_Hands_off_is_prohibited]['count'] += 1
        else:
            SendADstatus.Summery_HandOffProhibit[self.The_reason_that_Hands_off_is_prohibited] = {}
            SendADstatus.Summery_HandOffProhibit[self.The_reason_that_Hands_off_is_prohibited]['count'] = 1
            SendADstatus.Summery_HandOffProhibit[self.The_reason_that_Hands_off_is_prohibited]['length'] = 0

    def printHeader(self, sheet, row, col, _level = 1):        
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col)
        if getLocal() == 'ja_JP':
            headerList = [
                'Privacy mode(IVI)',
                'Privacy mode(HDMap)',
                '車間距離(真ん前)',
                '車間距離_前右',
                '車間距離_前左',
                '車間距離_後右',
                '車間距離_後左',
                'ヨー角',
                'ローカリゼーション confidence',
                '駆動力制御指令',
                'ブレーキ液圧制御指令',
                '舵角制御指令',
                'MPU異常ステータス',
                'ステアトルクでのHandsOn検知',
                'オーバーライド',
                'P2P状態',
                '自動追い越し機能',
                'オートレーンチェンジ機能 ドライバートリガー',
                'カメラ補正情報有無',
                'カメラ検出結果vsHDmapの整合度',
                'Localization',
                'Path planner',
                'Route planner',
                'Map for HMI',
                'Map for OD',
                'Navi設定値 後方衝突防止支援',
                'Navi設定値 ドライバーモニタ',
                'Navi設定値 車線逸脱警報',
                'Navi設定値 車線逸脱防止支援',
                'Navi設定値 後側方車両検知警報',
                'Navi設定値 後側方衝突防止支援',
                'Navi設定値 制限速度支援',
                'Navi設定値 ハンドル支援',
                'Navi設定値 エマージェンシーブレーキ',
                'Navi設定値 TSR車速調整',
                'Navi設定値 出口シーケンス',
                '走行レーン番号',
                'レーン数',
                'IVIデータ受信状態',
                'MapLinkage状態',
                'CP_longi',
                'CP_lat',
                'ICC車間距離',
                'キャンセルコード',
                'ND2コード',
                '状態遷移図の遷移状態',
                '曲率',
                'ワイパー動作',
                '最新Ver確認',
                '鮮度情報',
                'AD2緊急停止',
                'シートベルト',
                'レーン投影状態',
                'HDMAP有無',
                'ライセンス状態',
                'GPS_Latitude(緯度)',
                'GPS_Longitude(経度)',
                'GPS_UTC_Timestamp(Year)',
                'シフトポジション（ギヤ位置含む）',
                'GPS_UTC_Timestamp(Month)',
                'ウィンカー',
                '逸脱警報',
                '接近警報',
                'GPS_UTC_Timestamp(Day)',
                'PKB制御指令',
                'ブレーキランプ駆動指令',
                'LDP/BSI作動状態',
                'GPS_UTC_Timestamp(Hour)',
                'Steering SW',
                'GPS_UTC_Timestamp(Minute)',
                'ドアスイッチ',
                'ターンシグナルスイッチ',
                'ICCターゲット相対速',
                'ジャイロ無効フラグ',
                '加速度センサ無効フラグ',
                'GNSS無効フラグ',
                'アクセル開度',
                'ステアリングトルクセンサー',
                'ブレーキペダルストローク',
                'エンジン回転数',
                'AD自己位置(Latitude)',
                'AD自己位置(Longitude)',
                '設定車速',
                '車速',
                '横加速度',
                '舵角',
                'ヨーレート',
                'DMS_FD_YAW ',
                'DMS_FD_PCH',
                'Car Position msg無効フラグ(ロケータ）',
                'DMS_FD_ROL',
                '先行車確定フラグ(TJP / 停止物)',
                'DMS_EYE_R ',
                'distraction',
                'DMS_EYE_L ',
                'Sleepiness',
                'ドライバーモニター',
                '先行車確定フラグ(TJP / 移動物)',
                'マスターシリンダ液圧',
                'モーションステータス',
                'カメラモーションステータス',
                'ドライバブレーキ作動状態',
                'ブレーキランプ点灯状態',
                'PKB制御状態',
                'カメラ車間距離',
                'カメラ横位置',
                'カメラ相対速度',
                'カメラ物体識別',
                '停止保持制御状態',
                'レーダー物体識別',
                'メーターイルミネーション要求',
                'レーダー車間距離',
                'レーダー横位置',
                'レーダー相対速度',
                '設定車間',
                'ブレーキ液圧制御指令(ICC)',
                'Navi設定値 Hands off許可の有無',
                'Hands offが禁止される理由',
                '制御点までの時間',
                '車線変更可否判断情報',
                '車線認識確定情報',
                '自車位置中央分離帯情報',
                '着座センサ',
                'タッチセンサでのHands On/Off検知',
                '高速道路判定',
                'どのセンサのICC車間距離情報なのか',
                '車線変更方向',
                '右レーン位置',
                '左レーン位置',
                'GPS精度情報',
                'ADASウィンカー制御フラグ',
                'ADASウィンカー要求値',
                'AD自己位置(Altitude)',
                'AD自己位置(方位角)',
                'IVI_Speed_Limit',
                'IVI_Curvature',
                'IVI_Dist_Exit',
                'IVI_Dist_TG',
                'Naviの道路種別',
                '最寄LaneLinkID補正有無',
                'ALC承認状態',
                '制御ソース選択結果',
                'レーン推奨度(MapECU計算結果)',
                'レーン推奨度(MakeLabel計算結果)',
                'eCall',
                'TSR(最終選択値）',
                'TSR(HDマップ値）',
                'TSR(Camera）',
                'HDMAP走行ルート付加情報',
                'HDMAP出力状況',
                'IVI経路長の十分性診断結果',
                'NAVI ICC目標速度のOn/Off',
                'NAVI ICC目標速度',
                'ICC目標速度',
                'ICC目標車間距離',
                '舵角サーボゲイン',
                'LCキャンセル理由',
                '目標制御点横位置',
                'PathPlanner: map_pp_status',
                'PathPlanner: flags',
                '車線変更理由',
                '追い越し禁止情報',
                'MakeLabel提案ルート数',
                '車線変更可能残距離',
                'Driver Guidance',
                'Lateralからのハンズオン要求理由',
                'LC内部制御状態（全State）',
                '横制御内部制御状態',
                '縦制御内部状態',
                'FEB Warning cyclist',
                'FEB Warning Pedestrian',
                'FEB Malfunction / OFF indicator',
                'FEB Temporary Failure',
                'FEB Warning Vehicle',
                'RrAEB Malfunction',
                'RrAEB OFF indicator',
                'RrAEB warning',
                'TSR Temporary Failure',
                'LDP Temporary Failure',
                'LDP Temporary Failure (Camera)',
                'LDW Temporary Failure',
                'LDP Malfunction',
                'LDW Malfunction',
                'BSI Tempprary Failure (SideRadar)',
                'BSI Tempprary Failure',
                'BSI Tempprary Failure (Camera)',
                'BSI Malfunction',
                'ACC Malfunction',
                'ACC Temporary Failure',
                'LCA Malfunction',
                'LCA Message (HW)',
                'LCA Temporary Failure',
                'DAA Warning',
                'EAP Warning',
                'Current Form Of Way',
                'TSR(Status)',
                '自車位置信頼度フラグ情報',
                'P2Pgiveup情報',
                'MakeLabel提案ルート数提案ルート優先度',
                '地図情報での横制御許可判定',
                'AD2用警告表示',
                'AD2用ドライバー通知',
                'AD2用キャンセル通知',
                'AD2用TD/MRM表示',
                'AD2用吹聴音Group1',
                'AD2用吹聴音Group2',
                'AD2用吹聴音Group3',
                'AD2用吹聴音Group4',
                'AD2用吹聴音Group5',
                'ハンズオフ許可条件',
                'FCAターゲット相対速度',
                'LeftEyeCenterPosition_X',
                'RightEyeCenterPosition_X',
                'LeftEyeCenterPosition_Y',
                'RightEyeCenterPosition_Y',
                'LeftEyeCenterPosition_Z',
                'EAP2のターゲット認識状態',
                'FAPの作動状態',
                'RPKの作動状態',
                'MakeLabel提案ルート改変状況',
                'RightEyeCenterPosition_Z',
                'EyesDirection_Yaw',
                'EyesDirection_Pitch',
                'FEB/EAP の先行車認識状態',
                '高速道路判定（NAVI）',
                'データ整合性コード',
                '走行距離',
                'EDRトリガー'
                ]
        else:    
            headerList = [
                'Privacy mode(IVI)',
                'Privacy mode(HDMap)',
                'Inter-vehicular distance(front)',
                'Inter-vehicular distance(right front)',
                'Inter-vehicular distance(left front)',
                'Inter-vehicular distance(right rear)',
                'Inter-vehicular distance(left rear)',
                'Yaw angle',
                'Localization confidence',
                'Drive force control command',
                'Brake fluid pressure control command(AEB)',
                'Steering angle control command',
                'Fault Status of Mapecu',
                'Detection of hands-on by Steering torque',
                'Steering override',
                'P2P state',
                'Auto-overtaking function',
                'Auto-Lanechanging function',
                'Presence / absence of camera correction information',
                'Consistency between camera vision and hdmap',
                'Localization',
                'Path planner',
                'Route planner',
                'Map for HMI',
                'Map for OD',
                'Navi settings Rear Automatic Braking',
                'Navi settings Driver monitor',
                'Navi settings Lane departure warning',
                'Navi settings Lane departure prevention',
                'Navi settings Blind spot warning',
                'Navi settings Blind spot intervention',
                'Navi settings Traffic signs recognition',
                'Navi settings Steering assist',
                'Navi settings Forward emergency braking',
                'Navi settings TSR vehicle speed adjustment',
                'Navi settings Sequence exit',
                'Which lane number running',
                'Number of lane',
                'Status of data receiving from IVI',
                'Linkage status between SDmap and HDmap',
                'CP_longi',
                'CP_lat',
                'InterVehicularDistanceICC',
                'Cancel code',
                'ND2 code',
                'Status transition of ADAS',
                'Curvature',
                'Wiper mode',
                'Check latest version',
                'HDMAP freshness information',
                'AD2 emergency stop flag',
                'Sheet belt',
                'Lane projection state',
                'With or without HDMAP flag',
                'License state',
                'GPS_Latitude',
                'GPS_Longitude',
                'GPS_UTC_Timestamp(Year)',
                'Shift position',
                'GPS_UTC_Timestamp(Month)',
                'Winker',
                'Deviation warning',
                'Approch warning',
                'GPS_UTC_Timestamp(Day)',
                'PKB control command',
                'Brake lamp command',
                'LDP/BSI operation status',
                'GPS_UTC_Timestamp(Hour)',
                'Steering SW',
                'GPS_UTC_Timestamp(Minute)',
                'Switch of door',
                'Turn signal switch',
                'Relative velocity of ICC target',
                'Flag of jyro',
                'Flag of accelerometer',
                'Flag of GNSS',
                'Press degree of accelerator',
                'Steering torque sensor',
                'Brake pedal stroke',
                'Engine RPM',
                'AD Localization_Latitude',
                'AD Localization_Longitude',
                'Target vehicle speed for AD2',
                'Real Vehicle speed',
                'Lateral acceleration',
                'Steering angle',
                'Yaw rate',
                'Face direction(Yaw)',
                'Face direction(Pitch)',
                'Flag of car position message',
                'Face direction(Roll)',
                'The preceding vehicle determination flag (TJP / stopping item)',
                'Closure status of right eye',
                'distraction',
                'Closure status of left eye',
                'Sleepiness',
                'Driver monitoring',
                'The preceding vehicle determination flag (TJP / moving item)',
                'Master cylinder fluid pressure',
                'Motion status',
                'Camera motion status',
                'ON/OFF of driver brakes working conditions',
                'OFF/ON of stop-lamp lighting state',
                'PKB control state',
                'Inter-vehicular distance(Camera)',
                'Camera lateral position',
                'Camera relative speed',
                'Camera object identification',
                'Stop maintenance control state',
                'Radar object identification',
                'ON/OFF of meter illuminations demand',
                'Inter-vehicular distance(Radar)',
                'Radar lateral position',
                'Radar relative speed',
                'Setting inter-vehicular',
                'Brake fluid pressure control command(ICC)',
                'Navi settings with or without Hands off permission',
                'The reason that Hands off is prohibited',
                'Time to control point',
                'Status of lane-changing possibility',
                'Fixed recognition information of lane',
                'Own car position safety zone information',
                'Sensor of sitting dowm',
                'Detection of hands-on or off by touch sensor',
                'Expressway judgment',
                'ICC Inter-vehicular distance information of witch Sensor',
                'Lane-changing direction',
                'Right lane position',
                'Left lane position',
                'GPS precision information',
                'ADAS blinker control flag',
                'ADAS blinker demand level',
                'AD Localization_Altitude',
                'AD Localization_Yaw angle',
                'IVI_Speed_Limit',
                'IVI_Curvature',
                'IVI_Dist_Exit',
                'IVI_Dist_TG',
                'Road classification of navi',
                'With or without nearest LaneLinkID revision',
                'ALC approval state',
                'Control source choice result',
                'Lane recommendation degree (MapECU calculation result)',
                'Lane recommendation degree (MakeLabel calculation result)',
                'eCall',
                'TSR(Last choice level)',
                'TSR(HDMAP level)',
                'TSR(Camera)',
                'HDMAP run route addition information',
                'HDMAP output situation',
                'Path information diagnosis result of the ICI Mayor of course',
                'On/Off of NAVI ICC',
                'NAVI ICC target speed',
                'ICC target speed',
                'InterVehicularDistanceICC Target',
                'Steering angle servo gain',
                'LC cancellation reason',
                'Aim Control Point side position',
                'PathPlanner: map_pp_status',
                'PathPlanner: flags',
                'Lane-changing reason',
                'Passing prohibition information',
                'Number of MaleLabel suggestion routes',
                'Remaining distance of lane-changing possibility',
                'Driver Guidance',
                'Hands on demand reason from Lateral',
                'LC internal control state',
                'Wide control internal control state',
                'Long control internal control state',
                'FEB Warning cyclist',
                'FEB Warning Pedestrian',
                'FEB Malfunction / OFF indicator',
                'FEB Temporary Failure',
                'FEB Warning Vehicle',
                'RrAEB Malfunction',
                'RrAEB OFF indicator',
                'RrAEB warning',
                'TSR Temporary Failure',
                'LDP Temporary Failure',
                'LDP Temporary Failure (Camera)',
                'LDW Temporary Failure',
                'LDP Malfunction',
                'LDW Malfunction',
                'BSI Tempprary Failure (SideRadar)',
                'BSI Tempprary Failure',
                'BSI Tempprary Failure (Camera)',
                'BSI Malfunction',
                'ACC Malfunction',
                'ACC Temporary Failure',
                'LCA Malfunction',
                'LCA Message (HW)',
                'LCA Temporary Failure',
                'DAA Warning',
                'EAP Warning',
                'Current Form Of Way',
                'TSR(Status)',
                'Own car position reliability flag information',
                'P2P giveup information',
                'Priority of number of MaleLabel suggestion routes',
                'Wide control permission judgment in the map information',
                'Warning indication for AD2',
                'Notice of driver for AD2',
                'Notice of cancellation for AD2',
                'TD/MRM indication for AD2',
                'Announcement sound for AD2 (Group1)',
                'Announcement sound for AD2 (Group2)',
                'Announcement sound for AD2 (Group3)',
                'Announcement sound for AD2 (Group4)',
                'Announcement sound for AD2 (Group5)',
                'Hands off permission condition',
                'Target Relative speed(FCA)',
                'LeftEyeCenterPosition_X',
                'RightEyeCenterPosition_X',
                'LeftEyeCenterPosition_Y',
                'RightEyeCenterPosition_Y',
                'LeftEyeCenterPosition_Z',
                'Target recognition state of EAP2',
                'Full auto parking operational status',
                'Remote parking operational status',
                'MakeLabel suggestion route modification situation',
                'RightEyeCenterPosition_Z',
                'EyesDirection_Yaw',
                'EyesDirection_Pitch',
                'Precedent car recognition state of FEB/EAP',
                'Expressway judgment(NAVI)',
                'Data consistency cord(CRC)',
                'mileage',
                'EDR Trigger'
                ]
            
        sheet.write_row(row, col, headerList, sheet.cellFormats('header'))
        col += len(headerList)
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        valueList = [
            self.Privacy_mode_IVI_,
            self.Privacy_mode_HDMap_,
            self.Inter_vehicular_distance_front_,
            self.Inter_vehicular_distance_right_front_,
            self.Inter_vehicular_distance_left_front_,
            self.Inter_vehicular_distance_right_rear_,
            self.Inter_vehicular_distance_left_rear_,
            self.Yaw_angle,
            self.Localization_confidence,
            self.Drive_force_control_command,
            self.Brake_fluid_pressure_control_command_AEB_,
            self.Steering_angle_control_command,
            self.Fault_Status_of_Mapecu,
            self.Detection_of_hands_on_by_Steering_torque,
            self.Steering_override,
            self.P2P_state,
            self.Auto_overtaking_function,
            self.Auto_Lanechanging_function,
            self.Presence_absence_of_camera_correction_information,
            self.Consistency_between_camera_vision_and_hdmap,
            self.Localization,
            self.Path_planner,
            self.Route_planner,
            self.Map_for_HMI,
            self.Map_for_OD,
            self.Navi_settings_Rear_Automatic_Braking,
            self.Navi_settings_Driver_monitor,
            self.Navi_settings_Lane_departure_warning,
            self.Navi_settings_Lane_departure_prevention,
            self.Navi_settings_Blind_spot_warning,
            self.Navi_settings_Blind_spot_intervention,
            self.Navi_settings_Traffic_signs_recognition,
            self.Navi_settings_Steering_assist,
            self.Navi_settings_Forward_emergency_braking,
            self.Navi_settings_TSR_vehicle_speed_adjustment,
            self.Navi_settings_Sequence_exit,
            self.Which_lane_number_running,
            self.Number_of_lane,
            self.Status_of_data_receiving_from_IVI,
            self.Linkage_status_between_SDmap_and_HDmap,
            self.CP_longi,
            self.CP_lat,
            self.InterVehicularDistanceICC,
            self.Cancel_code,
            self.ND2_code,
            self.Status_transition_of_ADAS,
            self.Curvature,
            self.Wiper_mode,
            self.Check_latest_version,
            self.HDMAP_freshness_information,
            self.AD2_emergency_stop_flag,
            self.Sheet_belt,
            self.Lane_projection_state,
            self.With_or_without_HDMAP_flag,
            self.License_state,
            self.GPS_Latitude,
            self.GPS_Longitude,
            self.GPS_UTC_Timestamp_Year_,
            self.Shift_position,
            self.GPS_UTC_Timestamp_Month_,
            self.Winker,
            self.Deviation_warning,
            self.Approch_warning,
            self.GPS_UTC_Timestamp_Day_,
            self.PKB_control_command,
            self.Brake_lamp_command,
            self.LDP_BSI_operation_status,
            self.GPS_UTC_Timestamp_Hour_,
            self.Steering_SW,
            self.GPS_UTC_Timestamp_Minute_,
            self.Switch_of_door,
            self.Turn_signal_switch,
            self.Relative_velocity_of_ICC_target,
            self.Flag_of_jyro,
            self.Flag_of_accelerometer,
            self.Flag_of_GNSS,
            self.Press_degree_of_accelerator,
            self.Steering_torque_sensor,
            self.Brake_pedal_stroke,
            self.Engine_RPM,
            self.AD_Localization_Latitude,
            self.AD_Localization_Longitude,
            self.Target_vehicle_speed_for_AD2,
            self.Real_Vehicle_speed,
            self.Lateral_acceleration,
            self.Steering_angle,
            self.Yaw_rate,
            self.Face_direction_Yaw_,
            self.Face_direction_Pitch_,
            self.Flag_of_car_position_message,
            self.Face_direction_Roll_,
            self.The_preceding_vehicle_determination_flag_TJP_stopping_item_,
            self.Closure_status_of_right_eye,
            self.distraction,
            self.Closure_status_of_left_eye,
            self.Sleepiness,
            self.Driver_monitoring,
            self.The_preceding_vehicle_determination_flag_TJP_moving_item_,
            self.Master_cylinder_fluid_pressure,
            self.Motion_status,
            self.Camera_motion_status,
            self.ON_OFF_of_driver_brakes_working_conditions,
            self.OFF_ON_of_stop_lamp_lighting_state,
            self.PKB_control_state,
            self.Inter_vehicular_distance_Camera_,
            self.Camera_lateral_position,
            self.Camera_relative_speed,
            self.Camera_object_identification,
            self.Stop_maintenance_control_state,
            self.Radar_object_identification,
            self.ON_OFF_of_meter_illuminations_demand,
            self.Inter_vehicular_distance_Radar_,
            self.Radar_lateral_position,
            self.Radar_relative_speed,
            self.Setting_inter_vehicular,
            self.Brake_fluid_pressure_control_command_ICC_,
            self.Navi_settings_with_or_without_Hands_off_permission,
            self.The_reason_that_Hands_off_is_prohibited,
            self.Time_to_control_point,
            self.Status_of_lane_changing_possibility,
            self.Fixed_recognition_information_of_lane,
            self.Own_car_position_safety_zone_information,
            self.Sensor_of_sitting_dowm,
            self.Detection_of_hands_on_or_off_by_touch_sensor,
            self.Expressway_judgment,
            self.ICC_Inter_vehicular_distance_information_of_witch_Sensor,
            self.Lane_changing_direction,
            self.Right_lane_position,
            self.Left_lane_position,
            self.GPS_precision_information,
            self.ADAS_blinker_control_flag,
            self.ADAS_blinker_demand_level,
            self.AD_Localization_Altitude,
            self.AD_Localization_Yaw_angle,
            self.IVI_Speed_Limit,
            self.IVI_Curvature,
            self.IVI_Dist_Exit,
            self.IVI_Dist_TG,
            self.Road_classification_of_navi,
            self.With_or_without_nearest_LaneLinkID_revision,
            self.ALC_approval_state,
            self.Control_source_choice_result,
            self.Lane_recommendation_degree_MapECU_calculation_result_,
            self.Lane_recommendation_degree_MakeLabel_calculation_result_,
            self.eCall,
            self.TSR_Last_choice_level_,
            self.TSR_HDMAP_level_,
            self.TSR_Camera_,
            self.HDMAP_run_route_addition_information,
            self.HDMAP_output_situation,
            self.Path_information_diagnosis_result_of_the_ICI_Mayor_of_course,
            self.On_Off_of_NAVI_ICC,
            self.NAVI_ICC_target_speed,
            self.ICC_target_speed,
            self.InterVehicularDistanceICC_Target,
            self.Steering_angle_servo_gain,
            self.LC_cancellation_reason,
            self.Aim_Control_Point_side_position,
            self.PathPlanner_map_pp_status,
            self.PathPlanner_flags,
            self.Lane_changing_reason,
            self.Passing_prohibition_information,
            self.Number_of_MaleLabel_suggestion_routes,
            self.Remaining_distance_of_lane_changing_possibility,
            self.Driver_Guidance,
            self.Hands_on_demand_reason_from_Lateral,
            self.LC_internal_control_state,
            self.Wide_control_internal_control_state,
            self.Long_control_internal_control_state,
            self.FEB_Warning_cyclist,
            self.FEB_Warning_Pedestrian,
            self.FEB_Malfunction_OFF_indicator,
            self.FEB_Temporary_Failure,
            self.FEB_Warning_Vehicle,
            self.RrAEB_Malfunction,
            self.RrAEB_OFF_indicator,
            self.RrAEB_warning,
            self.TSR_Temporary_Failure,
            self.LDP_Temporary_Failure,
            self.LDP_Temporary_Failure_Camera_,
            self.LDW_Temporary_Failure,
            self.LDP_Malfunction,
            self.LDW_Malfunction,
            self.BSI_Tempprary_Failure_SideRadar_,
            self.BSI_Tempprary_Failure,
            self.BSI_Tempprary_Failure_Camera_,
            self.BSI_Malfunction,
            self.ACC_Malfunction,
            self.ACC_Temporary_Failure,
            self.LCA_Malfunction,
            self.LCA_Message_HW_,
            self.LCA_Temporary_Failure,
            self.DAA_Warning,
            self.EAP_Warning,
            self.Current_Form_Of_Way,
            self.TSR_Status_,
            self.Own_car_position_reliability_flag_information,
            self.P2P_giveup_information,
            self.Priority_of_number_of_MaleLabel_suggestion_routes,
            self.Wide_control_permission_judgment_in_the_map_information,
            self.Warning_indication_for_AD2,
            self.Notice_of_driver_for_AD2,
            self.Notice_of_cancellation_for_AD2,
            self.TD_MRM_indication_for_AD2,
            self.Announcement_sound_for_AD2_Group1_,
            self.Announcement_sound_for_AD2_Group2_,
            self.Announcement_sound_for_AD2_Group3_,
            self.Announcement_sound_for_AD2_Group4_,
            self.Announcement_sound_for_AD2_Group5_,
            self.Hands_off_permission_condition,
            self.Target_Relative_speed_FCA_,
            self.LeftEyeCenterPosition_X,
            self.RightEyeCenterPosition_X,
            self.LeftEyeCenterPosition_Y,
            self.RightEyeCenterPosition_Y,
            self.LeftEyeCenterPosition_Z,
            self.Target_recognition_state_of_EAP2,
            self.Full_auto_parking_operational_status,
            self.Remote_parking_operational_status,
            self.MakeLabel_suggestion_route_modification_situation,
            self.RightEyeCenterPosition_Z,
            self.EyesDirection_Yaw,
            self.EyesDirection_Pitch,
            self.Precedent_car_recognition_state_of_FEB_EAP,
            self.Expressway_judgment_NAVI_,
            self.CRC,
            self.mileage,
            self.EDR_Trigger
            ]
        
        sheet.write_row(row, col, valueList)
        
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    
    class LayerType(Enum):
        VehicleDirection = 91
        RDR_info = 92
        Hands_off_prohibit = 93
        ND2_code = 94
        Cancel_code = 95
        GPS = 96
        RDR_pos = 97
        HDMAP_freshness = 98
        WithWithoutHDMAP = 99
        LaneProjectionState = 100
        Wide_control_state = 101
        Long_control_state = 102
        AF_Camera_unstable = 103
        AF_MAP_freshness = 104
        AF_Dependancy_of_road = 105
        AF_Dependancy_of_software = 106
        AF_Type_of_construction = 107
        AD_status = 199
        MPU_Error = 109
    
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.VehicleDirection:
            #!!!！なぜか以下のコードで矢印を描くと、一部のPCではQgisがCrashする。!!!！
            #sl = QgsSymbolLayerRegistry().symbolLayerMetadata('ArrowLine').createSymbolLayer({ 'width' : '0.1', 'color' : '255,0,0' })     
            #symbollist = newLayer_v.renderer().symbols(QgsRenderContext())
            #symbol = symbollist[0]
            #symbol.appendSymbolLayer(sl)
            #以下のコードなら大丈夫だった
            symLyr = QgsArrowSymbolLayer()
            symLyr.setIsCurved(False)
            symLyr.setIsRepeated(False)
            symLyr.setColor(QtGui.QColor.fromRgb(0,0,255))
            layer.renderer().symbols(QgsRenderContext())[0].changeSymbolLayer(0, symLyr)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
            
        elif layerType == cls.LayerType.RDR_info:
            layer = myQgsRendererCategoryLayer(layer, SendADstatus.RDRinfo_symbolDic, width = 1.2)
            label_settings = QgsPalLayerSettings()
            label_settings.drawLabels = True
            label_settings.fieldName = 'Event'
            label_settings.placement = QgsPalLayerSettings.Horizontal
            #label_settings.placement = QgsPalLayerSettings.Line
            label_settings.overrunDistance = 1000
            format = label_settings.format()
            format.setColor(QtGui.QColor.fromRgb(0,0,0))
            format.setFont(QtGui.QFont("Consolas", 15, weight = QtGui.QFont.Bold))
            label_settings.setFormat(format)
            layer.setLabeling(QgsVectorLayerSimpleLabeling(label_settings))
            layer.setLabelsEnabled(True)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.RDR_pos:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(255,0,255))
            symbol.setWidth(0.2)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
            
        elif layerType == cls.LayerType.AD_status:
            layer = myQgsRendererCategoryLayer(layer, SendADstatus.AD_status_symbolDic, width = 4)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.MPU_Error:
            layer = myQgsRendererCategoryLayer(layer, SendADstatus.MPUerror_symbolDic, width = 1.2)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.Hands_off_prohibit:
            layer = myQgsRendererCategoryLayer(layer, SendADstatus.Hands_off_prohibit_symbolDic, width = 1.2)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.ND2_code:
            layer = myQgsRendererCategoryLayer(layer, SendADstatus.ND2_code_symbolDic, width = 1.2)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.Cancel_code:
            layer = myQgsRendererCategoryLayer(layer, SendADstatus.Cancel_code_symbolDic, width = 1.2)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.HDMAP_freshness:
            layer = myQgsRendererCategoryLayer(layer, SendADstatus.HDMAP_freshness_symbolDic, width = 0.4)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.Wide_control_state:
            layer = myQgsRendererCategoryLayer(layer, SendADstatus.Wide_control_state_symbolDic, width = 0.4)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.Long_control_state:
            layer = myQgsRendererCategoryLayer(layer, SendADstatus.Long_control_state_symbolDic, width = 0.4)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.AF_Camera_unstable:
            layer = myQgsRendererCategoryLayer(layer, SendADstatus.AF_Camera_unstable_symbolDic, width = 0.4)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.AF_MAP_freshness:
            layer = myQgsRendererCategoryLayer(layer, SendADstatus.AF_MAP_freshness_symbolDic, width = 0.4)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.AF_Dependancy_of_road:
            layer = myQgsRendererCategoryLayer(layer, SendADstatus.AF_Dependancy_of_road_symbolDic, width = 0.4)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.AF_Dependancy_of_software:
            layer = myQgsRendererCategoryLayer(layer, SendADstatus.AF_Dependancy_of_software_symbolDic, width = 0.4)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.AF_Type_of_construction:
            layer = myQgsRendererCategoryLayer(layer, SendADstatus.AF_Type_of_construction_symbolDic, width = 0.4)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.GPS:
            layer = myQgsRendererCategoryLayer(layer, SendADstatus.GPS_symbolDic, width = 0.6)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.WithWithoutHDMAP:
            layer = myQgsRendererCategoryLayer(layer, SendADstatus.WithWithoutHDMAP_symbolDic, width = 0.4)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.LaneProjectionState:
            layer = myQgsRendererCategoryLayer(layer, SendADstatus.LaneProjectionState_symbolDic, width = 0.4)
            return [layer, layerType.value]
        
        else:
            return None
    
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw, detailMode = False, createArrow = False):
        fieldStr = (
            '&field=Privacy_mode_IVI_:double' 
            + '&field=Privacy_mode_HDMap_:double'
            + '&field=Inter_vehicular_distance_front_:double'
            + '&field=Inter_vehicular_distance_right_front_:double'
            + '&field=Inter_vehicular_distance_left_front_:double'
            + '&field=Inter_vehicular_distance_right_rear_:double'
            + '&field=Inter_vehicular_distance_left_rear_:double'
            + '&field=Yaw_angle:double'
            + '&field=Localization_confidence:double'
            + '&field=Drive_force_control_command:double'
            + '&field=Brake_fluid_pressure_control_command_AEB_:double'
            + '&field=Steering_angle_control_command:double'
            + '&field=Fault_Status_of_Mapecu:double'
            + '&field=Detection_of_hands_on_by_Steering_torque:double'
            + '&field=Steering_override:double'
            + '&field=P2P_state:double'
            + '&field=Auto_overtaking_function:double'
            + '&field=Auto_Lanechanging_function:double'
            + '&field=Presence_absence_of_camera_correction_information:double'
            + '&field=Consistency_between_camera_vision_and_hdmap:double'
            + '&field=Localization:double'
            + '&field=Path_planner:double'
            + '&field=Route_planner:double'
            + '&field=Map_for_HMI:double'
            + '&field=Map_for_OD:double'
            + '&field=Navi_settings_Rear_Automatic_Braking:double'
            + '&field=Navi_settings_Driver_monitor:double'
            + '&field=Navi_settings_Lane_departure_warning:double'
            + '&field=Navi_settings_Lane_departure_prevention:double'
            + '&field=Navi_settings_Blind_spot_warning:double'
            + '&field=Navi_settings_Blind_spot_intervention:double'
            + '&field=Navi_settings_Traffic_signs_recognition:double'
            + '&field=Navi_settings_Steering_assist:double'
            + '&field=Navi_settings_Forward_emergency_braking:double'
            + '&field=Navi_settings_TSR_vehicle_speed_adjustment:double'
            + '&field=Navi_settings_Sequence_exit:double'
            + '&field=Which_lane_number_running:double'
            + '&field=Number_of_lane:double'
            + '&field=Status_of_data_receiving_from_IVI:double'
            + '&field=Linkage_status_between_SDmap_and_HDmap:double'
            + '&field=CP_longi:double'
            + '&field=CP_lat:double'
            + '&field=InterVehicularDistanceICC:double'
            + '&field=Cancel_code:double'
            + '&field=ND2_code:double'
            + '&field=Status_transition_of_ADAS:double'
            + '&field=Curvature:double'
            + '&field=Wiper_mode:double'
            + '&field=Check_latest_version:double'
            + '&field=HDMAP_freshness_information:double'
            + '&field=AD2_emergency_stop_flag:double'
            + '&field=Sheet_belt:double'
            + '&field=Lane_projection_state:double'
            + '&field=With_or_without_HDMAP_flag:double'
            + '&field=License_state:double'
            + '&field=GPS_Latitude:double'
            + '&field=GPS_Longitude:double'
            + '&field=GPS_UTC_Timestamp_Year_:double'
            + '&field=Shift_position:double'
            + '&field=GPS_UTC_Timestamp_Month_:double'
            + '&field=Winker:double'
            + '&field=Deviation_warning:double'
            + '&field=Approch_warning:double'
            + '&field=GPS_UTC_Timestamp_Day_:double'
            + '&field=PKB_control_command:double'
            + '&field=Brake_lamp_command:double'
            + '&field=LDP_BSI_operation_status:double'
            + '&field=GPS_UTC_Timestamp_Hour_:double'
            + '&field=Steering_SW:double'
            + '&field=GPS_UTC_Timestamp_Minute_:double'
            + '&field=Switch_of_door:double'
            + '&field=Turn_signal_switch:double'
            + '&field=Relative_velocity_of_ICC_target:double'
            + '&field=Flag_of_jyro:double'
            + '&field=Flag_of_accelerometer:double'
            + '&field=Flag_of_GNSS:double'
            + '&field=Press_degree_of_accelerator:double'
            + '&field=Steering_torque_sensor:double'
            + '&field=Brake_pedal_stroke:double'
            + '&field=Engine_RPM:double'
            + '&field=AD_Localization_Latitude:double'
            + '&field=AD_Localization_Longitude:double'
            + '&field=Target_vehicle_speed_for_AD2:double'
            + '&field=Real_Vehicle_speed:double'
            + '&field=Lateral_acceleration:double'
            + '&field=Steering_angle:double'
            + '&field=Yaw_rate:double'
            + '&field=Face_direction_Yaw_:double'
            + '&field=Face_direction_Pitch_:double'
            + '&field=Flag_of_car_position_message:double'
            + '&field=Face_direction_Roll_:double'
            + '&field=The_preceding_vehicle_determination_flag_TJP_stopping_item_:double'
            + '&field=Closure_status_of_right_eye:double'
            + '&field=distraction:double'
            + '&field=Closure_status_of_left_eye:double'
            + '&field=Sleepiness:double'
            + '&field=Driver_monitoring:double'
            + '&field=The_preceding_vehicle_determination_flag_TJP_moving_item_:double'
            + '&field=Master_cylinder_fluid_pressure:double'
            + '&field=Motion_status:double'
            + '&field=Camera_motion_status:double'
            + '&field=ON_OFF_of_driver_brakes_working_conditions:double'
            + '&field=OFF_ON_of_stop_lamp_lighting_state:double'
            + '&field=PKB_control_state:double'
            + '&field=Inter_vehicular_distance_Camera_:double'
            + '&field=Camera_lateral_position:double'
            + '&field=Camera_relative_speed:double'
            + '&field=Camera_object_identification:double'
            + '&field=Stop_maintenance_control_state:double'
            + '&field=Radar_object_identification:double'
            + '&field=ON_OFF_of_meter_illuminations_demand:double'
            + '&field=Inter_vehicular_distance_Radar_:double'
            + '&field=Radar_lateral_position:double'
            + '&field=Radar_relative_speed:double'
            + '&field=Setting_inter_vehicular:double'
            + '&field=Brake_fluid_pressure_control_command_ICC_:double'
            + '&field=Navi_settings_with_or_without_Hands_off_permission:double'
            + '&field=The_reason_that_Hands_off_is_prohibited:double'
            + '&field=Time_to_control_point:double'
            + '&field=Status_of_lane_changing_possibility:double'
            + '&field=Fixed_recognition_information_of_lane:double'
            + '&field=Own_car_position_safety_zone_information:double'
            + '&field=Sensor_of_sitting_dowm:double'
            + '&field=Detection_of_hands_on_or_off_by_touch_sensor:double'
            + '&field=Expressway_judgment:double'
            + '&field=ICC_Inter_vehicular_distance_information_of_witch_Sensor:double'
            + '&field=Lane_changing_direction:double'
            + '&field=Right_lane_position:double'
            + '&field=Left_lane_position:double'
            + '&field=GPS_precision_information:double'
            + '&field=ADAS_blinker_control_flag:double'
            + '&field=ADAS_blinker_demand_level:double'
            + '&field=AD_Localization_Altitude:double'
            + '&field=AD_Localization_Yaw_angle:double'
            + '&field=IVI_Speed_Limit:double'
            + '&field=IVI_Curvature:double'
            + '&field=IVI_Dist_Exit:double'
            + '&field=IVI_Dist_TG:double'
            + '&field=Road_classification_of_navi:double'
            + '&field=With_or_without_nearest_LaneLinkID_revision:double'
            + '&field=ALC_approval_state:double'
            + '&field=Control_source_choice_result:double'
            + '&field=Lane_recommendation_degree_MapECU_calculation_result_:double'
            + '&field=Lane_recommendation_degree_MakeLabel_calculation_result_:double'
            + '&field=eCall:double'
            + '&field=TSR_Last_choice_level_:double'
            + '&field=TSR_HDMAP_level_:double'
            + '&field=TSR_Camera_:double'
            + '&field=HDMAP_run_route_addition_information:double'
            + '&field=HDMAP_output_situation:double'
            + '&field=Path_information_diagnosis_result_of_the_ICI_Mayor_of_course:double'
            + '&field=On_Off_of_NAVI_ICC:double'
            + '&field=NAVI_ICC_target_speed:double'
            + '&field=ICC_target_speed:double'
            + '&field=InterVehicularDistanceICC_Target:double'
            + '&field=Steering_angle_servo_gain:double'
            + '&field=LC_cancellation_reason:double'
            + '&field=Aim_Control_Point_side_position:double'
            + '&field=PathPlanner_map_pp_status:double'
            + '&field=PathPlanner_flags:double'
            + '&field=Lane_changing_reason:double'
            + '&field=Passing_prohibition_information:double'
            + '&field=Number_of_MaleLabel_suggestion_routes:double'
            + '&field=Remaining_distance_of_lane_changing_possibility:double'
            + '&field=Driver_Guidance:double'
            + '&field=Hands_on_demand_reason_from_Lateral:double'
            + '&field=LC_internal_control_state:double'
            + '&field=Wide_control_internal_control_state:double'
            + '&field=Long_control_internal_control_state:double'
            + '&field=FEB_Warning_cyclist:double'
            + '&field=FEB_Warning_Pedestrian:double'
            + '&field=FEB_Malfunction_OFF_indicator:double'
            + '&field=FEB_Temporary_Failure:double'
            + '&field=FEB_Warning_Vehicle:double'
            + '&field=RrAEB_Malfunction:double'
            + '&field=RrAEB_OFF_indicator:double'
            + '&field=RrAEB_warning:double'
            + '&field=TSR_Temporary_Failure:double'
            + '&field=LDP_Temporary_Failure:double'
            + '&field=LDP_Temporary_Failure_Camera_:double'
            + '&field=LDW_Temporary_Failure:double'
            + '&field=LDP_Malfunction:double'
            + '&field=LDW_Malfunction:double'
            + '&field=BSI_Tempprary_Failure_SideRadar_:double'
            + '&field=BSI_Tempprary_Failure:double'
            + '&field=BSI_Tempprary_Failure_Camera_:double'
            + '&field=BSI_Malfunction:double'
            + '&field=ACC_Malfunction:double'
            + '&field=ACC_Temporary_Failure:double'
            + '&field=LCA_Malfunction:double'
            + '&field=LCA_Message_HW_:double'
            + '&field=LCA_Temporary_Failure:double'
            + '&field=DAA_Warning:double'
            + '&field=EAP_Warning:double'
            + '&field=Current_Form_Of_Way:double'
            + '&field=TSR_Status_:double'
            + '&field=Own_car_position_reliability_flag_information:double'
            + '&field=P2P_giveup_information:double'
            + '&field=Priority_of_number_of_MaleLabel_suggestion_routes:double'
            + '&field=Wide_control_permission_judgment_in_the_map_information:double'
            + '&field=Warning_indication_for_AD2:double'
            + '&field=Notice_of_driver_for_AD2:double'
            + '&field=Notice_of_cancellation_for_AD2:double'
            + '&field=TD_MRM_indication_for_AD2:double'
            + '&field=Announcement_sound_for_AD2_Group1_:double'
            + '&field=Announcement_sound_for_AD2_Group2_:double'
            + '&field=Announcement_sound_for_AD2_Group3_:double'
            + '&field=Announcement_sound_for_AD2_Group4_:double'
            + '&field=Announcement_sound_for_AD2_Group5_:double'
            + '&field=Hands_off_permission_condition:double'
            + '&field=Target_Relative_speed_FCA_:double'
            + '&field=LeftEyeCenterPosition_X:double'
            + '&field=RightEyeCenterPosition_X:double'
            + '&field=LeftEyeCenterPosition_Y:double'
            + '&field=RightEyeCenterPosition_Y:double'
            + '&field=LeftEyeCenterPosition_Z:double'
            + '&field=Target_recognition_state_of_EAP2:double'
            + '&field=Full_auto_parking_operational_status:double'
            + '&field=Remote_parking_operational_status:double'
            + '&field=MakeLabel_suggestion_route_modification_situation:double'
            + '&field=RightEyeCenterPosition_Z:double'
            + '&field=EyesDirection_Yaw:double'
            + '&field=EyesDirection_Pitch:double'
            + '&field=Precedent_car_recognition_state_of_FEB_EAP:double'
            + '&field=Expressway_judgment_NAVI_:double'
            + '&field=CRC:double'
            + '&field=mileage:double'
            + '&field=EDR_Trigger:double'
            )
        
        if (realTimeMode == DrawMode.QGIS_RealTimeDraw):
            newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&field=Event:string&field=Longitude:double&field=Latitude:double&index=yes',name + '(R-DR Info)','memory')
            newLayer = self.SetLayerStyle(self.LayerType.RDR_info, newLayer)
            return [newLayer]
        
        elif (realTimeMode == DrawMode.OpenGL_RealTimeDraw):
            newLayer_pos = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime' + fieldStr + '&index=yes',name,'memory')
            newLayer_pos = self.SetLayerStyle(self.LayerType.RDR_pos, newLayer_pos)
            return [newLayer_pos]
        
        elif (realTimeMode == DrawMode.FullDraw):
            if createArrow == True:
                newLayer_v = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&field=RealSpeed[km/h]:double&index=yes',name+'(V)','memory')
                newLayer_v = self.SetLayerStyle(self.LayerType.VehicleDirection, newLayer_v)
                SendADstatus.oldVpoint = None
            
            newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&field=Event:string&field=Longitude:double&field=Latitude:double&index=yes',name + '(R-DR Info)','memory')
            newLayer = self.SetLayerStyle(self.LayerType.RDR_info, newLayer)
            
            newLayer_adStatus = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&index=yes',name + '(AD status)','memory')
            newLayer_adStatus = self.SetLayerStyle(self.LayerType.AD_status, newLayer_adStatus)
            
            newLayer_Hands_off_prohibit = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&field=detail:string&index=yes',name + '(Hands off prohibit)','memory')
            newLayer_Hands_off_prohibit = self.SetLayerStyle(self.LayerType.Hands_off_prohibit, newLayer_Hands_off_prohibit)
            
            newLayer_ND2_code = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&field=detail:string&index=yes',name + '(ND2_code)','memory')
            newLayer_ND2_code = self.SetLayerStyle(self.LayerType.ND2_code, newLayer_ND2_code)
            
            newLayer_Cancel_code = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&field=detail:string&index=yes',name + '(Cancel_code)','memory')
            newLayer_Cancel_code = self.SetLayerStyle(self.LayerType.Cancel_code, newLayer_Cancel_code)
            
            newLayer_WithWithoutHDMAP = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&index=yes',name + '(WithWithoutHDMAP)','memory')
            newLayer_WithWithoutHDMAP = self.SetLayerStyle(self.LayerType.WithWithoutHDMAP, newLayer_WithWithoutHDMAP)
            
            newLayer_Wide_control_internal_control_state = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&index=yes',name + '(Wide_control_state)','memory')
            newLayer_Wide_control_internal_control_state = self.SetLayerStyle(self.LayerType.Wide_control_state, newLayer_Wide_control_internal_control_state)
            
            newLayer_Long_control_internal_control_state = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&index=yes',name + '(Long_control_state)','memory')
            newLayer_Long_control_internal_control_state = self.SetLayerStyle(self.LayerType.Long_control_state, newLayer_Long_control_internal_control_state)
             
            if detailMode == True:
                newLayer_HDMAP_freshness_information = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&index=yes',name + '(HDMAP_freshness)','memory')
                newLayer_HDMAP_freshness_information = self.SetLayerStyle(self.LayerType.HDMAP_freshness, newLayer_HDMAP_freshness_information)
                
                newLayer_LaneProjectionState = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&index=yes',name + '(LaneProjectionState)','memory')
                newLayer_LaneProjectionState = self.SetLayerStyle(self.LayerType.LaneProjectionState, newLayer_LaneProjectionState)
                
                newLayer_AF_Camera_unstable = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&index=yes',name + '(AF_Camera_unstable)','memory')
                newLayer_AF_Camera_unstable = self.SetLayerStyle(self.LayerType.AF_Camera_unstable, newLayer_AF_Camera_unstable)
                
                newLayer_AF_MAP_freshness = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&index=yes',name + '(AF_MAP_freshness)','memory')
                newLayer_AF_MAP_freshness = self.SetLayerStyle(self.LayerType.AF_MAP_freshness, newLayer_AF_MAP_freshness)
                
                newLayer_AF_Dependancy_of_road = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&index=yes',name + '(AF_Dependancy_of_road)','memory')
                newLayer_AF_Dependancy_of_road = self.SetLayerStyle(self.LayerType.AF_Dependancy_of_road, newLayer_AF_Dependancy_of_road)
                
                newLayer_AF_Dependancy_of_software = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&index=yes',name + '(AF_Dependancy_of_software)','memory')
                newLayer_AF_Dependancy_of_software = self.SetLayerStyle(self.LayerType.AF_Dependancy_of_software, newLayer_AF_Dependancy_of_software)
                
                newLayer_AF_Type_of_construction = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&index=yes',name + '(AF_Type_of_construction)','memory')
                newLayer_AF_Type_of_construction = self.SetLayerStyle(self.LayerType.AF_Type_of_construction, newLayer_AF_Type_of_construction)
                
                newLayer_GPS = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&field=precision[m]:double&field=Longitude:double&field=Latitude:double&index=yes',name + '(GPS)','memory')
                newLayer_GPS = self.SetLayerStyle(self.LayerType.GPS, newLayer_GPS)
                
                newLayer_MPU_Error = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&field=detail:string&index=yes',name + '(MPU_Error)','memory')
                newLayer_MPU_Error = self.SetLayerStyle(self.LayerType.MPU_Error, newLayer_MPU_Error)
            
            
            newLayer_pos = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime' + fieldStr + '&index=yes',name,'memory')
            newLayer_pos = self.SetLayerStyle(self.LayerType.RDR_pos, newLayer_pos)
            
            returnList = [newLayer, newLayer_adStatus, newLayer_Hands_off_prohibit, newLayer_ND2_code, newLayer_Cancel_code, newLayer_pos,
                          newLayer_WithWithoutHDMAP, newLayer_Wide_control_internal_control_state, newLayer_Long_control_internal_control_state]
            if createArrow == True:
                returnList += [newLayer_v]
            if detailMode == True:
                returnList += [newLayer_HDMAP_freshness_information, newLayer_LaneProjectionState,
                               newLayer_GPS, newLayer_MPU_Error,
                               newLayer_AF_Camera_unstable, newLayer_AF_MAP_freshness, newLayer_AF_Dependancy_of_road, newLayer_AF_Dependancy_of_software, newLayer_AF_Type_of_construction]
            return returnList 

    def drawRDRinfo(self, targetLayer, old, classIndex, *args):
        info = ''
        for valueName, dic in args:
            newValue = eval('self.' + valueName)
            if old == None: oldValue = newValue
            else: oldValue = eval('old.' + valueName)
            
            if oldValue == newValue and SendADstatus.firstDrawRDRinfo[classIndex-1] == False:
                continue

            if type(dic) == type({}):
                if not (newValue in dic):
                    continue
                event = dic[newValue]
            elif type(dic) == type([]):
                newGroup = bisect.bisect(dic[0], newValue)
                oldGroup = bisect.bisect(dic[0], oldValue)
                if oldGroup == newGroup and SendADstatus.firstDrawRDRinfo[classIndex-1] == False:
                    continue
                event = dic[1][newGroup]
            
            if event != '':    
                if info == '': info += event
                else: info += '\n' + event
        
        if info != '':
            SendADstatus.firstDrawRDRinfo[classIndex-1] = False
            if self.infoPosition == None:
                return
            lat1 = self.infoPosition[0]
            lon1 = self.infoPosition[1]
            lat2 = self.infoPosition[2]
            lon2 = self.infoPosition[3]
                 
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline(
                [QgsPoint(lon1, lat1), QgsPoint(lon2, lat2)] ))
            if len(info) > 255: info = info[:255]
            feature.setAttributes([QDateTime(self.commonHeader.logTime), classIndex, info, lon1, lat1])
            targetLayer.dataProvider().addFeatures( [feature] )
    
    def getLonLat(self):
        lat = self.AD_Localization_Latitude
        lon = self.AD_Localization_Longitude
        if checkInvalidLonLat(lon, lat) == False:
            if self.relatedADPositionMessage != None:
                [lon, lat] = self.relatedADPositionMessage.getLonLat()
            else:
                lat = self.GPS_Latitude
                lon = self.GPS_Longitude
        return [lon, lat]
    
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        old = self.oldMessage
        layer = None    
        layer_v = None
        layer_adStatus = None
        layer_Hands_off_prohibit = None
        layer_ND2_code = None
        layer_Cancel_code = None
        layer_pos = None
        layer_HDMAP_freshness_information = None
        layer_WithWithoutHDMAP = None
        layer_LaneProjectionState = None
        layer_Wide_control_internal_control_state = None
        layer_Long_control_internal_control_state = None
        layer_AF_Camera_unstable = None
        layer_AF_MAP_freshness = None
        layer_AF_Dependancy_of_road = None
        layer_AF_Dependancy_of_software = None
        layer_AF_Type_of_construction = None
        layer_GPS = None
        layer_MPU_Error = None
        for layerListItem in layerList:
            if layerListItem[1] == SendADstatus.LayerType.VehicleDirection.value:
                layer_v = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.RDR_info.value:
                layer = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.AD_status.value:
                layer_adStatus = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.Hands_off_prohibit.value:
                layer_Hands_off_prohibit = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.ND2_code.value:
                layer_ND2_code = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.Cancel_code.value:
                layer_Cancel_code = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.RDR_pos.value:
                layer_pos = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.HDMAP_freshness.value:
                layer_HDMAP_freshness_information = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.WithWithoutHDMAP.value:
                layer_WithWithoutHDMAP = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.LaneProjectionState.value:
                layer_LaneProjectionState = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.Wide_control_state.value:
                layer_Wide_control_internal_control_state = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.Long_control_state.value:
                layer_Long_control_internal_control_state = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.AF_Camera_unstable.value:
                layer_AF_Camera_unstable = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.AF_MAP_freshness.value:
                layer_AF_MAP_freshness = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.AF_Dependancy_of_road.value:
                layer_AF_Dependancy_of_road = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.AF_Dependancy_of_software.value:
                layer_AF_Dependancy_of_software = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.AF_Type_of_construction.value:
                layer_AF_Type_of_construction = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.GPS.value:
                layer_GPS = layerListItem[0]
            elif layerListItem[1] == SendADstatus.LayerType.MPU_Error.value:
                layer_MPU_Error = layerListItem[0]
        
        if old == None:
            [oldLon, oldLat] = [180, 180]
        else:
            [oldLon, oldLat] = old.getLonLat()
        [lon, lat] = self.getLonLat()
        checkInvalidLonLatResult = checkInvalidLonLat(lon, lat, oldLon, oldLat, allowSamePoint = True)
        
        # layer_pos は、Lon/Latが決まらなくても、Feature追加する。
        # (緯度経度が収束される前からもR-EDR情報を表示するため。ただし、地図描画上に無効な位置からの長い無駄な線が描画されないするために、0,0の位置として登録する。)
        if layer_pos != None:
            feature = QgsFeature()
            if checkInvalidLonLatResult == False:
                feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(0, 0), QgsPoint(0, 0)])) # OpenGL描画などのために、位置情報がなくてもとりあえず現在の情報は流れるように
            else:
                feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)]))
            feature.setAttributes([QDateTime(self.commonHeader.logTime),
                                    self.Privacy_mode_IVI_,
                                    self.Privacy_mode_HDMap_,
                                    self.Inter_vehicular_distance_front_,
                                    self.Inter_vehicular_distance_right_front_,
                                    self.Inter_vehicular_distance_left_front_,
                                    self.Inter_vehicular_distance_right_rear_,
                                    self.Inter_vehicular_distance_left_rear_,
                                    self.Yaw_angle,
                                    self.Localization_confidence,
                                    self.Drive_force_control_command,
                                    self.Brake_fluid_pressure_control_command_AEB_,
                                    self.Steering_angle_control_command,
                                    self.Fault_Status_of_Mapecu,
                                    self.Detection_of_hands_on_by_Steering_torque,
                                    self.Steering_override,
                                    self.P2P_state,
                                    self.Auto_overtaking_function,
                                    self.Auto_Lanechanging_function,
                                    self.Presence_absence_of_camera_correction_information,
                                    self.Consistency_between_camera_vision_and_hdmap,
                                    self.Localization,
                                    self.Path_planner,
                                    self.Route_planner,
                                    self.Map_for_HMI,
                                    self.Map_for_OD,
                                    self.Navi_settings_Rear_Automatic_Braking,
                                    self.Navi_settings_Driver_monitor,
                                    self.Navi_settings_Lane_departure_warning,
                                    self.Navi_settings_Lane_departure_prevention,
                                    self.Navi_settings_Blind_spot_warning,
                                    self.Navi_settings_Blind_spot_intervention,
                                    self.Navi_settings_Traffic_signs_recognition,
                                    self.Navi_settings_Steering_assist,
                                    self.Navi_settings_Forward_emergency_braking,
                                    self.Navi_settings_TSR_vehicle_speed_adjustment,
                                    self.Navi_settings_Sequence_exit,
                                    self.Which_lane_number_running,
                                    self.Number_of_lane,
                                    self.Status_of_data_receiving_from_IVI,
                                    self.Linkage_status_between_SDmap_and_HDmap,
                                    self.CP_longi,
                                    self.CP_lat,
                                    self.InterVehicularDistanceICC,
                                    self.Cancel_code,
                                    self.ND2_code,
                                    self.Status_transition_of_ADAS,
                                    self.Curvature,
                                    self.Wiper_mode,
                                    self.Check_latest_version,
                                    self.HDMAP_freshness_information,
                                    self.AD2_emergency_stop_flag,
                                    self.Sheet_belt,
                                    self.Lane_projection_state,
                                    self.With_or_without_HDMAP_flag,
                                    self.License_state,
                                    self.GPS_Latitude,
                                    self.GPS_Longitude,
                                    self.GPS_UTC_Timestamp_Year_,
                                    self.Shift_position,
                                    self.GPS_UTC_Timestamp_Month_,
                                    self.Winker,
                                    self.Deviation_warning,
                                    self.Approch_warning,
                                    self.GPS_UTC_Timestamp_Day_,
                                    self.PKB_control_command,
                                    self.Brake_lamp_command,
                                    self.LDP_BSI_operation_status,
                                    self.GPS_UTC_Timestamp_Hour_,
                                    self.Steering_SW,
                                    self.GPS_UTC_Timestamp_Minute_,
                                    self.Switch_of_door,
                                    self.Turn_signal_switch,
                                    self.Relative_velocity_of_ICC_target,
                                    self.Flag_of_jyro,
                                    self.Flag_of_accelerometer,
                                    self.Flag_of_GNSS,
                                    self.Press_degree_of_accelerator,
                                    self.Steering_torque_sensor,
                                    self.Brake_pedal_stroke,
                                    self.Engine_RPM,
                                    self.AD_Localization_Latitude,
                                    self.AD_Localization_Longitude,
                                    self.Target_vehicle_speed_for_AD2,
                                    self.Real_Vehicle_speed,
                                    self.Lateral_acceleration,
                                    self.Steering_angle,
                                    self.Yaw_rate,
                                    self.Face_direction_Yaw_,
                                    self.Face_direction_Pitch_,
                                    self.Flag_of_car_position_message,
                                    self.Face_direction_Roll_,
                                    self.The_preceding_vehicle_determination_flag_TJP_stopping_item_,
                                    self.Closure_status_of_right_eye,
                                    self.distraction,
                                    self.Closure_status_of_left_eye,
                                    self.Sleepiness,
                                    self.Driver_monitoring,
                                    self.The_preceding_vehicle_determination_flag_TJP_moving_item_,
                                    self.Master_cylinder_fluid_pressure,
                                    self.Motion_status,
                                    self.Camera_motion_status,
                                    self.ON_OFF_of_driver_brakes_working_conditions,
                                    self.OFF_ON_of_stop_lamp_lighting_state,
                                    self.PKB_control_state,
                                    self.Inter_vehicular_distance_Camera_,
                                    self.Camera_lateral_position,
                                    self.Camera_relative_speed,
                                    self.Camera_object_identification,
                                    self.Stop_maintenance_control_state,
                                    self.Radar_object_identification,
                                    self.ON_OFF_of_meter_illuminations_demand,
                                    self.Inter_vehicular_distance_Radar_,
                                    self.Radar_lateral_position,
                                    self.Radar_relative_speed,
                                    self.Setting_inter_vehicular,
                                    self.Brake_fluid_pressure_control_command_ICC_,
                                    self.Navi_settings_with_or_without_Hands_off_permission,
                                    self.The_reason_that_Hands_off_is_prohibited,
                                    self.Time_to_control_point,
                                    self.Status_of_lane_changing_possibility,
                                    self.Fixed_recognition_information_of_lane,
                                    self.Own_car_position_safety_zone_information,
                                    self.Sensor_of_sitting_dowm,
                                    self.Detection_of_hands_on_or_off_by_touch_sensor,
                                    self.Expressway_judgment,
                                    self.ICC_Inter_vehicular_distance_information_of_witch_Sensor,
                                    self.Lane_changing_direction,
                                    self.Right_lane_position,
                                    self.Left_lane_position,
                                    self.GPS_precision_information,
                                    self.ADAS_blinker_control_flag,
                                    self.ADAS_blinker_demand_level,
                                    self.AD_Localization_Altitude,
                                    self.AD_Localization_Yaw_angle,
                                    self.IVI_Speed_Limit,
                                    self.IVI_Curvature,
                                    self.IVI_Dist_Exit,
                                    self.IVI_Dist_TG,
                                    self.Road_classification_of_navi,
                                    self.With_or_without_nearest_LaneLinkID_revision,
                                    self.ALC_approval_state,
                                    self.Control_source_choice_result,
                                    self.Lane_recommendation_degree_MapECU_calculation_result_,
                                    self.Lane_recommendation_degree_MakeLabel_calculation_result_,
                                    self.eCall,
                                    self.TSR_Last_choice_level_,
                                    self.TSR_HDMAP_level_,
                                    self.TSR_Camera_,
                                    self.HDMAP_run_route_addition_information,
                                    self.HDMAP_output_situation,
                                    self.Path_information_diagnosis_result_of_the_ICI_Mayor_of_course,
                                    self.On_Off_of_NAVI_ICC,
                                    self.NAVI_ICC_target_speed,
                                    self.ICC_target_speed,
                                    self.InterVehicularDistanceICC_Target,
                                    self.Steering_angle_servo_gain,
                                    self.LC_cancellation_reason,
                                    self.Aim_Control_Point_side_position,
                                    self.PathPlanner_map_pp_status,
                                    self.PathPlanner_flags,
                                    self.Lane_changing_reason,
                                    self.Passing_prohibition_information,
                                    self.Number_of_MaleLabel_suggestion_routes,
                                    self.Remaining_distance_of_lane_changing_possibility,
                                    self.Driver_Guidance,
                                    self.Hands_on_demand_reason_from_Lateral,
                                    self.LC_internal_control_state,
                                    self.Wide_control_internal_control_state,
                                    self.Long_control_internal_control_state,
                                    self.FEB_Warning_cyclist,
                                    self.FEB_Warning_Pedestrian,
                                    self.FEB_Malfunction_OFF_indicator,
                                    self.FEB_Temporary_Failure,
                                    self.FEB_Warning_Vehicle,
                                    self.RrAEB_Malfunction,
                                    self.RrAEB_OFF_indicator,
                                    self.RrAEB_warning,
                                    self.TSR_Temporary_Failure,
                                    self.LDP_Temporary_Failure,
                                    self.LDP_Temporary_Failure_Camera_,
                                    self.LDW_Temporary_Failure,
                                    self.LDP_Malfunction,
                                    self.LDW_Malfunction,
                                    self.BSI_Tempprary_Failure_SideRadar_,
                                    self.BSI_Tempprary_Failure,
                                    self.BSI_Tempprary_Failure_Camera_,
                                    self.BSI_Malfunction,
                                    self.ACC_Malfunction,
                                    self.ACC_Temporary_Failure,
                                    self.LCA_Malfunction,
                                    self.LCA_Message_HW_,
                                    self.LCA_Temporary_Failure,
                                    self.DAA_Warning,
                                    self.EAP_Warning,
                                    self.Current_Form_Of_Way,
                                    self.TSR_Status_,
                                    self.Own_car_position_reliability_flag_information,
                                    self.P2P_giveup_information,
                                    self.Priority_of_number_of_MaleLabel_suggestion_routes,
                                    self.Wide_control_permission_judgment_in_the_map_information,
                                    self.Warning_indication_for_AD2,
                                    self.Notice_of_driver_for_AD2,
                                    self.Notice_of_cancellation_for_AD2,
                                    self.TD_MRM_indication_for_AD2,
                                    self.Announcement_sound_for_AD2_Group1_,
                                    self.Announcement_sound_for_AD2_Group2_,
                                    self.Announcement_sound_for_AD2_Group3_,
                                    self.Announcement_sound_for_AD2_Group4_,
                                    self.Announcement_sound_for_AD2_Group5_,
                                    self.Hands_off_permission_condition,
                                    self.Target_Relative_speed_FCA_,
                                    self.LeftEyeCenterPosition_X,
                                    self.RightEyeCenterPosition_X,
                                    self.LeftEyeCenterPosition_Y,
                                    self.RightEyeCenterPosition_Y,
                                    self.LeftEyeCenterPosition_Z,
                                    self.Target_recognition_state_of_EAP2,
                                    self.Full_auto_parking_operational_status,
                                    self.Remote_parking_operational_status,
                                    self.MakeLabel_suggestion_route_modification_situation,
                                    self.RightEyeCenterPosition_Z,
                                    self.EyesDirection_Yaw,
                                    self.EyesDirection_Pitch,
                                    self.Precedent_car_recognition_state_of_FEB_EAP,
                                    self.Expressway_judgment_NAVI_,
                                    self.CRC,
                                    self.mileage,
                                    self.EDR_Trigger])
            layer_pos.dataProvider().addFeatures( [feature] )    
        
        if old == None:
            return

        if (self.commonHeader.logTime - old.commonHeader.logTime).total_seconds() > 3: #3秒以上間隔があいたR-DRデータの場合は、途切れとみなし、結ばない。
            return
        
        if checkInvalidLonLatResult == False:
            return
        
        lat1 = oldLat
        lon1 = oldLon
        lat2 = lat
        lon2 = lon
        length = sqrt((lon - oldLon)**2 + (lat - oldLat)**2)
        if lat1 == lat2 and lon1 == lon2:
            lon2 = lon1 + 0.00005
            lat2 = lat1 + 0.00005 
        else:
            if length < 0.0001:
                lon2 = lon1 + (lon2 - lon1)*0.0001/length
                lat2 = lat1 + (lat2 - lat1)*0.0001/length
        self.infoPosition = (lat1, lon1, lat2, lon2)
        
        SendADstatus.Summery_TotalRecordLength += length
        SendADstatus.Summery_ADStatusGroup[self.ad_status_group]['length'] += length
        SendADstatus.Summery_ND2Code[self.ND2_code]['length'] += length
        SendADstatus.Summery_CancelCode[self.Cancel_code]['length'] += length
        SendADstatus.Summery_HandOffProhibit[self.The_reason_that_Hands_off_is_prohibited]['length'] += length
        
        if layer != None:
            if (realTimeMode == DrawMode.QGIS_RealTimeDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw):
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo,  6, ('Status_transition_of_ADAS', SendADstatus.Status_transition_of_ADAS_Dic))
                
            else:
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo,  1, ('Winker', SendADstatus.WinkerInfoDic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo,  2, ('P2P_state', SendADstatus.P2PStateDic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo,  3, ('Consistency_between_camera_vision_and_hdmap', SendADstatus.Consistency_between_camera_vision_and_hdmap_Dic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo,  4, ('Status_of_data_receiving_from_IVI', SendADstatus.Status_of_data_receiving_from_IVI_Dic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo,  5, ('Linkage_status_between_SDmap_and_HDmap', SendADstatus.Linkage_status_between_SDmap_and_HDmap_Dic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo,  6, ('Status_transition_of_ADAS', SendADstatus.Status_transition_of_ADAS_Dic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo,  7, ('Wiper_mode & 0x01', SendADstatus.Wiper_mode_low_Dic), 
                                                 ('Wiper_mode & 0x02', SendADstatus.Wiper_mode_high_Dic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo,  8, ('Check_latest_version', SendADstatus.Check_latest_version_Dic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo,  9, ('P2P_giveup_information', SendADstatus.P2PGiveupDic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo, 10, ('AD2_emergency_stop_flag', SendADstatus.AD2_emergency_stop_flag_Dic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo, 11, ('License_state', SendADstatus.License_state_Dic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo, 12, ('Deviation_warning', SendADstatus.Deviation_warning_Dic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo, 13, ('Approch_warning', SendADstatus.Approch_warning_Dic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo, 14, ('LDP_BSI_operation_status', SendADstatus.LDP_BSI_operation_status_Dic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo, 15, ('Steering_SW', SendADstatus.Steering_SW_Dic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo, 16, ('Hands_on_demand_reason_from_Lateral', SendADstatus.Hands_on_demand_reason_from_Lateral_Dic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo, 17, ('Wide_control_permission_judgment_in_the_map_information', SendADstatus.Wide_control_permission_judgment_in_the_map_information_Dic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo, 18, ('Hands_off_permission_condition & 0x0001', SendADstatus.Hands_off_permission_condition_Dic_0),
                                                 ('Hands_off_permission_condition & 0x0002', SendADstatus.Hands_off_permission_condition_Dic_1),
                                                 ('Hands_off_permission_condition & 0x0004', SendADstatus.Hands_off_permission_condition_Dic_2),
                                                 ('Hands_off_permission_condition & 0x0008', SendADstatus.Hands_off_permission_condition_Dic_3),
                                                 ('Hands_off_permission_condition & 0x0010', SendADstatus.Hands_off_permission_condition_Dic_4),
                                                 ('Hands_off_permission_condition & 0x0020', SendADstatus.Hands_off_permission_condition_Dic_5),
                                                 ('Hands_off_permission_condition & 0x0040', SendADstatus.Hands_off_permission_condition_Dic_6),
                                                 ('Hands_off_permission_condition & 0x0080', SendADstatus.Hands_off_permission_condition_Dic_7),
                                                 ('Hands_off_permission_condition & 0x0100', SendADstatus.Hands_off_permission_condition_Dic_8),
                                                 ('Hands_off_permission_condition & 0x0200', SendADstatus.Hands_off_permission_condition_Dic_9),
                                                 ('Hands_off_permission_condition & 0x0400', SendADstatus.Hands_off_permission_condition_Dic_10),
                                                 ('Hands_off_permission_condition & 0x0800', SendADstatus.Hands_off_permission_condition_Dic_11),
                                                 ('Hands_off_permission_condition & 0x1000', SendADstatus.Hands_off_permission_condition_Dic_12),
                                                 ('Hands_off_permission_condition & 0x2000', SendADstatus.Hands_off_permission_condition_Dic_13),
                                                 ('Hands_off_permission_condition & 0x4000', SendADstatus.Hands_off_permission_condition_Dic_14),
                                                 ('Hands_off_permission_condition & 0x8000', SendADstatus.Hands_off_permission_condition_Dic_15))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo, 19, ('EDR_Trigger & 0x01', SendADstatus.EDR_Trigger_Dic),
                                                 ('EDR_Trigger & 0x02', SendADstatus.EDR_Trigger_Dic),
                                                 ('EDR_Trigger & 0x04', SendADstatus.EDR_Trigger_Dic),
                                                 ('EDR_Trigger & 0x08', SendADstatus.EDR_Trigger_Dic),
                                                 ('EDR_Trigger & 0x10', SendADstatus.EDR_Trigger_Dic),
                                                 ('EDR_Trigger & 0x20', SendADstatus.EDR_Trigger_Dic),
                                                 ('EDR_Trigger & 0x40', SendADstatus.EDR_Trigger_Dic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo, 20, ('The_reason_that_Hands_off_is_prohibited', SendADstatus.The_reason_that_Hands_off_is_prohibited_Dic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo, 21, ('HDMAP_output_situation & 0x01', SendADstatus.HDMAP_output_situation_Dic_0),
                                                 ('HDMAP_output_situation & 0x02', SendADstatus.HDMAP_output_situation_Dic_1),
                                                 ('HDMAP_output_situation & 0x04', SendADstatus.HDMAP_output_situation_Dic_2))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo, 22, ('Lane_recommendation_degree_MapECU_calculation_result_', SendADstatus.Lane_recommendation_degree_MapECU_Dic))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo, 23, ('Lane_recommendation_degree_MakeLabel_calculation_result_ & 0x03', SendADstatus.Lane_recommendation_degree_MakeLabel_Dic_0),
                                                 ('Lane_recommendation_degree_MakeLabel_calculation_result_ & 0x0C', SendADstatus.Lane_recommendation_degree_MakeLabel_Dic_2),
                                                 ('Lane_recommendation_degree_MakeLabel_calculation_result_ & 0x30', SendADstatus.Lane_recommendation_degree_MakeLabel_Dic_4))
                self.drawRDRinfo(layer, SendADstatus.lastDrawRDRinfo, 24, ('LC_cancellation_reason', SendADstatus.LC_cancellation_reason_Dic))
           
            SendADstatus.lastDrawRDRinfo = self
                                    
        if layer_v != None:
            scaleRate = 0.000002
            if (SendADstatus.oldVpoint == None) or ((SendADstatus.oldVpoint[0]-lon) ** 2 + (SendADstatus.oldVpoint[1]-lat) ** 2) >= 0.0000005:
                lat1 = oldLat
                lon1 = oldLon
                lat2 = lat
                lon2 = lon
                if lat1 != lat2 or lon1 != lon2:
                    length = sqrt((lon2 - lon1)*(lon2 - lon1) + (lat2 - lat1)*(lat2 - lat1))
                    lon2 = lon1 + (lon2 - lon1)*self.Real_Vehicle_speed*scaleRate/length
                    lat2 = lat1 + (lat2 - lat1)*self.Real_Vehicle_speed*scaleRate/length
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(lon1, lat1), QgsPoint(lon2, lat2)]))
                    feature.setAttributes([QDateTime(self.commonHeader.logTime), lon, lat, self.Real_Vehicle_speed])
                    layer_v.dataProvider().addFeatures( [feature] )
                    SendADstatus.oldVpoint = (lon, lat)
        
        if layer_adStatus != None:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)]))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), self.ad_status_group])
            layer_adStatus.dataProvider().addFeatures( [feature] )
            
        if layer_GPS != None:
            if checkInvalidLonLat(self.GPS_Longitude, self.GPS_Latitude, old.GPS_Longitude, old.GPS_Latitude, allowSamePoint = True) == True:
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(old.GPS_Longitude, old.GPS_Latitude), QgsPoint(self.GPS_Longitude, self.GPS_Latitude)]))
                feature.setAttributes([QDateTime(self.commonHeader.logTime), int(self.GPS_precision_information), self.GPS_precision_information, self.GPS_Longitude, self.GPS_Latitude])
                layer_GPS.dataProvider().addFeatures( [feature] )
            
        if layer_HDMAP_freshness_information != None:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)]))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), self.HDMAP_freshness_information])
            layer_HDMAP_freshness_information.dataProvider().addFeatures( [feature] )
            
        if layer_WithWithoutHDMAP != None:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)]))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), self.With_or_without_HDMAP_flag])
            layer_WithWithoutHDMAP.dataProvider().addFeatures( [feature] )
            
        if layer_LaneProjectionState != None:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)]))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), self.Lane_projection_state])
            layer_LaneProjectionState.dataProvider().addFeatures( [feature] )
            
        if layer_Wide_control_internal_control_state != None:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)]))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), self.Wide_control_internal_control_state])
            layer_Wide_control_internal_control_state.dataProvider().addFeatures( [feature] )
            
        if layer_Long_control_internal_control_state != None:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)]))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), self.Long_control_internal_control_state])
            layer_Long_control_internal_control_state.dataProvider().addFeatures( [feature] )
            
        if layer_AF_Camera_unstable != None:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)]))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), (self.Own_car_position_reliability_flag_information & 0x00001) >> 0])
            layer_AF_Camera_unstable.dataProvider().addFeatures( [feature] )
            
        if layer_AF_MAP_freshness != None:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)]))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), (self.Own_car_position_reliability_flag_information & 0x00006) >> 1])
            layer_AF_MAP_freshness.dataProvider().addFeatures( [feature] )
            
        if layer_AF_Dependancy_of_road != None:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)]))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), (self.Own_car_position_reliability_flag_information & 0x00038) >> 3])
            layer_AF_Dependancy_of_road.dataProvider().addFeatures( [feature] )
            
        if layer_AF_Dependancy_of_software != None:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)]))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), (self.Own_car_position_reliability_flag_information & 0x001C0) >> 6])
            layer_AF_Dependancy_of_software.dataProvider().addFeatures( [feature] )
            
        if layer_AF_Type_of_construction != None:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)]))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), (self.Own_car_position_reliability_flag_information & 0x70000) >> 16])
            layer_AF_Type_of_construction.dataProvider().addFeatures( [feature] )
        
        if layer_MPU_Error != None:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline(
                [QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)] ))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), self.Fault_Status_of_Mapecu,
                                   SendADstatus.MPUerror_symbolDic.get(self.Fault_Status_of_Mapecu, ('-','-'))[1]])
            layer_MPU_Error.dataProvider().addFeatures( [feature] )
            
        if layer_Hands_off_prohibit != None:    
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline(
                [QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)] ))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), self.The_reason_that_Hands_off_is_prohibited,
                                   SendADstatus.Hands_off_prohibit_symbolDic.get(self.The_reason_that_Hands_off_is_prohibited, ('-','-'))[1]])
            layer_Hands_off_prohibit.dataProvider().addFeatures( [feature] )
            
        if layer_ND2_code != None:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline(
                [QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)] ))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), self.ND2_code,
                                   SendADstatus.ND2_code_symbolDic.get(self.ND2_code, ('-','-'))[1]])
            layer_ND2_code.dataProvider().addFeatures( [feature] )
            
        if layer_Cancel_code != None:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline(
                [QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)] ))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), self.Cancel_code,
                                   SendADstatus.Cancel_code_symbolDic.get(self.Cancel_code, ('-','-'))[1]])
            layer_Cancel_code.dataProvider().addFeatures( [feature] )
        
            
#-----------------------------------------------#
#----   ADASISv2METADATA                    ----#
#-----------------------------------------------#
class ADASISv2METADATA(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        readFunc(int,3) #CheckSum
        self.MapProvider = readFunc(int,3)
        self.CountryCode = readFunc(int,10)
        self.CyclicCounter = readFunc(int,2)
        self.MajorProtocolVersion = readFunc(int,2)
        self.MinorProtocolSubVersion = readFunc(int,3)
        self.HardwareVersion = readFunc(int,9)
        self.DrivingSide = readFunc(int,1)
        self.RegionCode = readFunc(int,15)
        self.MapVersionYearQuarter = readFunc(int,2)
        self.MapVersionYear = readFunc(int,6)
        readFunc(int,1) #CheckSum
        readFunc(int,2) #Reserve
        self.SpeedUnits = readFunc(int,1)
        self.MinorProtocolVersion = readFunc(int,4)
        self.assertMessageSize()

    def printHeader(self, sheet, row, col, _level = 1):
        [_, col, _] = self.commonHeader.printHeader(sheet, row, col)
        
        sheet.write_row(row, col, [
            'Map Provider', 
            'Country Code', 
            'Cyclic Counter',
            'Major Protocol Ver',
            'Minor Protocol SubVer',
            'Hardware Ver',
            'Driving Side',
            'Region Code',
            'Map Ver (YearQuarter)',
            'Map Ver (Year)',
            'Speed Units',
            'Minor Protocol Ver'], sheet.cellFormats('header'))
        col += 12
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        
        sheet.write_row(row, col, [
            (self.MapProvider),
            (self.CountryCode),
            (self.CyclicCounter),
            (self.MajorProtocolVersion),
            (self.MinorProtocolSubVersion),
            (self.HardwareVersion),
            (self.DrivingSide),
            (self.RegionCode),
            (self.MapVersionYearQuarter),
            (self.MapVersionYear),
            (self.SpeedUnits),
            (self.MinorProtocolVersion)])
        
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)


#-----------------------------------------------#
#----   ADASISv2METADATA_ETH                ----#
#-----------------------------------------------#
class ADASISv2METADATA_ETH(ADASISv2METADATA):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        self.ADASISinfo = ADASISinfoManager.getADASISinfo_forEth()
        
        
#-----------------------------------------------#
#----   ADASISv2METADATA_CAN                ----#
#-----------------------------------------------#
class ADASISv2METADATA_CAN(ADASISv2METADATA):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        self.ADASISinfo = ADASISinfoManager.getADASISinfo_forCAN()
    
    
#-----------------------------------------------#
#----   ADASISv2POSITION                    ----#
#-----------------------------------------------#
class ADASISv2POSITION(Message):    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None, processRelativeParse = True):
        readFunc = self.data.readValue
        readFunc(int,3) #Reserve
        self.Offset = readFunc(int,13)
        self.CyclicCounter = readFunc(int,2)
        self.PathIndex = readFunc(int,6)
        self.PositionIndex = readFunc(int,2)
        self.PositionProbablility = readFunc(int,5)
        self.PositionAge = readFunc(int,9)
        readFunc(int,1) #Checksum
        self.PositionConfidence = readFunc(int,3)
        readFunc(int,3) #Checksum
        self.Speed = readFunc(int,9)
        self.RelativeHeading = readFunc(int,8)
        self.assertMessageSize()
        
        self.longitude = 180
        self.latitude = 180
        self.latestAvailableLonLat = [180, 180]
        
        if processRelativeParse:
            self.ADASISinfo.setCurrentPosition(self.PathIndex, self.Offset)
            self.ADASISinfo_getLonLat = self.ADASISinfo.getLonLat(self.PathIndex, self.Offset)
            self.ADASISinfo_adjustOffset = self.ADASISinfo.adjustOffset(self.PathIndex, self.Offset)
        else:
            self.ADASISinfo_getLonLat = (180, 180)
            self.ADASISinfo_adjustOffset = None

    def printHeader(self, sheet, row, col, _level = 1):
        [_, col, _] = self.commonHeader.printHeader(sheet, row, col)
        
        if self.ADASISinfo_adjustOffset != None:
            sheet.write_row(row, col, [
                'Path Index',
                'Offset', 
                'Offset(Adj)', 
                'Cyclic Counter', 
                'Position Index',
                'Position Probablility',
                'Position Age',
                'Position Confidence',
                'Speed',
                'Relative Heading'], sheet.cellFormats('header'))
            col += 10
        else:
            sheet.write_row(row, col, [
                'Path Index',
                'Offset', 
                'Cyclic Counter', 
                'Position Index',
                'Position Probablility',
                'Position Age',
                'Position Confidence',
                'Speed',
                'Relative Heading'], sheet.cellFormats('header'))
            col += 9
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        
        if self.ADASISinfo_adjustOffset != None:
            sheet.write_row(row, col, [
                (self.PathIndex),
                (self.Offset),
                (self.ADASISinfo_adjustOffset),
                (self.CyclicCounter),
                (self.PositionIndex),
                (self.PositionProbablility),
                (self.PositionAge),
                (self.PositionConfidence),
                (self.Speed),
                (self.RelativeHeading)])
        else:
            sheet.write_row(row, col, [
                (self.PathIndex),
                (self.Offset),
                (self.CyclicCounter),
                (self.PositionIndex),
                (self.PositionProbablility),
                (self.PositionAge),
                (self.PositionConfidence),
                (self.Speed),
                (self.RelativeHeading)])
        
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
    class LayerType(Enum):
        ADASIS_Position = 39
        
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.ADASIS_Position:
            #直線で描画時
#             symbollist = layer.renderer().symbols(QgsRenderContext())
#             symbol = symbollist[0]
#             symbol.setColor(QtGui.QColor.fromRgb(0,200,0))
#             symbol.setWidth(0.4)
#             layer.beginEditCommand( 'QGIS draw' )
            
            #矢印で描画時
            #!!!！なぜか以下のコードで矢印を描くと、一部のPCではQgisがCrashする。!!!！
            #sl = QgsSymbolLayerRegistry().symbolLayerMetadata('ArrowLine').createSymbolLayer({ 'width' : '0.1', 'color' : '255,0,0' })     
            #symbollist = newLayer_v.renderer().symbols(QgsRenderContext())
            #symbol = symbollist[0]
            #symbol.appendSymbolLayer(sl)
            #以下のコードなら大丈夫だった
            symLyr = QgsArrowSymbolLayer()
            symLyr.setIsCurved(False)
            symLyr.setIsRepeated(False)
            symLyr.setColor(QtGui.QColor.fromRgb(0,200,0))
            layer.renderer().symbols(QgsRenderContext())[0].changeSymbolLayer(0, symLyr)
            layer.beginEditCommand( 'QGIS draw' )
            
            return [layer, layerType.value]
        
        else:
            return None
        
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if getADASISanalyze() == False:
            return None

        newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&field=PathIndex:int&field=Offset:int&index=yes',name,'memory')
        newLayer = self.SetLayerStyle(self.LayerType.ADASIS_Position, newLayer)

        return [newLayer]
        
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        if getADASISanalyze() == False:
            return
        newLayer = None
        for layerListItem in layerList:
            if layerListItem[1] == ADASISv2POSITION.LayerType.ADASIS_Position.value:
                newLayer = layerListItem[0]
         
#         if str(self.commonHeader.logTime) == '1970-01-02 09:09:26.588914':
#             print('here')
        
        [lon, lat] = self.ADASISinfo_getLonLat
        self.longitude = lon
        self.latitude = lat
        logger = getLogger()
        logger.debugLog('<ADASISv2POSITION getLonLat>, PathIndex = {} , offset = {} , '.format(self.PathIndex, self.Offset) + str([lon, lat]))
            
        old = self.oldMessage
        if newLayer != None:
            if old == None:
                if checkInvalidLonLat(lon, lat) == True:
                    self.latestAvailableLonLat = [lon, lat]
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(lon, lat), QgsPoint(lon + 0.000005, lat + 0.000005)]))
                    feature.setAttributes([QDateTime(self.commonHeader.logTime), lon, lat, self.PathIndex, self.Offset])
                    newLayer.dataProvider().addFeatures( [feature] )
            elif checkInvalidLonLat(lon, lat, old.longitude, old.latitude, allowSamePoint = True) == True:
                self.latestAvailableLonLat = [lon, lat]
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(old.longitude, old.latitude), QgsPoint(lon, lat)]))
                feature.setAttributes([QDateTime(self.commonHeader.logTime), lon, lat, self.PathIndex, self.Offset])
                newLayer.dataProvider().addFeatures( [feature] )
            else:
                self.latestAvailableLonLat = old.latestAvailableLonLat

    def getLonLat(self):
        return [self.longitude, self.latitude]

#-----------------------------------------------#
#----   ADASISv2POSITION_ETH                ----#
#-----------------------------------------------#
class ADASISv2POSITION_ETH(ADASISv2POSITION):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        self.ADASISinfo = ADASISinfoManager.getADASISinfo_forEth()
        
        
#-----------------------------------------------#
#----   ADASISv2POSITION_CAN                ----#
#-----------------------------------------------#
class ADASISv2POSITION_CAN(ADASISv2POSITION):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        self.ADASISinfo = ADASISinfoManager.getADASISinfo_forCAN()


#-----------------------------------------------#
#----   ADASISv2SEGMENT                     ----#
#-----------------------------------------------#
class ADASISv2SEGMENT(Message):
    FormOfWaySymbolDic = {
        0:(QtGui.QColor.fromRgb(0,0,0),'(0)Unknown', 0.5),
        1:(QtGui.QColor.fromRgb(50,50,0),'(1)Freeway or Controlled Access', 0.5),
        2:(QtGui.QColor.fromRgb(0,50,50),'(2)Multiple Carriageway or Digitized Road', 0.5),
        3:(QtGui.QColor.fromRgb(50,0,50),'(3)Single Carriageway', 0.5),
        4:(QtGui.QColor.fromRgb(100,100,50),'(4)Roundabout Circle', 0.5),
        5:(QtGui.QColor.fromRgb(50,100,100),'(5)Traffic Square or Special Traffic Figure', 0.5),
        6:(QtGui.QColor.fromRgb(100,50,100),'(6)Junction', 0.5),
        7:(QtGui.QColor.fromRgb(150,0,150),'(7)not used', 0.5),
        8:(QtGui.QColor.fromRgb(150,150,0),'(8)Parallel Road (special slip road or ramp)', 0.5),
        9:(QtGui.QColor.fromRgb(0,150,150),'(9)ramp on freeway', 0.5),
        10:(QtGui.QColor.fromRgb(200,200,0),'(10)ramp on other (not freeway)', 0.5),
        11:(QtGui.QColor.fromRgb(0,200,200),'(11)service road or Frontage Road', 0.5),
        12:(QtGui.QColor.fromRgb(200,0,200),'(12)entrance or exit car park', 0.5),
        13:(QtGui.QColor.fromRgb(250,250,50),'(13)entrance or exit to service', 0.5),
        14:(QtGui.QColor.fromRgb(50,250,250),'(14)pedastrian zone', 0.5),
        15:(QtGui.QColor.fromRgb(250,50,250),'(15)not available', 0.5)}

    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None, processRelativeParse = True):
        readFunc = self.data.readValue
        readFunc(int,1) #Reserve
        self.AD2flag = readFunc(int,1)
        self.SpeedUnits = readFunc(int,1)
        self.Offset = readFunc(int,13)
        self.CyclicCounter = readFunc(int,2)
        self.PathIndex = readFunc(int,6)
        self.Tunnel = readFunc(int,2)
        self.Bridge = readFunc(int,2)
        self.BuildUpArea = readFunc(int,2)
        self.Retransmission = readFunc(int,1)
        self.Update = readFunc(int,1)
        self.RelativeProbability = readFunc(int,5)
        self.FunctionalRoadClass = readFunc(int,3)
        self.PartOfCalculatedRoute = readFunc(int,2)
        readFunc(int,1) #Reserve
        self.ExpresswayFlag = readFunc(int,1)
        self.FormOfWay = readFunc(int,4)
        self.EffectiveSpeedLimit = readFunc(int,5)
        self.EffectiveSpeedLimitType = readFunc(int,3)
        readFunc(int,4) #Checksum
        self.NumberOfLanesInDrivingDirection = readFunc(int,4)
        self.assertMessageSize()
        
        if processRelativeParse:
            self.ADASISinfo_getLonLat = self.ADASISinfo.getLonLat(self.PathIndex, self.Offset) 
            self.ADASISinfo_getLonLat_StubLine = self.ADASISinfo.getLonLat_StubLine(self.PathIndex, 0, self.Offset)
            self.ADASISinfo_adjustOffset = self.ADASISinfo.adjustOffset(self.PathIndex, self.Offset)
        else:
            self.ADASISinfo_getLonLat = (180, 180)
            self.ADASISinfo_getLonLat_StubLine = [(180, 180), (180, 180)]
            self.ADASISinfo_adjustOffset = None

    def printHeader(self, sheet, row, col, _level = 1):
        [_, col, _] = self.commonHeader.printHeader(sheet, row, col)
        
        if self.ADASISinfo_adjustOffset != None:
            sheet.write_row(row, col, [
                'Path Index',
                'Offset',
                'Offset(Adj)', 
                'Cyclic Counter',
                'AD2 flag', 
                'Speed Units', 
                'Tunnel',
                'Bridge',
                'Build-up Area',
                'Retransmission',
                'Update',
                'Relative Probability',
                'Functional Road Class',
                'Part of Calculated route',
                'Expressway Flag',
                'Form of Way',
                'Effective Speed Limit',
                'Effective Speed Limit Type',
                'Number of Lanes in driving direction'], sheet.cellFormats('header'))
            col += 19
        else:
            sheet.write_row(row, col, [
                'Path Index',
                'Offset',
                'Cyclic Counter',
                'AD2 flag', 
                'Speed Units', 
                'Tunnel',
                'Bridge',
                'Build-up Area',
                'Retransmission',
                'Update',
                'Relative Probability',
                'Functional Road Class',
                'Part of Calculated route',
                'Expressway Flag',
                'Form of Way',
                'Effective Speed Limit',
                'Effective Speed Limit Type',
                'Number of Lanes in driving direction'], sheet.cellFormats('header'))
            col += 18
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        
        if self.ADASISinfo_adjustOffset != None:
            sheet.write_row(row, col, [
                (self.PathIndex),
                (self.Offset),
                (self.ADASISinfo_adjustOffset),
                (self.CyclicCounter),
                (self.AD2flag),
                (self.SpeedUnits),
                (self.Tunnel),
                (self.Bridge),
                (self.BuildUpArea),
                (self.Retransmission),
                (self.Update),
                (self.RelativeProbability),
                (self.FunctionalRoadClass),
                (self.PartOfCalculatedRoute),
                (self.ExpresswayFlag),
                (self.FormOfWay),
                (self.EffectiveSpeedLimit),
                (self.EffectiveSpeedLimitType),
                (self.NumberOfLanesInDrivingDirection)])
        else:
            sheet.write_row(row, col, [
                (self.PathIndex),
                (self.Offset),
                (self.CyclicCounter),
                (self.AD2flag),
                (self.SpeedUnits),
                (self.Tunnel),
                (self.Bridge),
                (self.BuildUpArea),
                (self.Retransmission),
                (self.Update),
                (self.RelativeProbability),
                (self.FunctionalRoadClass),
                (self.PartOfCalculatedRoute),
                (self.ExpresswayFlag),
                (self.FormOfWay),
                (self.EffectiveSpeedLimit),
                (self.EffectiveSpeedLimitType),
                (self.NumberOfLanesInDrivingDirection)])
        
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
    
    class LayerType(Enum):
        ADASIS_Segment = 32
        ADASIS_Segment_FoW = 41
        
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.ADASIS_Segment:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(255,255,0))
            symbol.setWidth(2.0)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]  
        
        elif layerType == cls.LayerType.ADASIS_Segment_FoW:
            layer = myQgsRendererCategoryLayer(layer, cls.FormOfWaySymbolDic, 'FormOfWay')
            return [layer, layerType.value]
        
        else:
            return None
        
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if getADASISanalyze() == False:
            return None

        newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double' +
                                        '&field=AD2flag:int' +
                                        '&field=SpeedUnits:int' +
                                        '&field=Offset:int' +
                                        '&field=CyclicCounter:int' +
                                        '&field=PathIndex:int' +
                                        '&field=Tunnel:int' +
                                        '&field=Bridge:int' +
                                        '&field=BuildUpArea:int' +
                                        '&field=Retransmission:int' +
                                        '&field=Update:int' +
                                        '&field=RelativeProbability:int' +
                                        '&field=FunctionalRoadClass:int' +
                                        '&field=PartOfCalculatedRoute:int' +
                                        '&field=ExpresswayFlag:int' +
                                        '&field=FormOfWay:int' +
                                        '&field=EffectiveSpeedLimit:int' +
                                        '&field=EffectiveSpeedLimitType:int' +
                                        '&field=NumberOfLanesInDrivingDirection:int' +
                                        '&index=yes',name,'memory')
        newLayer = self.SetLayerStyle(self.LayerType.ADASIS_Segment, newLayer)
        
        newLayer_fow = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&field=FormOfWay:int&index=yes','FormOfWay-' + name,'memory')
        newLayer_fow = self.SetLayerStyle(self.LayerType.ADASIS_Segment_FoW, newLayer_fow)
        
        return [newLayer, newLayer_fow]
        
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        if getADASISanalyze() == False:
            return
        
        newLayer = None
        newLayer_fow = None
        for layerListItem in layerList:
            if layerListItem[1] == ADASISv2SEGMENT.LayerType.ADASIS_Segment.value:
                newLayer = layerListItem[0]
            if layerListItem[1] == ADASISv2SEGMENT.LayerType.ADASIS_Segment_FoW.value:
                newLayer_fow = layerListItem[0]
        
        [lon, lat] = self.ADASISinfo_getLonLat       

        if newLayer != None:    
            if checkInvalidLonLat(lon, lat) == True:
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(lon, lat), QgsPoint(lon + 0.000005, lat + 0.000005)]))
                feature.setAttributes([QDateTime(self.commonHeader.logTime), lon, lat,
                                        (self.AD2flag),
                                        (self.SpeedUnits),
                                        (self.Offset),
                                        (self.CyclicCounter),
                                        (self.PathIndex),
                                        (self.Tunnel),
                                        (self.Bridge),
                                        (self.BuildUpArea),
                                        (self.Retransmission),
                                        (self.Update),
                                        (self.RelativeProbability),
                                        (self.FunctionalRoadClass),
                                        (self.PartOfCalculatedRoute),
                                        (self.ExpresswayFlag),
                                        (self.FormOfWay),
                                        (self.EffectiveSpeedLimit),
                                        (self.EffectiveSpeedLimitType),
                                        (self.NumberOfLanesInDrivingDirection)])
                newLayer.dataProvider().addFeatures( [feature] )
        
        if newLayer_fow != None:    
            posList = self.ADASISinfo_getLonLat_StubLine
            drawPointList = []
            feature = QgsFeature()
            
            for i in range(len(posList)-1):
                (lon, lat) = posList[i]
                (targetLon, targetLat) = posList[i+1]
                if checkInvalidLonLat(lon, lat, targetLon, targetLat) == True:
                    drawPointList.append(QgsPoint(lon, lat))
                    drawPointList.append(QgsPoint(targetLon, targetLat))
                elif checkInvalidLonLat(lon, lat) == True:
                    drawPointList.append(QgsPoint(lon, lat))
                    drawPointList.append(QgsPoint(lon+0.000001, lat+0.000001))
            feature.setGeometry(QgsGeometry.fromPolyline(drawPointList))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), lon, lat, self.FormOfWay])
            newLayer_fow.dataProvider().addFeatures( [feature] )
        

#-----------------------------------------------#
#----   ADASISv2SEGMENT_ETH                 ----#
#-----------------------------------------------#
class ADASISv2SEGMENT_ETH(ADASISv2SEGMENT):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        self.ADASISinfo = ADASISinfoManager.getADASISinfo_forEth()
        
        
#-----------------------------------------------#
#----   ADASISv2SEGMENT_CAN                 ----#
#-----------------------------------------------#
class ADASISv2SEGMENT_CAN(ADASISv2SEGMENT):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        self.ADASISinfo = ADASISinfoManager.getADASISinfo_forCAN()
        
        
#-----------------------------------------------#
#----   ADASISv2STUB                        ----#
#-----------------------------------------------#
class ADASISv2STUB(Message):
    RerouteDic = {0:'Rerouting Flag off', 1:'Rerouting Flag on'}
    Stub0Dic = {0:'Stub 0'}
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None, processRelativeParse = True):
        readFunc = self.data.readValue
        self.LastStubAtOffset = readFunc(int,1)
        self.ReroutingFlag = readFunc(int,1)
        readFunc(int,1) #Reserve
        self.Offset = readFunc(int,13)
        self.CyclicCounter = readFunc(int,2)
        self.PathIndex = readFunc(int,6)
        self.SubPathIndex = readFunc(int,6)
        self.Retransmission = readFunc(int,1)
        self.Update = readFunc(int,1)
        self.RelativeProbability = readFunc(int,5)
        self.FunctionalRoadClass = readFunc(int,3)
        self.PartOfCalculatedRoute = readFunc(int,2)
        readFunc(int,1) #Reserve
        self.ExpresswayFlag = readFunc(int,1)
        self.FormOfWay = readFunc(int,4)
        self.TurnAngle = readFunc(int,8)
        readFunc(int,4) #Checksum
        self.NumberOfLanesInDrivingDirection = readFunc(int,4)
        self.assertMessageSize()
        
#             if str(self.commonHeader.logTime) == '1970-01-02 09:06:23.696855':
#                 print('here')
#             if self.PathIndex == 16:
#                 print('here')
        if processRelativeParse:
            if self.PathIndex == 0:
                self.ADASISinfo.reset()
            elif self.PathIndex >= 8:
                self.ADASISinfo.setStub(self.PathIndex, self.Offset, self.SubPathIndex, self.TurnAngle)
                self.ADASISinfo_getLonLat_StubLine = self.ADASISinfo.getLonLat_StubLine(self.PathIndex, self.SubPathIndex, self.Offset)
            self.ADASISinfo_adjustOffset = self.ADASISinfo.adjustOffset(self.PathIndex, self.Offset)
        else:
            self.ADASISinfo_getLonLat_StubLine = [(180, 180), (180, 180)]
            self.ADASISinfo_adjustOffset = None

    def printHeader(self, sheet, row, col, _level = 1):
        [_, col, _] = self.commonHeader.printHeader(sheet, row, col)
        
        if self.ADASISinfo_adjustOffset != None:
            sheet.write_row(row, col, [
                'Path Index',
                'Offset',
                'Offset(Adj)', 
                'Cyclic Counter',
                'Last Stub at Offset', 
                'Rerouting Flag', 
                'Sub-path Index',
                'Retransmission',
                'Update',
                'Relative Probability',
                'Functional Road Class',
                'Part of Calculated route',
                'Expressway Flag',
                'Form of Way',
                'Turn angle',
                'Number of Lanes in driving direction'], sheet.cellFormats('header'))
            col += 15
        else:
            sheet.write_row(row, col, [
                'Path Index',
                'Offset',
                'Cyclic Counter',
                'Last Stub at Offset', 
                'Rerouting Flag', 
                'Sub-path Index',
                'Retransmission',
                'Update',
                'Relative Probability',
                'Functional Road Class',
                'Part of Calculated route',
                'Expressway Flag',
                'Form of Way',
                'Turn angle',
                'Number of Lanes in driving direction'], sheet.cellFormats('header'))
            col += 14
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        
        if self.ADASISinfo_adjustOffset != None:
            sheet.write_row(row, col, [
                (self.PathIndex),
                (self.Offset),
                (self.ADASISinfo_adjustOffset),
                (self.CyclicCounter),
                (self.LastStubAtOffset),
                (self.ReroutingFlag),
                (self.SubPathIndex),
                (self.Retransmission),
                (self.Update),
                (self.RelativeProbability),
                (self.FunctionalRoadClass),
                (self.PartOfCalculatedRoute),
                (self.ExpresswayFlag),
                (self.FormOfWay),
                (self.TurnAngle),
                (self.NumberOfLanesInDrivingDirection)])
        else:
            sheet.write_row(row, col, [
                (self.PathIndex),
                (self.Offset),
                (self.CyclicCounter),
                (self.LastStubAtOffset),
                (self.ReroutingFlag),
                (self.SubPathIndex),
                (self.Retransmission),
                (self.Update),
                (self.RelativeProbability),
                (self.FunctionalRoadClass),
                (self.PartOfCalculatedRoute),
                (self.ExpresswayFlag),
                (self.FormOfWay),
                (self.TurnAngle),
                (self.NumberOfLanesInDrivingDirection)])
            
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
    class LayerType(Enum):
        ADASIS_Stub_Zero = 34
        ADASIS_StubInfo = 35
        ADASIS_Stub = 36
    
    Pocr_symbolDic = {
         0:(QtGui.QColor.fromRgb(0xcc, 0x6b, 0x4d),'(0) Sub Path', 0.6),
         1:(QtGui.QColor.fromRgb(0x4d, 0x6b, 0xcc),'(1) Main Path (gidance)', 0.6),
         2:(QtGui.QColor.fromRgb(0x4d, 0x6b, 0xcc),'(2) MPP', 0.6),
         }
    
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.ADASIS_StubInfo:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(0,255,0))
            symbol.setWidth(1.2)
            label_settings = QgsPalLayerSettings()
            label_settings.drawLabels = True
            label_settings.fieldName = 'Event'
            label_settings.placement = QgsPalLayerSettings.Horizontal
            #label_settings.placement = QgsPalLayerSettings.Line
            label_settings.overrunDistance = 1000
            format = label_settings.format()
            format.setColor(QtGui.QColor.fromRgb(0,0,0))
            format.setFont(QtGui.QFont("Consolas", 15, weight = QtGui.QFont.Bold))
            label_settings.setFormat(format)
            layer.setLabeling(QgsVectorLayerSimpleLabeling(label_settings))
            layer.setLabelsEnabled(True)
            return [layer, layerType.value]
        
        elif layerType == cls.LayerType.ADASIS_Stub:
            if layer.fields().indexFromName('PartOfCalculatedRoute') != -1:
                layer = myQgsRendererCategoryMarkerLayer(layer, ADASISv2STUB.Pocr_symbolDic, 'PartOfCalculatedRoute')
            else:
                layer = myQgsRendererCategoryMarkerLayer(layer, ADASISv2STUB.Pocr_symbolDic, 'PartOfCalc')
            return [layer, layerType.value]   
        
        elif layerType == cls.LayerType.ADASIS_Stub_Zero:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(0,0,0))
            symbol.setWidth(0.8)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
        
        else:
            return None
    
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if getADASISanalyze() == False:
            return None
        
        if realTimeMode == DrawMode.FullDraw:
            newLayer_info = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Event:string&field=Longitude:double&field=Latitude:double&index=yes',name + '(reroute)','memory')
            newLayer_info = self.SetLayerStyle(self.LayerType.ADASIS_StubInfo, newLayer_info)
            
            newLayer_stub_zero = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&index=yes',name + '(Stub 0 area)','memory')
            newLayer_stub_zero = self.SetLayerStyle(self.LayerType.ADASIS_Stub_Zero, newLayer_stub_zero)
            
        newLayer_stub = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&'
                                                + 'field=LastStubAtOffset:int&'
                                                + 'field=ReroutingFlag:int&'
                                                + 'field=CyclicCounter:int&'
                                                + 'field=Offset:int&'
                                                + 'field=PathIndex:int&'
                                                + 'field=SubPathIndex:int&'
                                                + 'field=Retransmission:int&'
                                                + 'field=Update:int&'
                                                + 'field=RelativeProbability:int&'
                                                + 'field=FunctionalRoadClass:int&'
                                                + 'field=PartOfCalculatedRoute:int&'
                                                + 'field=ExpresswayFlag:int&'
                                                + 'field=FormOfWay:int&'
                                                + 'field=TurnAngle:int&'
                                                + 'field=NumberOfLanesInDrivingDirection:int&index=yes',name,'memory')
        newLayer_stub = self.SetLayerStyle(self.LayerType.ADASIS_Stub, newLayer_stub)
            
        if realTimeMode == DrawMode.FullDraw:
            return [newLayer_info, newLayer_stub, newLayer_stub_zero]
        else:
            return [newLayer_stub]
    
    def drawStubinfo(self, targetLayer, old, *args):
        info = ''
        for valueName, dic in args:
            oldValue = eval('old.' + valueName)
            newValue = eval('self.' + valueName)
            if oldValue == newValue:
                continue

            if type(dic) == type({}):
                if not (newValue in dic):
                    continue
                event = dic[newValue]
            elif type(dic) == type([]):
                oldGroup = bisect.bisect(dic[0], oldValue)
                newGroup = bisect.bisect(dic[0], newValue)
                if oldGroup == newGroup:
                    continue
                event = dic[1][newGroup]
            
            if event != '':    
                if info == '': info += event
                else: info += '\n' + event
        
        if info != '':
            if self.infoPosition == None:
                return
            lat1 = self.infoPosition[0]
            lon1 = self.infoPosition[1]
            lat2 = self.infoPosition[2]
            lon2 = self.infoPosition[3]
                 
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline(
                [QgsPoint(lon1, lat1), QgsPoint(lon2, lat2)] ))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), info, lon1, lat1])
            targetLayer.dataProvider().addFeatures( [feature] )
    
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        if getADASISanalyze() == False:
            return
        old = self.oldMessage
        if old == None:
            return
        layer_info = None
        layer_stub = None
        layer_stub_zero = None
        for layerListItem in layerList:
            if layerListItem[1] == ADASISv2STUB.LayerType.ADASIS_StubInfo.value:
                layer_info = layerListItem[0]
            if layerListItem[1] == ADASISv2STUB.LayerType.ADASIS_Stub.value:
                layer_stub = layerListItem[0]
            if layerListItem[1] == ADASISv2STUB.LayerType.ADASIS_Stub_Zero.value:
                layer_stub_zero = layerListItem[0]
        
        [curlon, curlat] = self.getRelatedPosition([self.relatedCarPositionMessage, self.relatedIVIPositionMessage, self.relatedADASISPositionMessage])
        if self.ReroutingFlag == 1 or self.PathIndex == 0:
            logger = getLogger()
            logger.debugLog('<Stub info>, ReroutingFlag = {} , PathIndex = {}'.format(self.ReroutingFlag, self.PathIndex))
            logger.debugLog('<Stub info>, lon = {} , lat = {}'.format(curlon, curlat))

        if layer_info != None:
            if checkInvalidLonLat(curlon, curlat) == True:
                self.infoPosition = (curlat, curlon, curlat + 0.000005, curlon + 0.000005)
                self.drawStubinfo(layer_info, old,  ('ReroutingFlag', ADASISv2STUB.RerouteDic))
                if self.PathIndex == 0:
                    self.drawStubinfo(layer_info, old,  ('PathIndex', ADASISv2STUB.Stub0Dic))
                
        if self.PathIndex == 0:
            if layer_stub_zero != None:
                if old.PathIndex == 0:
                    [oldlon, oldlat] = old.getRelatedPosition([old.relatedCarPositionMessage, old.relatedIVIPositionMessage, old.relatedADASISPositionMessage])
                    if checkInvalidLonLat(curlon, curlat, oldlon, oldlat) == True:
                        feature = QgsFeature()
                        feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldlon, oldlat), QgsPoint(curlon, curlat)]))
                        feature.setAttributes([QDateTime(self.commonHeader.logTime)])
                        layer_stub_zero.dataProvider().addFeatures( [feature] )
                
        if self.PathIndex >= 8:                
            if layer_stub != None:
                posList = self.ADASISinfo_getLonLat_StubLine
                drawPointList = []
                feature = QgsFeature()
                for i in range(len(posList)-1):
                    (lon, lat) = posList[i]
                    (targetLon, targetLat) = posList[i+1]
                    if checkInvalidLonLat(lon, lat, targetLon, targetLat) == True:
                        drawPointList.append(QgsPoint(lon, lat))
                        drawPointList.append(QgsPoint(targetLon, targetLat))
                    elif checkInvalidLonLat(lon, lat) == True:
                        drawPointList.append(QgsPoint(lon, lat))
                        drawPointList.append(QgsPoint(lon+0.000001, lat+0.000001))
                feature.setGeometry(QgsGeometry.fromPolyline(drawPointList))
                feature.setAttributes([QDateTime(self.commonHeader.logTime), lon, lat, 
                                        self.LastStubAtOffset,
                                        self.ReroutingFlag,
                                        self.CyclicCounter,
                                        self.Offset,
                                        self.PathIndex,
                                        self.SubPathIndex,
                                        self.Retransmission,
                                        self.Update,
                                        self.RelativeProbability,
                                        self.FunctionalRoadClass,
                                        self.PartOfCalculatedRoute,
                                        self.ExpresswayFlag,
                                        self.FormOfWay,
                                        self.TurnAngle,
                                        self.NumberOfLanesInDrivingDirection])
                layer_stub.dataProvider().addFeatures( [feature] )


#-----------------------------------------------#
#----   ADASISv2STUB_ETH                    ----#
#-----------------------------------------------#
class ADASISv2STUB_ETH(ADASISv2STUB):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        self.ADASISinfo = ADASISinfoManager.getADASISinfo_forEth()
        
        
#-----------------------------------------------#
#----   ADASISv2STUB_CAN                    ----#
#-----------------------------------------------#
class ADASISv2STUB_CAN(ADASISv2STUB):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        self.ADASISinfo = ADASISinfoManager.getADASISinfo_forCAN()
        
        
#-----------------------------------------------#
#----   ADASISv2PROFILESHORT                ----#
#-----------------------------------------------#
class ADASISv2PROFILESHORT(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None, processRelativeParse = True):
        readFunc = self.data.readValue
        readFunc(int,3) #Checksum
        self.Offset = readFunc(int,13)
        self.CyclicCounter = readFunc(int,2)
        self.PathIndex = readFunc(int,6)
        self.ProfileType = readFunc(int,5)
        readFunc(int,1) #Checksum
        self.Retransmission = readFunc(int,1)
        self.Update = readFunc(int,1)
        self.Accuracy = readFunc(int,2)
        self.Distance = readFunc(int,10)
        self.Value0 = readFunc(int,10)
        self.Value1 = readFunc(int,10)
        self.assertMessageSize()
        
        if processRelativeParse:
            self.ADASISinfo_getLonLat = self.ADASISinfo.getLonLat(self.PathIndex, self.Offset)
            if self.Distance > 0:    
                self.ADASISinfo_getLonLat_distance = self.ADASISinfo.getLonLat(self.PathIndex, self.Offset+self.Distance)
            else:
                self.ADASISinfo_getLonLat_distance = self.ADASISinfo_getLonLat
            self.ADASISinfo_adjustOffset = self.ADASISinfo.adjustOffset(self.PathIndex, self.Offset)
        else:
            self.ADASISinfo_getLonLat = (180, 180)
            self.ADASISinfo_getLonLat_distance = (180, 180)
            self.ADASISinfo_adjustOffset = None

    def printHeader(self, sheet, row, col, _level = 1):
        [_, col, _] = self.commonHeader.printHeader(sheet, row, col)
        
        if self.ADASISinfo_adjustOffset != None:
            sheet.write_row(row, col, [
                'Path Index', 
                'Offset', 
                'Offset(Adj)', 
                'Cyclic Counter', 
                'Profile type', 
                'Retransmission', 
                'Update', 
                'Accuracy', 
                'Distance', 
                'Value 0', 
                'Value 1'], sheet.cellFormats('header'))
            col += 11
        else:
            sheet.write_row(row, col, [
                'Path Index', 
                'Offset', 
                'Cyclic Counter', 
                'Profile type', 
                'Retransmission', 
                'Update', 
                'Accuracy', 
                'Distance', 
                'Value 0', 
                'Value 1'], sheet.cellFormats('header'))
            col += 10
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        
        if self.ADASISinfo_adjustOffset != None:
            sheet.write_row(row, col, [
                (self.PathIndex),
                (self.Offset),
                (self.ADASISinfo_adjustOffset),
                (self.CyclicCounter),
                (self.ProfileType),
                (self.Retransmission),
                (self.Update),
                (self.Accuracy),
                (self.Distance),
                (self.Value0),
                (self.Value1)])
        else:
            sheet.write_row(row, col, [
                (self.PathIndex),
                (self.Offset),
                (self.CyclicCounter),
                (self.ProfileType),
                (self.Retransmission),
                (self.Update),
                (self.Accuracy),
                (self.Distance),
                (self.Value0),
                (self.Value1)])
        
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
    class LayerType(Enum):
        ADASIS_ProfileShort = 37
        ADASIS_ProfileShort_Curvature = 38
    
    ProfileShort_symbolDic = {
             1:(QtGui.QColor.fromRgb(200,0,50),'(1) Curvature', 2.0),
             4:(QtGui.QColor.fromRgb(200,50,100),'(4) Slope', 2.0),
             16:(QtGui.QColor.fromRgb(250,100,0),'(16) average vehicle speed', 2.0)
             }
    
    ProfileShort_Curvature_symbolList = [ #for graduated
            # min , max , color
            (-511, -310, QtGui.QColor.fromRgb(255,0,0)),
            (-310, -150, QtGui.QColor.fromRgb(255,80,80)),
            (-150, -90, QtGui.QColor.fromRgb(255,150,150)),
            (-90, -30, QtGui.QColor.fromRgb(255,200,200)),
            (-30, 30, QtGui.QColor.fromRgb(255,255,255)),
            (30, 90, QtGui.QColor.fromRgb(200,200,255)),
            (90, 150, QtGui.QColor.fromRgb(150,150,255)),
            (150, 310, QtGui.QColor.fromRgb(80,80,255)),
            (310, 511, QtGui.QColor.fromRgb(0,0,255)),
        ]
    
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.ADASIS_ProfileShort:
            layer = myQgsRendererCategoryLayer(layer, ADASISv2PROFILESHORT.ProfileShort_symbolDic)
            return [layer, layerType.value]
        elif layerType == cls.LayerType.ADASIS_ProfileShort_Curvature:
            layer = myQgsGraduatedCategoryLayer(layer, ADASISv2PROFILESHORT.ProfileShort_Curvature_symbolList, categoryName = '"Value" - 511', width = 2)
            return [layer, layerType.value]  
        else:
            return None
    
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if getADASISanalyze() == False:
            return None
        
        newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&field=Longitude:double&field=Latitude:double&field=PathIndex:int&field=Offset:int&field=Distance:int&field=Value:int&index=yes',name,'memory')
        newLayer = self.SetLayerStyle(self.LayerType.ADASIS_ProfileShort, newLayer)
        
        newLayer_curvature = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&field=Longitude:double&field=Latitude:double&field=PathIndex:int&field=Offset:int&field=Distance:int&field=Value:int&index=yes',name + '(Curvature)','memory')
        newLayer_curvature = self.SetLayerStyle(self.LayerType.ADASIS_ProfileShort_Curvature, newLayer_curvature)
        
        return [newLayer, newLayer_curvature]
        
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        if getADASISanalyze() == False:
            return
        
        layer = None
        layer_curvature = None
        for layerListItem in layerList:
            if layerListItem[1] == ADASISv2PROFILESHORT.LayerType.ADASIS_ProfileShort.value:
                layer = layerListItem[0]
            elif layerListItem[1] == ADASISv2PROFILESHORT.LayerType.ADASIS_ProfileShort_Curvature.value:
                layer_curvature = layerListItem[0]
        
        if layer != None:
            [lon, lat] = self.ADASISinfo_getLonLat
            if checkInvalidLonLat(lon, lat) == True:
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(lon, lat), QgsPoint(lon + 0.000005, lat + 0.000005)]))
                feature.setAttributes([QDateTime(self.commonHeader.logTime), self.ProfileType, lon, lat, self.PathIndex, self.Offset, 0, self.Value0])
                layer.dataProvider().addFeatures( [feature] )
            
            if self.Distance > 0:    
                [lon, lat] = self.ADASISinfo_getLonLat_distance
                if checkInvalidLonLat(lon, lat) == True:
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(lon, lat), QgsPoint(lon + 0.000005, lat + 0.000005)]))
                    feature.setAttributes([QDateTime(self.commonHeader.logTime), self.ProfileType, lon, lat, self.PathIndex, self.Offset, self.Distance, self.Value1])
                    layer.dataProvider().addFeatures( [feature] )
                    
        if layer_curvature != None and self.ProfileType == 1:
            [lon, lat] = self.ADASISinfo_getLonLat
            if checkInvalidLonLat(lon, lat) == True:
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(lon, lat), QgsPoint(lon + 0.000005, lat + 0.000005)]))
                feature.setAttributes([QDateTime(self.commonHeader.logTime), self.ProfileType, lon, lat, self.PathIndex, self.Offset, 0, self.Value0])
                layer_curvature.dataProvider().addFeatures( [feature] )
            
            if self.Distance > 0:    
                [lon, lat] = self.ADASISinfo_getLonLat_distance
                if checkInvalidLonLat(lon, lat) == True:
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(lon, lat), QgsPoint(lon + 0.000005, lat + 0.000005)]))
                    feature.setAttributes([QDateTime(self.commonHeader.logTime), self.ProfileType, lon, lat, self.PathIndex, self.Offset, self.Distance, self.Value1])
                    layer_curvature.dataProvider().addFeatures( [feature] )
    

#-----------------------------------------------#
#----   ADASISv2PROFILESHORT_ETH            ----#
#-----------------------------------------------#
class ADASISv2PROFILESHORT_ETH(ADASISv2PROFILESHORT):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        self.ADASISinfo = ADASISinfoManager.getADASISinfo_forEth()
        
        
#-----------------------------------------------#
#----   ADASISv2PROFILESHORT_CAN            ----#
#-----------------------------------------------#
class ADASISv2PROFILESHORT_CAN(ADASISv2PROFILESHORT):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        self.ADASISinfo = ADASISinfoManager.getADASISinfo_forCAN()
        
        
#-----------------------------------------------#
#----   ADASISv2PROFILELONG                 ----#
#-----------------------------------------------#
class ADASISv2PROFILELONG(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None, processRelativeParse = True):
        readFunc = self.data.readValue
        readFunc(int,3) #Checksum
        self.Offset = readFunc(int,13)
        self.CyclicCounter = readFunc(int,2)
        self.PathIndex = readFunc(int,6)
        self.ProfileType = readFunc(int,5)
        readFunc(int,1) #Checksum
        self.Retransmission = readFunc(int,1)
        self.Update = readFunc(int,1)
        self.Value = readFunc(int,32)
        self.assertMessageSize()
        
        if processRelativeParse:
            if (self.ProfileType == 1 or self.ProfileType == 2) and self.Offset < 8191 and self.Retransmission == 1:
                self.ADASISinfo.setReceivedPLcount(self.ProfileType, self.PathIndex, self.Offset)
                            
            if self.ProfileType == 1:
                self.ADASISinfo.addLongitudeInfo(self.PathIndex, self.Offset, (self.Value * 0.0000001) - 180.0)
            elif self.ProfileType == 2:
                self.ADASISinfo.addLatitudeInfo(self.PathIndex, self.Offset, (self.Value * 0.0000001) - 90.0)
            elif self.ProfileType == 25 or self.ProfileType == 26:
                #RoadBearingPart = (self.Value & 0xF0000000) >> 24
                latlon = (self.Value & 0x0FFFFFF0) >> 4
                (refLon, refLat) = self.ADASISinfo.getLonLat(self.PathIndex, self.Offset)
                if self.ProfileType == 25:
                    if math.fabs(refLon - latlon) < 1:
                        self.ADASISinfo.addLongitudeInfo(self.PathIndex, self.Offset, (latlon * 360.0 / (0xFFFFFF-2)) - 180.0)
                elif self.ProfileType == 26:
                    if math.fabs(refLat - latlon) < 1:
                        self.ADASISinfo.addLatitudeInfo(self.PathIndex, self.Offset, (latlon * 360.0 / (0xFFFFFF-2)) - 90.0)
                        
            self.ADASISinfo_getLonLat = self.ADASISinfo.getLonLat(self.PathIndex, self.Offset)
            self.ADASISinfo_adjustOffset = self.ADASISinfo.adjustOffset(self.PathIndex, self.Offset)
            
        else:
            self.ADASISinfo_getLonLat = (180, 180)
            self.ADASISinfo_adjustOffset = None

    def printHeader(self, sheet, row, col, _level = 1):
        [_, col, _] = self.commonHeader.printHeader(sheet, row, col)
        
        if self.ADASISinfo_adjustOffset != None:
            sheet.write_row(row, col, [
                'Path Index', 
                'Offset', 
                'Offset(Adj)', 
                'Cyclic Counter', 
                'Profile type', 
                'Retransmission', 
                'Update',  
                'Value',
                'Analyze'], sheet.cellFormats('header'))
            col += 9
        else:
            sheet.write_row(row, col, [
                'Path Index', 
                'Offset', 
                'Cyclic Counter', 
                'Profile type', 
                'Retransmission', 
                'Update',  
                'Value',
                'Analyze'], sheet.cellFormats('header'))
            col += 8
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        
        if self.ADASISinfo_adjustOffset != None:
            printList = [(self.PathIndex),
                        (self.Offset),
                        (self.ADASISinfo_adjustOffset),
                        (self.CyclicCounter),
                        (self.ProfileType),
                        (self.Retransmission),
                        (self.Update),
                        hex(self.Value)]
        else:
            printList = [(self.PathIndex),
                        (self.Offset),
                        (self.CyclicCounter),
                        (self.ProfileType),
                        (self.Retransmission),
                        (self.Update),
                        hex(self.Value)]
        
        if self.ProfileType == 1:
            printList.append((self.Value * 0.0000001) - 180.0)
        elif self.ProfileType == 2:
            printList.append((self.Value * 0.0000001) - 90.0)
        elif self.ProfileType == 25:
            latlon = (self.Value & 0x0FFFFFF0) >> 4
            printList.append((latlon * 360.0 / (0xFFFFFF-2)) - 180.0)
        elif self.ProfileType == 26:
            latlon = (self.Value & 0x0FFFFFF0) >> 4
            printList.append((latlon * 360.0 / (0xFFFFFF-2)) - 90.0)
        else:
            printList.append(self.Value)
                    
        sheet.write_row(row, col, printList)
        
        return  [row+1, 0, []]    
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
    class LayerType(Enum):
        ADASIS_ProfileLong = 33
    
    ProfileLong_symbolDic = {
             2:(QtGui.QColor.fromRgb(000,200,100),'(1,2) MPP LatLon', 2.0),
             8:(QtGui.QColor.fromRgb(100,200,100),'(8) Tollgate', 2.0),
             16:(QtGui.QColor.fromRgb(50,100,250),'(16) Node of leaving/merging point', 2.0),
             17:(QtGui.QColor.fromRgb(50,200,250),'(17) Change point of number of lanes', 2.0),
             18:(QtGui.QColor.fromRgb(150,200,100),'(18) Start of leaving', 2.0),
             19:(QtGui.QColor.fromRgb(100,150,100),'(19) End of leaving', 2.0),
             20:(QtGui.QColor.fromRgb(100,150,150),'(20) Start of merging', 2.0),
             21:(QtGui.QColor.fromRgb(100,150,100),'(21) End of merging', 2.0),
             22:(QtGui.QColor.fromRgb(150,200,100),'(22) Entrance of HOV lane', 2.0),
             23:(QtGui.QColor.fromRgb(200,200,150),'(23) Exit of HOV lane', 2.0),
             24:(QtGui.QColor.fromRgb(100,000,100),'(24) Before Lane to Enter', 2.6),
             26:(QtGui.QColor.fromRgb(000,200,100),'(25,26) Extra HD map linkage LatLon', 2.0),
             27:(QtGui.QColor.fromRgb(150,200,200),'(27) Destination', 2.0),
             28:(QtGui.QColor.fromRgb(150,200,200),'(28) waypoint (with setting)', 2.0),
             29:(QtGui.QColor.fromRgb(150,200,200),'(29) waypoint (without setting)', 2.0),
             30:(QtGui.QColor.fromRgb(000,000,000),'(30) Infra Link ID', 2.0)
             }
    
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.ADASIS_ProfileLong:
            layer = myQgsRendererCategoryLayer(layer, ADASISv2PROFILELONG.ProfileLong_symbolDic)
            return [layer, layerType.value]        
        else:
            return None
    
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if getADASISanalyze() == False:
            return None
        
        newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=category:int&field=Longitude:double&field=Latitude:double&field=PathIndex:int&field=Offset:int&field=Value:uint&index=yes',name,'memory')
        newLayer = self.SetLayerStyle(self.LayerType.ADASIS_ProfileLong, newLayer)
        return [newLayer]
        
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        if getADASISanalyze() == False:
            return
        
        for layerListItem in layerList:
            if layerListItem[1] == ADASISv2PROFILELONG.LayerType.ADASIS_ProfileLong.value:
                newLayer = layerListItem[0]
        
        [lon, lat] = self.ADASISinfo_getLonLat
        
        if checkInvalidLonLat(lon, lat) == True:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(lon, lat), QgsPoint(lon + 0.000005, lat + 0.000005)]))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), self.ProfileType, lon, lat, self.PathIndex, self.Offset, self.Value])
            newLayer.dataProvider().addFeatures( [feature] )
        

#-----------------------------------------------#
#----   ADASISv2PROFILELONG_ETH             ----#
#-----------------------------------------------#
class ADASISv2PROFILELONG_ETH(ADASISv2PROFILELONG):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        self.ADASISinfo = ADASISinfoManager.getADASISinfo_forEth()
        
        
#-----------------------------------------------#
#----   ADASISv2PROFILELONG_CAN             ----#
#-----------------------------------------------#
class ADASISv2PROFILELONG_CAN(ADASISv2PROFILELONG):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        self.ADASISinfo = ADASISinfoManager.getADASISinfo_forCAN()


#-----------------------------------------------#
#----   ADASISv2RouteInfo                   ----#
#-----------------------------------------------#
class ADASISv2RouteInfo(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        readFunc(int,3) #Checksum
        self.Offset = readFunc(int,13)
        self.CyclicCounter = readFunc(int,2)
        self.PathIndex = readFunc(int,6)
        readFunc(int,4) #Reserved
        self.LonLatType = readFunc(int,1)
        readFunc(int,1) #Checksum
        self.Retransmission = readFunc(int,1)
        self.Update = readFunc(int,1)
        self.RoadBearingPart = readFunc(int,4)
        self.LonLat = readFunc(int,24)
        readFunc(int,4) #Reserved
        self.assertMessageSize()
        
        if oldMessage != None:
            if self.LonLatType == 1 and oldMessage.LonLatType == 0:
                self.longitude = oldMessage.LonLat * 360.0 / (0xFFFFFF-2) - 180.0
                self.latitude = self.LonLat * 360.0 / (0xFFFFFF-2) - 90.0
                self.RoadBearing = (oldMessage.RoadBearingPart * 16 + self.RoadBearingPart) * 360.0 / 254
            else:
                self.latitude = oldMessage.latitude
                self.longitude = oldMessage.longitude
                self.RoadBearing = oldMessage.RoadBearing
        else:
            self.latitude = 0
            self.longitude = 0
            self.RoadBearing = 0
            
    def printHeader(self, sheet, row, col, _level = 1):
        [_, col, _] = self.commonHeader.printHeader(sheet, row, col)
        
        sheet.write_row(row, col, [
            'Offset', 
            'Cyclic Counter', 
            'Path Index', 
            'LonLat Type', 
            'Retransmission', 
            'Update',  
            'Road Bearing',
            'LonLat of POSITION point'], sheet.cellFormats('header'))
        col += 8
        
        sheet.write_row(row, col, [
            'RoadBearing', 
            'latitude', 
            'longitude'])
        col += 3
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        
        sheet.write_row(row, col, [
            (self.Offset),
            (self.CyclicCounter),
            (self.PathIndex),
            (self.LonLatType),
            (self.Retransmission),
            (self.Update),
            (self.RoadBearingPart),
            (self.LonLat)])
        col += 8
        
        if self.LonLatType == 1:
            sheet.write_row(row, col, [
            (self.RoadBearing),
            (self.latitude),
            (self.longitude)])
        col += 3
        
        return  [row+1, 0, []]  
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
    class LayerType(Enum):
        RouteInfo_IVIPosition = 8
    
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.RouteInfo_IVIPosition:
            symbollist = layer.renderer().symbols(QgsRenderContext())
            symbol = symbollist[0]
            symbol.setColor(QtGui.QColor.fromRgb(0,200,0))
            symbol.setWidth(1.2)
            layer.beginEditCommand( 'QGIS draw' )
            return [layer, layerType.value]
        
        else:
            return None
    
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if realTimeMode == DrawMode.FullDraw:
            newLayer_iviPos = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&index=yes',name,'memory')
        else:
            newLayer_iviPos = iface_obj.addVectorLayer('LineString?crs=epsg:4612',name,'memory')
        newLayer_iviPos = self.SetLayerStyle(self.LayerType.RouteInfo_IVIPosition, newLayer_iviPos)
        
        return [newLayer_iviPos]
        
    def getLonLat(self):
        return [self.longitude, self.latitude]
    
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        old = self.oldMessage
        for layerListItem in layerList:
            if layerListItem[1] == ADASISv2RouteInfo.LayerType.RouteInfo_IVIPosition.value:
                newLayer_iviPos = layerListItem[0]
        
        if old != None:
            lat = self.latitude
            lon = self.longitude
            if lat < 179 and lon < 179:
                oldLat = old.latitude
                oldLon = old.longitude
                if (lat != oldLat or lon != oldLon) and (((lat-oldLat) ** 2 + (lon-oldLon) ** 2) < 1):
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPolyline(
                        [QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)] ))
                    if realTimeMode == DrawMode.FullDraw:
                        feature.setAttributes([QDateTime(self.commonHeader.logTime), lon, lat])
                    newLayer_iviPos.dataProvider().addFeatures( [feature] )
    
    
#-----------------------------------------------#
#----   ADASISv2RouteInfo_ETH               ----#
#-----------------------------------------------#
class ADASISv2RouteInfo_ETH(ADASISv2RouteInfo):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        
        
#-----------------------------------------------#
#----   ADASISv2RouteInfo_CAN               ----#
#-----------------------------------------------#
class ADASISv2RouteInfo_CAN(ADASISv2RouteInfo):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
    

#-----------------------------------------------#
#----   (CAN) ADAS_ModeDisplay              ----#
#-----------------------------------------------#
class CAN_ADAS_ModeDisplay(Template_Default_Message_WithDraw):
    FieldNameList = [
        ('ADAS_ModeDisplay', 2, int, 1, 0),
        ('ACC_StatusDisplay', 2, int, 1, 0),
        ('NoEntry_ActivationState', 1, int, 1, 0),
        ('NoEntry_AlertDisplay', 1, int, 1, 0),
        ('ACC_FailureDisplay', 2, int, 1, 0),
        ('ACC_TargetDistanceDisplay', 3, int, 1, 0),
        ('ACC_SpeedOverrideDisplay', 1, int, 1, 0),
        ('ACC_DistanceOverrideDisplay', 1, int, 1, 0),
        ('ACC_TargetDistanceAlert', 2, int, 1, 0),
        ('NoEntry_Alert', 1, int, 1, 0),
        ('ACC_DynTargetDistanceDisplay', 8, int, 1, 0),
        ('ACC_SpeedSettingDisplay', 8, int, 1, 0),
        ('ACC_DistanceSettingDisplay', 3, int, 1, 0),
        ('ACC_LCA_TransitionStateDisplay', 3, int, 1, 0),
        ('LCA_LaneDisplay', 2, int, 1, 0),
        ('LCA_ActivationState', 1, int, 1, 0),
        ('LCA_SteeringWheelDisplay', 2, int, 1, 0),
        ('LCA_StatusDisplay', 2, int, 1, 0),
        ('LCA_OverrideDisplay', 1, int, 1, 0),
        ('LCA_FailureDisplay', 2, int, 1, 0),
        ('LCA_SoundAlert', 1, int, 1, 0),
        ('LDP_AlertStatus', 2, int, 1, 0),
        ('LDP_SoundAlert', 1, int, 1, 0),
        ('LDP_LaneDisplay', 2, int, 1, 0),
        ('LDP_StatusDisplay', 2, int, 1, 0),
        ('DriverGuideDisplay', 3, int, 1, 0),
        ('ContextRoad_ActivationState', 2, int, 1, 0),
        ('ContextSpeed_ActivationState', 2, int, 1, 0),
        ('ADL3_DisclaimerAcknowledgement', 1, int, 1, 0)
    ]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        
    @classmethod
    def GetFieldNameList(cls, self = None):
        return cls.FieldNameList
        
    
#-----------------------------------------------#
#----   (CAN) CAN_IVI_A5_SatelliteGPSNumber ----#
#-----------------------------------------------#
class DebugEther(Template_Default_Message_WithDraw):
     # (fieldName, size, readType, resolution, offset, sign, readFromLSB)
    FieldNameList_ver2 = [
        ('Header', 96, bytes, 1, 0),
        ('str_whl_com_lka', 32, float, 1, 0, False, True),
        ('str_whl_com_tja', 32, float, 1, 0, False, True),
        ('V_m_DistToEndNaviPoint', 32, float, 1, 0, False, True),
        ('xdist_in_lat', 32, float, 1, 0, False, True),
        ('ydist_in_lat', 32, float, 1, 0, False, True),
        ('YCR_L', 32, float, 1, 0, False, True),
        ('RHO_L', 32, float, 1, 0, False, True),
        ('PHI_L', 32, float, 1, 0, False, True),
        ('RefDistance', 32, float, 1, 0, False, True),
        ('RefRelSpeed', 32, float, 1, 0, False, True),
        ('FBSpeedCmd', 32, float, 1, 0, False, True),
        ('V_req_mps_RequestedSpeedLim', 32, float, 1, 0, False, True),
        ('V_req_mps2_AccComLim', 32, float, 1, 0, False, True),
        ('V_degps_OFST_YAW_RATE_AD2_for_SENS', 32, float, 1, 0, False, True),
        ('hmi_DistToMergeStart', 32, float, 1, 0, False, True),
        ('hmi_DistToMergeEnd', 32, float, 1, 0, False, True),
        ('hmi_DistToBranchStart', 32, float, 1, 0, False, True),
        ('hmi_DistToBranchEnd', 32, float, 1, 0, False, True),
        ('hmi_DistToTollgateStart', 32, float, 1, 0, False, True),
        ('hmi_DistToTollgateEnd', 32, float, 1, 0, False, True),
        ('Heading_LKA_SEL_LANE', 32, float, 1, 0, False, True),
        ('Position_LKA_SEL_LANE', 32, float, 1, 0, False, True),
        ('Curvature_LKA_SEL_LANE', 32, float, 1, 0, False, True),
        ('Curvature_derivative_LKA_SEL_LANE', 32, float, 1, 0, False, True),
        ('Lane_Width', 32, float, 1, 0, False, True),
        ('Position_SEL_LANE_Offset', 32, float, 1, 0, False, True),
        ('TargetDistance', 32, float, 1, 0, False, True),
        ('TargetSpeed', 32, float, 1, 0, False, True),
        ('TargetRelSpeed', 32, float, 1, 0, False, True),
        ('TargetAccel', 32, float, 1, 0, False, True),
        ('TargetTTC', 32, float, 1, 0, False, True),
        ('DIST_X_SIDE_L', 32, float, 1, 0, False, True),
        ('DIST_Y_SIDE_L', 32, float, 1, 0, False, True),
        ('VEL_X_SIDE_L', 32, float, 1, 0, False, True),
        ('VEL_Y_SIDE_L', 32, float, 1, 0, False, True),
        ('DIST_X_SIDE_R', 32, float, 1, 0, False, True),
        ('DIST_Y_SIDE_R', 32, float, 1, 0, False, True),
        ('VEL_X_SIDE_R', 32, float, 1, 0, False, True),
        ('VEL_Y_SIDE_R', 32, float, 1, 0, False, True),
        ('V_kph_CurrentSpeedLimitHD', 32, float, 1, 0, False, True),
        ('V_kph_NextSpeedLimitHD', 32, float, 1, 0, False, True),
        ('V_m_DistToNextSpeedLimitHD', 32, float, 1, 0, False, True),
        ('V_rad_LclztnYaw_0', 32, float, 1, 0, False, True),
        ('V_rad_LclztnYaw_1', 32, float, 1, 0, False, True),
        ('VSP_COM_NAVI', 32, float, 1, 0, False, True),
        ('V_m_P2P_link_offset', 32, float, 1, 0, False, True),
        ('V_mps2_AccSub', 32, float, 1, 0, False, True),
        ('V_m_YDistanceSelected', 32, float, 1, 0, False, True),
        ('V_s_SetTimeLKATargetDist', 32, float, 1, 0, False, True),
        ('V_rad_SelectedHeadingAngle', 32, float, 1, 0, False, True),
        ('V_1pm_CurvatureSelected', 32, float, 1, 0, False, True),
        ('V_x_HDMap_LKAInfo_C0', 32, float, 1, 0, False, True),
        ('V_x_HDMap_LKAInfo_C1', 32, float, 1, 0, False, True),
        ('V_x_HDMap_LKAInfo_C2', 32, float, 1, 0, False, True),
        ('V_x_HDMap_LKAInfo_C3', 32, float, 1, 0, False, True),
        ('LCH_DIR', 8, int, 1, 0, True),
        ('ADCtrlStat', 8, int, 1, 0, False, True),
        ('ALCState', 8, int, 1, 0, False, True),
        ('HandsOnLevel', 8, int, 1, 0, False, True),
        ('V_req_rad_SteerFrontFF', 32, float, 1, 0, False, True),
        ('LAT_CONTROL_SEL', 8, int, 1, 0, False, True),
        ('V_x_AutoLC_CancelStatus', 8, int, 1, 0, False, True),
        ('HandsOnType', 8, int, 1, 0, False, True),
        ('LKA_Ctrl_Status', 8, int, 1, 0, False, True),
        ('V_m_YDistanceLaneChange', 32, float, 1, 0, False, True),
        ('V_rad_SWAOffsetLowSpeed', 32, float, 1, 0, False, True),
        ('V_m_YDistanceCamLane', 32, float, 1, 0, False, True),
        ('SteerReqType', 8, int, 1, 0, False, True),
        ('NoticeType', 8, int, 1, 0, False, True),
        ('TD_Type', 8, int, 1, 0, False, True),
        ('V_x_InternalACCStatus', 8, int, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_0', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_1', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_2', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_3', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_4', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_5', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_6', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_7', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_0', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_1', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_2', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_3', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_4', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_5', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_6', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_7', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_0', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_1', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_2', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_3', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_4', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_5', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_6', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_11', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_12', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_13', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_14', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_15', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_16', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_17', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_22', 32, float, 1, 0, False, True),
        ('V_m_MapCamPositionDiff_JudgeLane', 32, float, 1, 0, False, True),
        ('V_rad_MapCamAngleDiff_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapCamCosSimilarity_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapCamXcorr_JudgeLane', 32, float, 1, 0, False, True),
        ('FS_EventTbl_0', 32, int, 1, 0, False, True),
        ('FS_EventTbl_1', 32, int, 1, 0, False, True),
        ('FS_EventTbl_2', 32, int, 1, 0, False, True),
        ('FS_EventTbl_3', 32, int, 1, 0, False, True),
        ('FS_EventTbl_4', 32, int, 1, 0, False, True),
        ('FS_EventTbl_5', 32, int, 1, 0, False, True),
        ('FS_EventTbl_6', 32, int, 1, 0, False, True),
        ('FS_EventTbl_7', 32, int, 1, 0, False, True),
        ('FS_EventTbl_8', 32, int, 1, 0, False, True),
        ('FS_EventTbl_9', 32, int, 1, 0, False, True),
        ('FS_EventTbl_10', 32, int, 1, 0, False, True),
        ('FS_EventTbl_11', 32, int, 1, 0, False, True),
        ('FS_EventTbl_12', 32, int, 1, 0, False, True),
        ('FS_EventTbl_13', 32, int, 1, 0, False, True),
        ('FS_EventTbl_14', 32, int, 1, 0, False, True),
        ('FS_EventTbl_15', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_0', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_1', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_2', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_3', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_4', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_5', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_6', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_7', 32, int, 1, 0, False, True),
        ('V_x_Debug_Large', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData123', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData124', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData125', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData126', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData127', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData128', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData129', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData130', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData131', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData132', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData133', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData134', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData135', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData136', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData137', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData138', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData139', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData140', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData141', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData142', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData143', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData144', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData145', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData146', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData147', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData148', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData149', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData150', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData151', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData152', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData153', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData154', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData155', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData156', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData157', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData158', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData159', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData160', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData161', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData162', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData163', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData164', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData165', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData166', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData167', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData168', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData169', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData170', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData171', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData172', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData173', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData174', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData175', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData176', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData177', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData178', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData179', 32, int, 1, 0, False, True),
        ('FS_EventTbl_16', 32, int, 1, 0, False, True),
        ('FS_EventTbl_17', 32, int, 1, 0, False, True),
        ('V_deg_Global_SteeringAngleRequest_ASD_SM_CAN', 32, int, 1, 0, True),
        ('V_x_LCA_SteeringGain_k1_ASD_SM_CAN', 32, int, 1, 0, False, True),
        ('V_x_Global_SteeringAngleOrder_ASD_SM_CAN', 32, int, 1, 0, False, True),
        ('F_x_ForcedSteeringLeft', 32, int, 1, 0, False, True),
        ('F_x_ForcedSteeringRight', 32, int, 1, 0, False, True),
        ('F_x_MapHppPosDif_JudgeLane', 32, int, 1, 0, False, True),
        ('V_m_MapHppPositionDiff_JudgeLane', 32, float, 1, 0, False, True),
        ('V_rad_MapHppAngleDiff_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapHppCosSimilarity_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapHppXcorr_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapValid_JudgeLane', 32, int, 1, 0, False, True),
        ('EstLatMoveRight', 32, float, 1, 0, False, True),
        ('EstLatMoveLeft', 32, float, 1, 0, False, True),
        ('LatPosRight', 32, float, 1, 0, False, True),
        ('LatPosLeft', 32, float, 1, 0, False, True),
        ('EstLatMoveDlyRight', 32, float, 1, 0, False, True),
        ('EstLatMoveDlyLeft', 32, float, 1, 0, False, True),
        ('EstLatMoveModifyRight', 32, float, 1, 0, False, True),
        ('EstLatMoveModifyLeft', 32, float, 1, 0, False, True),
        ('smDebugProtrudeEstimatedRight', 32, int, 1, 0, False, True),
        ('smDebugProtrudeEstimatedLeft', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData203', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData204', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData205', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData206', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData207', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData208', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData209', 32, int, 1, 0, False, True),
        ('V_pct_HDMAPCrossSlopeSel0', 32, float, 1, 0, False, True),
        ('ycr_i_LKA', 32, float, 1, 0, False, True),
        ('V_m_MapHmi_HDMAP_ActiveDistance_0', 32, float, 1, 0, False, True),
        ('V_mps_SaturatedRequestedSpdReq', 32, float, 1, 0, False, True),
        ('V_mps_CurveControlSpeed', 32, float, 1, 0, False, True),
        ('V_m_DistToLocal', 32, float, 1, 0, False, True),
        ('vVSP_TAR_MIN', 32, float, 1, 0, False, True),
        ('V_m_PthPlnrRouteLaneWidthLeft', 32, float, 1, 0, False, True),
        ('V_m_PthPlnrRouteLaneWidthRight', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPNextCrossSlopeSelL', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPNextCrossSlopeSelR', 32, float, 1, 0, False, True),
        ('V_m_PthPlnrRouteLaneWidthSel0', 32, float, 1, 0, False, True),
        ('V_deg_LclztnLatitude_0', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_LclztnLongitude_0', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_LclztnLatitude_1', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_LclztnLongitude_1', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_HDMAP_latitude_0', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_HDMAP_longitude_0', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_x_AutoLC_CancelReason', 32, int, 1, 0, False, True),
        ('Map_pp_status', 32, int, 1, 0, False, True),
        ('V_x_Debug_Middle04Small01', 32, int, 1, 0, False, True),
        ('V_x_ALCInhiFlagArry', 32, int, 1, 0, False, True),
        ('V_x_Route_Additional_Info', 32, int, 1, 0, False, True),
        ('V_x_Debug_LKAReadyTempOFF_Reason', 32, int, 1, 0, False, True),
        ('LchPossible_ListCode', 16, int, 1, 0, False, True),
        ('V_x_Debug_Middle04', 16, int, 1, 0, False, True),
        ('V_m_dist_Nolane_RCar_0', 16, int, 1, 0, False, True),
        ('V_x_P2P_Disable_Reason', 16, int, 1, 0, False, True),
        ('LANE_CHANGE_POSSIBLE_RIGHT', 8, int, 1, 0, False, True),
        ('LANE_CHANGE_POSSIBLE_LEFT', 8, int, 1, 0, False, True),
        ('Type_of_SystemReq', 8, int, 1, 0, False, True),
        ('hmi_BranchType', 8, int, 1, 0, False, True),
        ('hmi_MergeType', 8, int, 1, 0, False, True),
        ('hmi_HD_NumOfLane', 8, int, 1, 0, False, True),
        ('hmi_HD_CurrentLanePos', 8, int, 1, 0, False, True),
        ('LINE_SEL_HOKAN', 8, int, 1, 0, False, True),
        ('SensorSel', 8, int, 1, 0, False, True),
        ('map_valid', 8, int, 1, 0, False, True),
        ('V_x_BranchType', 8, int, 1, 0, False, True),
        ('V_x_AutoLCDirection_HMI', 8, int, 1, 0, False, True),
        ('V_x_AutoLC_Reason', 8, int, 1, 0, False, True),
        ('Confidence', 8, int, 1, 0, False, True),
        ('Confidence_2', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle02Small01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle02Small02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle02Small03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle03Small01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle03Small02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle03Small03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle04Small02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle04Small03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle05', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle05Small01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle05Small02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle05Small03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle06', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle07', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle09', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle12', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle12Small01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle14', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle16', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle17', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle19', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle20', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle21', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle22', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle23', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_r1_20', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_r1_29', 8, int, 1, 0, False, True),
        ('V_x_P2P_continuity_reason', 8, int, 1, 0, False, True),
        ('V_x_HandsOnReq_Lateral', 8, int, 1, 0, False, True),
        ('V_x_TimeGapRange', 8, int, 1, 0, False, True),
        ('V_x_LaneSourceSelect', 8, int, 1, 0, False, True),
        ('V_x_TSR_OSP_SpeedSignalZone1', 8, int, 1, 0, False, True),
        ('V_x_HOD_ModeStatus_Vsi', 8, int, 1, 0, False, True),
        ('V_x_HOD_Error_Vsi', 8, int, 1, 0, False, True),
        ('V_x_TSR_SpdWriteStatus', 8, int, 1, 0, False, True),
        ('V_x_MnSnd1', 8, int, 1, 0, False, True),
        ('V_x_MnSnd2', 8, int, 1, 0, False, True),
        ('V_x_MnSnd3', 8, int, 1, 0, False, True),
        ('V_x_MnSnd4', 8, int, 1, 0, False, True),
        ('V_x_MnSnd5', 8, int, 1, 0, False, True),
        ('V_x_MnSnd1_Invert', 8, int, 1, 0, False, True),
        ('V_x_MnSnd2_Invert', 8, int, 1, 0, False, True),
        ('V_x_MnSnd3_Invert', 8, int, 1, 0, False, True),
        ('V_x_MnSnd4_Invert', 8, int, 1, 0, False, True),
        ('V_x_MnSnd5_Invert', 8, int, 1, 0, False, True),
        ('V_x_EAP_SoundAlertRequest', 8, int, 1, 0, False, True),
        ('V_x_HDMAP_Route_SEL', 8, int, 1, 0, False, True),
        ('V_x_TSRRequestSpeed', 8, int, 1, 0, False, True),
        ('V_x_REQ_type_HDmap', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_0', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_r1_0', 8, int, 1, 0, False, True),
        ('vNAVI_ICC_MAP_MODE', 8, int, 1, 0, False, True),
        ('V_x_Nolane_Type_RCar_0', 8, int, 1, 0, False, True),
        ('V_x_P2P_ControlRegionType', 8, int, 1, 0, False, True),
        ('V_x_Num_LaneChangeReqForLeft', 8, int, 1, 0, False, True),
        ('V_x_Num_LaneChangeReqForRight', 8, int, 1, 0, False, True),
        ('LKA_Permit', 1, bytes, 1, 0, False, True),
        ('LCH_ON', 1, bytes, 1, 0, False, True),
        ('HDMAP_ready_valid2', 1, bytes, 1, 0, False, True),
        ('F_x_MemOn_valid1', 1, bytes, 1, 0, False, True),
        ('STRG_SW_DT04', 1, bytes, 1, 0, False, True),
        ('fSTEER_CTRL0', 1, bytes, 1, 0, False, True),
        ('fSTEER_CTRL2', 1, bytes, 1, 0, False, True),
        ('NAVI_ACC_ACT', 1, bytes, 1, 0, False, True),
        ('Longi_Permit', 1, bytes, 1, 0, False, True),
        ('RETURN_REQUEST_LEFT', 1, bytes, 1, 0, False, True),
        ('PASS_REQUEST_RIGHT', 1, bytes, 1, 0, False, True),
        ('hmi_MergeViewAreaControl', 1, bytes, 1, 0, False, True),
        ('flg_SIDEOBJ_L', 1, bytes, 1, 0, False, True),
        ('flg_SIDEOBJ_R', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAP_CntrlPointValid_0', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAP_CntrlPointValid_1', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAPRawValidControl', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAPRawValidShape', 1, bytes, 1, 0, False, True),
        ('F_x_TSR_OnHDMap', 1, bytes, 1, 0, False, True),
        ('F_x_DriveHighwayPredACCNavi', 1, bytes, 1, 0, False, True),
        ('F_x_DriveHighwayNavi', 1, bytes, 1, 0, False, True),
        ('F_x_DriveHighwayTSRNavi', 1, bytes, 1, 0, False, True),
        ('F_x_MapCamPosDif_JudgeLane', 1, bytes, 1, 0, False, True),
        ('F_x_P2P_Control_Region', 1, bytes, 1, 0, False, True),
        ('V_x_Nolane_Type_RCar_1', 8, int, 1, 0, False, True),
        ('V_m_dist_Nolane_RCar_1', 16, int, 1, 0, False, True),
        ('V_m_DistToToll', 32, float, 1, 0, False, True),
        ('V_x_LC_possible_route_0', 16, int, 1, 0, False, True),
        ('V_x_LC_possible_route_1', 16, int, 1, 0, False, True),
        ('V_pm_PthplnrDiagPathCurrentCurvature_0', 32, float, 1, 0, False, True),
        ('V_1pm_CurvaturePredSelected', 32, float, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_20', 8, int, 1, 0, False, True),
        ('F_x_LinkPointIntersection', 1, bytes, 1, 0, False, True),
        ('F_x_LC_req_Driver_L', 1, bytes, 1, 0, False, True),
        ('F_x_LC_req_Driver_R', 1, bytes, 1, 0, False, True),
        ('F_x_LC_req_P2P_L', 1, bytes, 1, 0, False, True),
        ('F_x_LC_req_P2P_R', 1, bytes, 1, 0, False, True),
        ('fIVIRouteCurveSel', 1, bytes, 1, 0, False, True),
        ('f_drive_Min_dist_fro_LchOn', 1, bytes, 1, 0, False, True),
        ('F_x_NoLaneIgnoreLeft', 1, bytes, 1, 0, False, True),
        ('V_x_OvertakeProhibit_0', 8, int, 1, 0, False, True),
        ('vCURV_NO', 8, int, 1, 0, False, True),
        ('V_mps_CaspExitTargetSpeed', 32, float, 1, 0, False, True),
        ('vACC_TAR_MIN', 32, float, 1, 0, False, True),
        ('vCURV_NO_0', 16, int, 1, 0, True),
        ('V_x_MapHmi_NumOfBranchLane_0', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_NumOfBranchLane_1', 8, int, 1, 0, False, True),
        ('V_pct_HDMAPCrossSlopeSel1', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPCrossSlopeSel2', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPCrossSlopeSel3', 32, float, 1, 0, False, True),
        ('V_m_drive_dist_from_reset', 32, float, 1, 0, False, True),
        ('V_x_LCStateTemporalCounter', 16, int, 1, 0, False, True),
        ('V_m_Dist_to_Branch_togo', 16, int, 1, 0, False, True),
        ('V_x_Debug_LKAReadyCondition', 16, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_27', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_r1_27', 8, int, 1, 0, False, True),
        ('V_m_DistToJCT', 32, float, 1, 0, False, True),
        ('V_pm_PthplnrDiagPathCurrentCurvature_1', 32, float, 1, 0, False, True),
        ('V_pm_PthplnrDiagPathCurrentCurvature_2', 32, float, 1, 0, False, True),
        ('V_pm_PthplnrDiagPathCurrentCurvature_3', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_0', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_1', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_2', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_3', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_4', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_5', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_6', 32, float, 1, 0, False, True),
        ('F_x_NoLaneIgnoreRight', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAP_CntrlPointValid_r1_0', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAP_CntrlPointValid_r1_1', 1, bytes, 1, 0, False, True),
        ('F_x_GotoExitLaneToLocal', 1, bytes, 1, 0, False, True),
        ('F_x_ConstructionArea', 1, bytes, 1, 0, False, True),
        ('Status_1120byte_bit5', 1, bytes, 1, 0, False, True),
        ('Status_1120byte_bit6', 1, bytes, 1, 0, False, True),
        ('Status_1120byte_bit7', 1, bytes, 1, 0, False, True),
        ('V_x_MapHmi_TypeEndMerge_SEL', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_Reliability_SEL_0', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_Reliability_SEL_1', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_Reliability2nd_SEL_0', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_Reliability2nd_SEL_1', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_IncLaneType', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_DecLaneType', 8, int, 1, 0, False, True),
        ('V_m_MapHmi_Dist2NextReliability_0', 32, float, 1, 0, False, True),
        ('V_m_MapHmi_Dist2NextReliability_1', 32, float, 1, 0, False, True),
        ('V_m_MapHmi_DistToIncLane', 32, float, 1, 0, False, True),
        ('V_m_MapHmi_DistToDecLane', 32, float, 1, 0, False, True),
        ('vACC_COM_LMT', 32, float, 1, 0, False, True),
        ('V_m_CaspCurveRadiusArray_0', 16, int, 1, 0, True),
        ('Status_1150byte', 8, int, 1, 0, False, True),
        ('Status_1151byte', 8, int, 1, 0, False, True),
        ('ADAS_MonitoringData289', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData290', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData291', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData292', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData293', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData294', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData295', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData296', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData297', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData298', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData299', 32, int, 1, 0, False, True),
        ('total_malloc_calls', 64, int, 1, 0, False, True),
        ('total_free_calls', 64, int, 1, 0, False, True),
        ('total_malloc_user_bytes', 64, int, 1, 0, False, True),
        ('total_malloc_chunk_bytes', 64, int, 1, 0, False, True),
        ('total_free_chunk_bytes', 64, int, 1, 0, False, True),
        ('total_malloc_searches', 64, int, 1, 0, False, True),
        ('malloc_chunk_bytes', 64, int, 1, 0, False, True),
        ('malloc_chunks', 64, int, 1, 0, False, True),
        ('free_chunks', 64, int, 1, 0, False, True),
        ('malloc_peak_chunk_bytes', 64, int, 1, 0, False, True),
        ('malloc_peak_chunks', 64, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_PROFILE_CONTROL', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_PATH_CONTROL', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_POSITION', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_POSITION_IVI', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_INTERSECTION', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_PROFILE', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_GLOBAL_DATA', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_DEFAULT', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_CAR_POSITION', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_SENSOR_DATA', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_SENSOR_CALIBRATION', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_GNSS_DATA', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_ABSOLUTE_POSITION', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_IVI_DATA_STATUS', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_MAPLINKAGE_STATUS', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_ERROR_STATUS', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_DEFAULT_REALTIME', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_RECOMMENDED_LANE', 32, int, 1, 0, False, True),
        ('counter_of_Parser_ETHER_MSGID_DEFAULT_RECOM', 32, int, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_OBJECT_LIST_63_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_OBJECT_LIST_ACC_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_OBJECT_LIST_AEB_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_AVM_OBJECT_LIST_00TO05_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_AVM_OBJECT_LIST_06TO11_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_AVM_OBJECT_LIST_12TO17_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_AVM_OBJECT_LIST_18TO23_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_AVM_OBJECT_LIST_24TO29_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_OBJECT_LIST_07TO13_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_OBJECT_LIST_14TO20_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_OBJECT_LIST_21TO27_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_OBJECT_LIST_28TO34_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_OBJECT_LIST_35TO41_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_OBJECT_LIST_42TO48_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_OBJECT_LIST_49TO55_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_OBJECT_LIST_56TO62_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_LOCATOR_SENSOR_INFORMATION_MAP_TO_AD_4_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_FREESPACE_LIST_PART1_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_FREESPACE_LIST_PART2_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_FREESPACE_LIST_PART3_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_INFRASTRUCTURE_LIST_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_MONITORINGINFO_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_ELKA_OBJECT_LIST_PRESELECTEDOBJECTS_DATA_I', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RADAR_OBJECT_LIST_00TO06_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_AVM_ALIGNMENT_LIST_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_AVM_STATEINFOLIST_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_AVM_LANEINFRAINFO_LIST_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_SYSTEM_COMMON_MAP_TO_AD_1_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_SYSTEM_COMMON_MAP_TO_AD_2_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_LOCATOR_SENSOR_INFORMATION_MAP_TO_AD_1_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_LOCATOR_SENSOR_INFORMATION_MAP_TO_AD_2_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_LOCATOR_SENSOR_INFORMATION_MAP_TO_AD_3_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_MAP_INFORMATION_MAP_TO_AD_2', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_MAP_INFORMATION_MAP_TO_AD_4', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_MAP_INFORMATION_MAP_TO_AD_5', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_MAP_INFORMATION_MAP_TO_AD_6', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_MAP_INFORMATION_MAP_TO_AD_7', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_MAP_INFORMATION_MAP_TO_AD_8', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_RESPONSE_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_ERROR_ALEART_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_CAM_OBJECT_LIST_10TO14_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_CAM_OBJECT_LIST_15TO19_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_MAP_INFORMATION_MAP_TO_AD_3', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_MAP_INFORMATION_MAP_TO_AD_9', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_MAP_INFORMATION_MAP_TO_AD_10', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_MAP_INFORMATION_MAP_TO_AD_16', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_ALIGMENT_RESPONSE_MAP_TO_AD_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_MAP_INFORMATION_MAP_TO_AD_1', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_CAM_AD2_EXTENDED_LIST_PART3_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_CAM_AD2_EXTENDED_MAPMATCHEDTSR_LIST_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_CAM_FREESPACE_LIST_PART1_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_CAM_FREESPACE_LIST_PART2_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_CAM_INFRASTRUCTURE_LIST_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_CAM_MONITORINGINFO_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_CAM_OBJECT_LIST_00TO04_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_CAM_OBJECT_LIST_05TO09_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_AVM_OBJECT_LIST_30TO35_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_AVM_OBJECT_LIST_36TO41_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_AVM_OBJECT_LIST_42TO47_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_AVM_OBJECT_LIST_48TO53_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_AVM_OBJECT_LIST_54TO55_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_AVM_SYSTEMINFO_LIST_PART1_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_CAM_AD2_EXTENDED_LIST_PART1_DATA_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_ETH_CAM_AD2_EXTENDED_LIST_PART2_DATA_ID', 1, bytes, 1, 0, False, True),
        ('Status_1368byte', 8, int, 1, 0, False, True),
        ('Status_1369byte', 8, int, 1, 0, False, True),
        ('Status_1370byte', 8, int, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_SPI_DATA_SIDE_RADAR_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_SPI_DATA_VEHICLE_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_SPI_DATA_NAVI_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_SPI_DATA_ADASIS_ID', 1, bytes, 1, 0, False, True),
        ('EN_MID_DATALOST_INFO_SPI_DATA_SEND_VIN_ID', 1, bytes, 1, 0, False, True),
        ('Status_1371byte_bit5', 1, bytes, 1, 0, False, True),
        ('Status_1371byte_bit6', 1, bytes, 1, 0, False, True),
        ('Status_1371byte_bit7', 1, bytes, 1, 0, False, True),
        ('RC_getLaneLinkID_RouteType_IVI', 1, bytes, 1, 0, False, True),
        ('RC_getLaneLinkID_RouteType_MPU', 1, bytes, 1, 0, False, True),
        ('RC_getLaneLinkID_RouteType_AD', 1, bytes, 1, 0, False, True),
        ('RC_getLaneLinkInfo_RouteType_IVI', 1, bytes, 1, 0, False, True),
        ('RC_getLaneLinkInfo_RouteType_MPU', 1, bytes, 1, 0, False, True),
        ('RC_getLaneLinkInfo_RouteType_AD', 1, bytes, 1, 0, False, True),
        ('Status_1372byte_bit6', 1, bytes, 1, 0, False, True),
        ('Status_1372byte_bit7', 1, bytes, 1, 0, False, True),
        ('RC_getLaneInfo_DType_1000_RouteType_IVI', 1, bytes, 1, 0, False, True),
        ('RC_getLaneInfo_DType_1000_RouteType_MPU', 1, bytes, 1, 0, False, True),
        ('RC_getLaneInfo_DType_1000_RouteType_AD', 1, bytes, 1, 0, False, True),
        ('RC_getLaneInfo_DType_2000_RouteType_IVI', 1, bytes, 1, 0, False, True),
        ('RC_getLaneInfo_DType_2000_RouteType_MPU', 1, bytes, 1, 0, False, True),
        ('RC_getLaneInfo_DType_2000_RouteType_AD', 1, bytes, 1, 0, False, True),
        ('Status_1373byte_bit6', 1, bytes, 1, 0, False, True),
        ('Status_1373byte_bit7', 1, bytes, 1, 0, False, True),
        ('RC_radiusSearch_AreaType_MPU', 1, bytes, 1, 0, False, True),
        ('RC_radiusSearch_AreaType_AD', 1, bytes, 1, 0, False, True),
        ('RC_checkTollgateArea_RouteType_IVI', 1, bytes, 1, 0, False, True),
        ('RC_checkTollgateArea_RouteType_MPU', 1, bytes, 1, 0, False, True),
        ('RC_checkTollgateArea_RouteType_AD', 1, bytes, 1, 0, False, True),
        ('Status_1374byte_bit5', 1, bytes, 1, 0, False, True),
        ('Status_1374byte_bit6', 1, bytes, 1, 0, False, True),
        ('Status_1374byte_bit7', 1, bytes, 1, 0, False, True),
        ('RC_getSensorData', 1, bytes, 1, 0, False, True),
        ('RC_getGPS', 1, bytes, 1, 0, False, True),
        ('RC_getCarPosition_100ms', 1, bytes, 1, 0, False, True),
        ('RC_getMpuErrorStatus_100ms', 1, bytes, 1, 0, False, True),
        ('RC_getIVIDataRecievingStatus', 1, bytes, 1, 0, False, True),
        ('RC_getMapLinkageStatus', 1, bytes, 1, 0, False, True),
        ('RC_getCarPosition_500ms', 1, bytes, 1, 0, False, True),
        ('RC_getMpuErrorStatus_500ms', 1, bytes, 1, 0, False, True),
        ('VehStatus_Out_ver', 32, int, 1, 0, False, True),
        ('AURIXver', 32, int, 1, 0, False, True),
        ('RCARver', 32, int, 1, 0, False, True),
        ]
    
    FieldNameList_ver3_ver4 = [
        ('Header', 96, bytes, 1, 0),
        ('str_whl_com_lka', 32, float, 1, 0, False, True),
        ('V_m_LKATargetXdist', 32, float, 1, 0, False, True),
        ('V_m_DistToEndNaviPoint', 32, float, 1, 0, False, True),
        ('FS_FailsafeTbl_8', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_9', 32, int, 1, 0, False, True),
        ('YCR_L', 32, float, 1, 0, False, True),
        ('RHO_L', 32, float, 1, 0, False, True),
        ('PHI_L', 32, float, 1, 0, False, True),
        ('RefDistance', 32, float, 1, 0, False, True),
        ('RefRelSpeed', 32, float, 1, 0, False, True),
        ('FBSpeedCmd', 32, float, 1, 0, False, True),
        ('V_req_mps_RequestedSpeedLim', 32, float, 1, 0, False, True),
        ('V_req_mps2_AccComLim', 32, float, 1, 0, False, True),
        ('V_degps_OFST_YAW_RATE_AD2_for_SENS', 32, float, 1, 0, False, True),
        ('hmi_DistToMergeStart', 32, float, 1, 0, False, True),
        ('hmi_DistToMergeEnd', 32, float, 1, 0, False, True),
        ('hmi_DistToBranchStart', 32, float, 1, 0, False, True),
        ('hmi_DistToBranchEnd', 32, float, 1, 0, False, True),
        ('hmi_DistToTollgateStart', 32, float, 1, 0, False, True),
        ('hmi_DistToTollgateEnd', 32, float, 1, 0, False, True),
        ('Heading_LKA_SEL_LANE', 32, float, 1, 0, False, True),
        ('Position_LKA_SEL_LANE', 32, float, 1, 0, False, True),
        ('Curvature_LKA_SEL_LANE', 32, float, 1, 0, False, True),
        ('Curvature_derivative_LKA_SEL_LANE', 32, float, 1, 0, False, True),
        ('Lane_Width', 32, float, 1, 0, False, True),
        ('Position_SEL_LANE_Offset', 32, float, 1, 0, False, True),
        ('TargetDistance', 32, float, 1, 0, False, True),
        ('TargetSpeed', 32, float, 1, 0, False, True),
        ('TargetRelSpeed', 32, float, 1, 0, False, True),
        ('TargetAccel', 32, float, 1, 0, False, True),
        ('TargetTTC', 32, float, 1, 0, False, True),
        ('DIST_X_SIDE_L', 32, float, 1, 0, False, True),
        ('DIST_Y_SIDE_L', 32, float, 1, 0, False, True),
        ('VEL_X_SIDE_L', 32, float, 1, 0, False, True),
        ('VEL_Y_SIDE_L', 32, float, 1, 0, False, True),
        ('DIST_X_SIDE_R', 32, float, 1, 0, False, True),
        ('DIST_Y_SIDE_R', 32, float, 1, 0, False, True),
        ('VEL_X_SIDE_R', 32, float, 1, 0, False, True),
        ('VEL_Y_SIDE_R', 32, float, 1, 0, False, True),
        ('V_kph_CurrentSpeedLimitHD', 32, float, 1, 0, False, True),
        ('V_kph_NextSpeedLimitHD', 32, float, 1, 0, False, True),
        ('V_m_DistToNextSpeedLimitHD', 32, float, 1, 0, False, True),
        ('V_rad_LclztnYaw_0', 32, float, 1, 0, False, True),
        ('V_rad_LclztnYaw_1', 32, float, 1, 0, False, True),
        ('VSP_COM_NAVI', 32, float, 1, 0, False, True),
        ('FS_EventTbl_18', 32, int, 1, 0, False, True),
        ('V_mps2_AccSub', 32, float, 1, 0, False, True),
        ('V_m_YDistanceSelected', 32, float, 1, 0, False, True),
        ('V_s_SetTimeLKATargetDist', 32, float, 1, 0, False, True),
        ('V_rad_SelectedHeadingAngle', 32, float, 1, 0, False, True),
        ('V_1pm_CurvatureSelected', 32, float, 1, 0, False, True),
        ('V_x_HDMap_LKAInfo_C0', 32, float, 1, 0, False, True),
        ('V_x_HDMap_LKAInfo_C1', 32, float, 1, 0, False, True),
        ('V_x_HDMap_LKAInfo_C2', 32, float, 1, 0, False, True),
        ('V_x_HDMap_LKAInfo_C3', 32, float, 1, 0, False, True),
        ('LCH_DIR', 8, int, 1, 0, True),
        ('ADCtrlStat', 8, int, 1, 0, False, True),
        ('ALCState', 8, int, 1, 0, False, True),
        ('HandsOnLevel', 8, int, 1, 0, False, True),
        ('V_req_rad_SteerFrontFF', 32, float, 1, 0, False, True),
        ('LAT_CONTROL_SEL', 8, int, 1, 0, False, True),
        ('V_x_AutoLC_CancelStatus', 8, int, 1, 0, False, True),
        ('HandsOnType', 8, int, 1, 0, False, True),
        ('LKA_Ctrl_Status', 8, int, 1, 0, False, True),
        ('V_m_YDistanceLaneChange', 32, float, 1, 0, False, True),
        ('V_rad_SWAOffsetLowSpeed', 32, float, 1, 0, False, True),
        ('V_m_YDistanceCamLane', 32, float, 1, 0, False, True),
        ('SteerReqType', 8, int, 1, 0, False, True),
        ('NoticeType', 8, int, 1, 0, False, True),
        ('TD_Type', 8, int, 1, 0, False, True),
        ('V_x_InternalACCStatus', 8, int, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_0', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_1', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_2', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_3', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_4', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_5', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_6', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_7', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_0', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_1', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_2', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_3', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_4', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_5', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_6', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_7', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_0', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_1', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_2', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_3', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_4', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_5', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_6', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_11', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_12', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_13', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_14', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_15', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_16', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_17', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_22', 32, float, 1, 0, False, True),
        ('V_m_MapCamPositionDiff_JudgeLane', 32, float, 1, 0, False, True),
        ('V_rad_MapCamAngleDiff_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapCamCosSimilarity_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapCamXcorr_JudgeLane', 32, float, 1, 0, False, True),
        ('FS_EventTbl_0', 32, int, 1, 0, False, True),
        ('FS_EventTbl_1', 32, int, 1, 0, False, True),
        ('FS_EventTbl_2', 32, int, 1, 0, False, True),
        ('FS_EventTbl_3', 32, int, 1, 0, False, True),
        ('FS_EventTbl_4', 32, int, 1, 0, False, True),
        ('FS_EventTbl_5', 32, int, 1, 0, False, True),
        ('FS_EventTbl_6', 32, int, 1, 0, False, True),
        ('FS_EventTbl_7', 32, int, 1, 0, False, True),
        ('FS_EventTbl_8', 32, int, 1, 0, False, True),
        ('FS_EventTbl_9', 32, int, 1, 0, False, True),
        ('FS_EventTbl_10', 32, int, 1, 0, False, True),
        ('FS_EventTbl_11', 32, int, 1, 0, False, True),
        ('FS_EventTbl_12', 32, int, 1, 0, False, True),
        ('FS_EventTbl_13', 32, int, 1, 0, False, True),
        ('FS_EventTbl_14', 32, int, 1, 0, False, True),
        ('FS_EventTbl_15', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_0', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_1', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_2', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_3', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_4', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_5', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_6', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_7', 32, int, 1, 0, False, True),
        ('V_x_Debug_Large', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData123', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData124', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData125', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData126', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData127', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData128', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData129', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData130', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData131', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData132', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData133', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData134', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData135', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData136', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData137', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData138', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData139', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData140', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData141', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData142', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData143', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData144', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData145', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData146', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData147', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData148', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData149', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData150', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData151', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData152', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData153', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData154', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData155', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData156', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData157', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData158', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData159', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData160', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData161', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData162', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData163', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData164', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData165', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData166', 32, int, 1, 0, False, True),
        ('smDebugMapCamCorrected_ThPosi', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_ThNega', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_0', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_1', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_2', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_3', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_4', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_5', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_6', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_ThPosi', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_ThNega', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_0', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_1', 32, float, 1, 0, False, True),
        ('FS_EventTbl_16', 32, int, 1, 0, False, True),
        ('FS_EventTbl_17', 32, int, 1, 0, False, True),
        ('V_deg_Global_SteeringAngleRequest_ASD_SM_CAN', 32, int, 1, 0, True),
        ('smDebugMapCamRaw_diff_2', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_3', 32, float, 1, 0, False, True),
        ('F_x_ForcedSteeringLeft', 32, int, 1, 0, False, True),
        ('F_x_ForcedSteeringRight', 32, int, 1, 0, False, True),
        ('F_x_MapHppPosDif_JudgeLane', 32, int, 1, 0, False, True),
        ('V_m_MapHppPositionDiff_JudgeLane', 32, float, 1, 0, False, True),
        ('V_rad_MapHppAngleDiff_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapHppCosSimilarity_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapHppXcorr_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapValid_JudgeLane', 32, int, 1, 0, False, True),
        ('EstLatMoveRight', 32, float, 1, 0, False, True),
        ('EstLatMoveLeft', 32, float, 1, 0, False, True),
        ('LatPosRight', 32, float, 1, 0, False, True),
        ('LatPosLeft', 32, float, 1, 0, False, True),
        ('EstLatMoveDlyRight', 32, float, 1, 0, False, True),
        ('EstLatMoveDlyLeft', 32, float, 1, 0, False, True),
        ('EstLatMoveModifyRight', 32, float, 1, 0, False, True),
        ('EstLatMoveModifyLeft', 32, float, 1, 0, False, True),
        ('smDebugProtrudeEstimatedRight', 32, int, 1, 0, False, True),
        ('smDebugProtrudeEstimatedLeft', 32, int, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_4', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_5', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_6', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_ThPosi', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_ThNega', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_0', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_1', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPCrossSlopeSel0', 32, float, 1, 0, False, True),
        ('ycr_i_LKA', 32, float, 1, 0, False, True),
        ('V_m_MapHmi_HDMAP_ActiveDistance_0', 32, float, 1, 0, False, True),
        ('V_mps_SaturatedRequestedSpdReq', 32, float, 1, 0, False, True),
        ('V_mps_CurveControlSpeed', 32, float, 1, 0, False, True),
        ('V_m_DistToLocal', 32, float, 1, 0, False, True),
        ('vVSP_TAR_MIN', 32, float, 1, 0, False, True),
        ('V_m_PthPlnrRouteLaneWidthLeft', 32, float, 1, 0, False, True),
        ('V_m_PthPlnrRouteLaneWidthRight', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPNextCrossSlopeSelL', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPNextCrossSlopeSelR', 32, float, 1, 0, False, True),
        ('V_m_PthPlnrRouteLaneWidthSel0', 32, float, 1, 0, False, True),
        ('V_deg_LclztnLatitude_0', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_LclztnLongitude_0', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_LclztnLatitude_1', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_LclztnLongitude_1', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_HDMAP_latitude_0', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_HDMAP_longitude_0', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_x_AutoLC_CancelReason', 32, int, 1, 0, False, True),
        ('Map_pp_status', 32, int, 1, 0, False, True),
        ('V_x_Debug_Middle04Small01', 32, int, 1, 0, False, True),
        ('V_x_ALCInhiFlagArry', 32, int, 1, 0, False, True),
        ('V_x_Route_Additional_Info', 32, int, 1, 0, False, True),
        ('V_x_Debug_LKAReadyTempOFF_Reason', 32, int, 1, 0, False, True),
        ('LchPossible_ListCode', 16, int, 1, 0, False, True),
        ('V_x_Debug_Middle04', 16, int, 1, 0, False, True),
        ('V_m_dist_Nolane_RCar_0', 16, int, 1, 0, False, True),
        ('V_x_P2P_Disable_Reason', 16, int, 1, 0, False, True),
        ('LANE_CHANGE_POSSIBLE_RIGHT', 8, int, 1, 0, False, True),
        ('LANE_CHANGE_POSSIBLE_LEFT', 8, int, 1, 0, False, True),
        ('Type_of_SystemReq', 8, int, 1, 0, False, True),
        ('hmi_BranchType', 8, int, 1, 0, False, True),
        ('hmi_MergeType', 8, int, 1, 0, False, True),
        ('hmi_HD_NumOfLane', 8, int, 1, 0, False, True),
        ('hmi_HD_CurrentLanePos', 8, int, 1, 0, False, True),
        ('LINE_SEL_HOKAN', 8, int, 1, 0, False, True),
        ('SensorSel', 8, int, 1, 0, False, True),
        ('map_valid', 8, int, 1, 0, False, True),
        ('V_x_BranchType', 8, int, 1, 0, False, True),
        ('V_x_AutoLCDirection_HMI', 8, int, 1, 0, False, True),
        ('V_x_AutoLC_Reason', 8, int, 1, 0, False, True),
        ('Confidence', 8, int, 1, 0, False, True),
        ('Confidence_2', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle02Small01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle02Small02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle02Small03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle03Small01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle03Small02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle03Small03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle04Small02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle04Small03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle05', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle05Small01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle05Small02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle05Small03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle06', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle07', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle09', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle12', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle12Small01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle14', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle16', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle17', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle19', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle20', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle21', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle22', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle23', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_r1_20', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_r1_29', 8, int, 1, 0, False, True),
        ('V_x_P2P_continuity_reason', 8, int, 1, 0, False, True),
        ('V_x_HandsOnReq_Lateral', 8, int, 1, 0, False, True),
        ('V_x_TimeGapRange', 8, int, 1, 0, False, True),
        ('V_x_LaneSourceSelect', 8, int, 1, 0, False, True),
        ('V_x_TSR_OSP_SpeedSignalZone1', 8, int, 1, 0, False, True),
        ('V_x_HOD_ModeStatus_Vsi', 8, int, 1, 0, False, True),
        ('V_x_HOD_Error_Vsi', 8, int, 1, 0, False, True),
        ('V_x_TSR_SpdWriteStatus', 8, int, 1, 0, False, True),
        ('V_x_MnSnd1', 8, int, 1, 0, False, True),
        ('V_x_MnSnd2', 8, int, 1, 0, False, True),
        ('V_x_MnSnd3', 8, int, 1, 0, False, True),
        ('V_x_MnSnd4', 8, int, 1, 0, False, True),
        ('V_x_MnSnd5', 8, int, 1, 0, False, True),
        ('V_x_CurrentSpeedLimit_TSR', 8, int, 1, 0, False, True),
        ('V_x_NRD_Status', 8, int, 1, 0, False, True),
        ('V_x_ApprovalCancelReason', 8, int, 1, 0, False, True),
        ('Status_1001byte', 8, int, 1, 0, False, True),
        ('Status_1002byte', 8, int, 1, 0, False, True),
        ('V_x_EAP_SoundAlertRequest', 8, int, 1, 0, False, True),
        ('V_x_HDMAP_Route_SEL', 8, int, 1, 0, False, True),
        ('V_x_TSRRequestSpeed', 8, int, 1, 0, False, True),
        ('V_x_REQ_type_HDmap', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_0', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_r1_0', 8, int, 1, 0, False, True),
        ('vNAVI_ICC_MAP_MODE', 8, int, 1, 0, False, True),
        ('V_x_Nolane_Type_RCar_0', 8, int, 1, 0, False, True),
        ('V_x_P2P_ControlRegionType', 8, int, 1, 0, False, True),
        ('V_x_Num_LaneChangeReqForLeft', 8, int, 1, 0, False, True),
        ('V_x_Num_LaneChangeReqForRight', 8, int, 1, 0, False, True),
        ('LKA_Permit', 1, bytes, 1, 0, False, True),
        ('LCH_ON', 1, bytes, 1, 0, False, True),
        ('HDMAP_ready_valid2', 1, bytes, 1, 0, False, True),
        ('F_x_MemOn_valid1', 1, bytes, 1, 0, False, True),
        ('STRG_SW_DT04', 1, bytes, 1, 0, False, True),
        ('fSTEER_CTRL0', 1, bytes, 1, 0, False, True),
        ('fSTEER_CTRL2', 1, bytes, 1, 0, False, True),
        ('NAVI_ACC_ACT', 1, bytes, 1, 0, False, True),
        ('Longi_Permit', 1, bytes, 1, 0, False, True),
        ('RETURN_REQUEST_LEFT', 1, bytes, 1, 0, False, True),
        ('PASS_REQUEST_RIGHT', 1, bytes, 1, 0, False, True),
        ('hmi_MergeViewAreaControl', 1, bytes, 1, 0, False, True),
        ('flg_SIDEOBJ_L', 1, bytes, 1, 0, False, True),
        ('flg_SIDEOBJ_R', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAP_CntrlPointValid_0', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAP_CntrlPointValid_1', 1, bytes, 1, 0, False, True),
        ('F_x_NStateReroute', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAPRawValidShape', 1, bytes, 1, 0, False, True),
        ('F_x_TSR_OnHDMap', 1, bytes, 1, 0, False, True),
        ('F_x_DriveHighwayPredACCNavi', 1, bytes, 1, 0, False, True),
        ('F_x_DriveHighwayNavi', 1, bytes, 1, 0, False, True),
        ('F_x_DriveHighwayTSRNavi', 1, bytes, 1, 0, False, True),
        ('F_x_MapCamPosDif_JudgeLane', 1, bytes, 1, 0, False, True),
        ('F_x_P2P_Control_Region', 1, bytes, 1, 0, False, True),
        ('V_x_Nolane_Type_RCar_1', 8, int, 1, 0, False, True),
        ('V_m_dist_Nolane_RCar_1', 16, int, 1, 0, False, True),
        ('V_m_DistToToll', 32, float, 1, 0, False, True),
        ('V_x_LC_possible_route_0', 16, int, 1, 0, False, True),
        ('V_x_LC_possible_route_1', 16, int, 1, 0, False, True),
        ('V_pm_PthplnrDiagPathCurrentCurvature_0', 32, float, 1, 0, False, True),
        ('V_1pm_CurvaturePredSelected', 32, float, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_20', 8, int, 1, 0, False, True),
        ('F_x_LinkPointIntersection', 1, bytes, 1, 0, False, True),
        ('F_x_LC_req_Driver_L', 1, bytes, 1, 0, False, True),
        ('F_x_LC_req_Driver_R', 1, bytes, 1, 0, False, True),
        ('F_x_LC_req_P2P_L', 1, bytes, 1, 0, False, True),
        ('F_x_LC_req_P2P_R', 1, bytes, 1, 0, False, True),
        ('fIVIRouteCurveSel', 1, bytes, 1, 0, False, True),
        ('f_drive_Min_dist_fro_LchOn', 1, bytes, 1, 0, False, True),
        ('F_x_NoLaneIgnoreLeft', 1, bytes, 1, 0, False, True),
        ('V_x_OvertakeProhibit_0', 8, int, 1, 0, False, True),
        ('vCURV_NO', 8, int, 1, 0, False, True),
        ('V_mps_CaspExitTargetSpeed', 32, float, 1, 0, False, True),
        ('vACC_TAR_MIN', 32, float, 1, 0, False, True),
        ('vCURV_NO_0', 16, int, 1, 0, True),
        ('V_x_MapHmi_NumOfBranchLane_0', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_NumOfBranchLane_1', 8, int, 1, 0, False, True),
        ('V_pct_HDMAPCrossSlopeSel1', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPCrossSlopeSel2', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPCrossSlopeSel3', 32, float, 1, 0, False, True),
        ('V_m_ycr_pre_l', 32, float, 1, 0, False, True),
        ('V_x_LCStateTemporalCounter', 16, int, 1, 0, False, True),
        ('V_m_Dist_to_Branch_togo', 16, int, 1, 0, False, True),
        ('V_x_Debug_LKAReadyCondition', 16, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_27', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_r1_27', 8, int, 1, 0, False, True),
        ('V_m_DistToJCT', 32, float, 1, 0, False, True),
        ('V_pm_PthplnrDiagPathCurrentCurvature_1', 32, float, 1, 0, False, True),
        ('V_pm_PthplnrDiagPathCurrentCurvature_2', 32, float, 1, 0, False, True),
        ('V_pm_PthplnrDiagPathCurrentCurvature_3', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_0', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_1', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_2', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_3', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_4', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_5', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_6', 32, float, 1, 0, False, True),
        ('F_x_NoLaneIgnoreRight', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAP_CntrlPointValid_r1_0', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAP_CntrlPointValid_r1_1', 1, bytes, 1, 0, False, True),
        ('F_x_GotoExitLaneToLocal', 1, bytes, 1, 0, False, True),
        ('F_x_ConstructionArea', 1, bytes, 1, 0, False, True),
        ('Status_1120byte_bit5', 1, bytes, 1, 0, False, True),
        ('Status_1120byte_bit6', 1, bytes, 1, 0, False, True),
        ('Status_1120byte_bit7', 1, bytes, 1, 0, False, True),
        ('V_x_MapHmi_TypeEndMerge_SEL', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_Reliability_SEL_0', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_Reliability_SEL_1', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_Reliability2nd_SEL_0', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_Reliability2nd_SEL_1', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_IncLaneType', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_DecLaneType', 8, int, 1, 0, False, True),
        ('V_m_MapHmi_Dist2NextReliability_0', 32, float, 1, 0, False, True),
        ('V_m_MapHmi_Dist2NextReliability_1', 32, float, 1, 0, False, True),
        ('V_m_MapHmi_DistToIncLane', 32, float, 1, 0, False, True),
        ('V_m_MapHmi_DistToDecLane', 32, float, 1, 0, False, True),
        ('vACC_COM_LMT', 32, float, 1, 0, False, True),
        ('V_m_CaspCurveRadiusArray_0', 16, int, 1, 0, True),
        ('Status_1150byte', 8, int, 1, 0, False, True),
        ('Status_1151byte', 8, int, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_2', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_3', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_4', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_5', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_6', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_ThPosi', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_ThNega', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_0', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_1', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_2', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_3', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_4', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_5', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_6', 32, float, 1, 0, False, True),
        ('ADAS_MonitoringData303', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData304', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData305', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData306', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData307', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData308', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData309', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData310', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData311', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData312', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData313', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData314', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData315', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData316', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData317', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData318', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData319', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData320', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData321', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData322', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData323', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData324', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData325', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData326', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData327', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData328', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData329', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData330', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData331', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData332', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData333', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData334', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData335', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData336', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData337', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData338', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData339', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData340', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData341', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData342', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData343', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData344', 32, int, 1, 0, False, True),
        ('VehStatus_Out_ver', 32, int, 1, 0, False, True),
        ('AURIXver', 32, int, 1, 0, False, True),
        ('RCARver', 32, int, 1, 0, False, True),
        ]
    
    FieldNameList_ver5 = [
        ('Header', 96, bytes, 1, 0),
        ('str_whl_com_lka', 32, float, 1, 0, False, True),
        ('V_m_LKATargetXdist', 32, float, 1, 0, False, True),
        ('V_m_DistToEndNaviPoint', 32, float, 1, 0, False, True),
        ('FS_FailsafeTbl_8', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_9', 32, int, 1, 0, False, True),
        ('YCR_L', 32, float, 1, 0, False, True),
        ('RHO_L', 32, float, 1, 0, False, True),
        ('PHI_L', 32, float, 1, 0, False, True),
        ('RefDistance', 32, float, 1, 0, False, True),
        ('RefRelSpeed', 32, float, 1, 0, False, True),
        ('FBSpeedCmd', 32, float, 1, 0, False, True),
        ('V_req_mps_RequestedSpeedLim', 32, float, 1, 0, False, True),
        ('V_req_mps2_AccComLim', 32, float, 1, 0, False, True),
        ('V_degps_OFST_YAW_RATE_AD2_for_SENS', 32, float, 1, 0, False, True),
        ('hmi_DistToMergeStart', 32, float, 1, 0, False, True),
        ('hmi_DistToMergeEnd', 32, float, 1, 0, False, True),
        ('hmi_DistToBranchStart', 32, float, 1, 0, False, True),
        ('hmi_DistToBranchEnd', 32, float, 1, 0, False, True),
        ('hmi_DistToTollgateStart', 32, float, 1, 0, False, True),
        ('hmi_DistToTollgateEnd', 32, float, 1, 0, False, True),
        ('Heading_LKA_SEL_LANE', 32, float, 1, 0, False, True),
        ('Position_LKA_SEL_LANE', 32, float, 1, 0, False, True),
        ('Curvature_LKA_SEL_LANE', 32, float, 1, 0, False, True),
        ('Curvature_derivative_LKA_SEL_LANE', 32, float, 1, 0, False, True),
        ('Lane_Width', 32, float, 1, 0, False, True),
        ('Position_SEL_LANE_Offset', 32, float, 1, 0, False, True),
        ('TargetDistance', 32, float, 1, 0, False, True),
        ('TargetSpeed', 32, float, 1, 0, False, True),
        ('TargetRelSpeed', 32, float, 1, 0, False, True),
        ('TargetAccel', 32, float, 1, 0, False, True),
        ('TargetTTC', 32, float, 1, 0, False, True),
        ('DIST_X_SIDE_L', 32, float, 1, 0, False, True),
        ('DIST_Y_SIDE_L', 32, float, 1, 0, False, True),
        ('VEL_X_SIDE_L', 32, float, 1, 0, False, True),
        ('VEL_Y_SIDE_L', 32, float, 1, 0, False, True),
        ('DIST_X_SIDE_R', 32, float, 1, 0, False, True),
        ('DIST_Y_SIDE_R', 32, float, 1, 0, False, True),
        ('VEL_X_SIDE_R', 32, float, 1, 0, False, True),
        ('VEL_Y_SIDE_R', 32, float, 1, 0, False, True),
        ('V_kph_CurrentSpeedLimitHD', 32, float, 1, 0, False, True),
        ('V_kph_NextSpeedLimitHD', 32, float, 1, 0, False, True),
        ('V_m_DistToNextSpeedLimitHD', 32, float, 1, 0, False, True),
        ('V_rad_LclztnYaw_0', 32, float, 1, 0, False, True),
        ('V_rad_LclztnYaw_1', 32, float, 1, 0, False, True),
        ('VSP_COM_NAVI', 32, float, 1, 0, False, True),
        ('FS_EventTbl_18', 32, int, 1, 0, False, True),
        ('V_mps2_AccSub', 32, float, 1, 0, False, True),
        ('V_m_YDistanceSelected', 32, float, 1, 0, False, True),
        ('V_s_SetTimeLKATargetDist', 32, float, 1, 0, False, True),
        ('V_rad_SelectedHeadingAngle', 32, float, 1, 0, False, True),
        ('V_1pm_CurvatureSelected', 32, float, 1, 0, False, True),
        ('V_x_HDMap_LKAInfo_C0', 32, float, 1, 0, False, True),
        ('V_x_HDMap_LKAInfo_C1', 32, float, 1, 0, False, True),
        ('V_x_HDMap_LKAInfo_C2', 32, float, 1, 0, False, True),
        ('V_x_HDMap_LKAInfo_C3', 32, float, 1, 0, False, True),
        ('V_x_MapHmi_DecLaneType_2km_0', 8, int, 1, 0, False, True),
        ('ADCtrlStat', 8, int, 1, 0, False, True),
        ('ALCState', 8, int, 1, 0, False, True),
        ('HandsOnLevel', 8, int, 1, 0, False, True),
        ('V_req_rad_SteerFrontFF', 32, float, 1, 0, False, True),
        ('LAT_CONTROL_SEL', 8, int, 1, 0, False, True),
        ('V_x_AutoLC_CancelStatus', 8, int, 1, 0, False, True),
        ('HandsOnType', 8, int, 1, 0, False, True),
        ('LKA_Ctrl_Status', 8, int, 1, 0, False, True),
        ('V_m_YDistanceLaneChange', 32, float, 1, 0, False, True),
        ('V_rad_SWAOffsetLowSpeed', 32, float, 1, 0, False, True),
        ('V_m_YDistanceCamLane', 32, float, 1, 0, False, True),
        ('SteerReqType', 8, int, 1, 0, False, True),
        ('NoticeType', 8, int, 1, 0, False, True),
        ('TD_Type', 8, int, 1, 0, False, True),
        ('V_x_InternalACCStatus', 8, int, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_0', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_1', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_2', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_3', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_4', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_5', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_6', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_7', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_0', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_1', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_2', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_3', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_4', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_5', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_6', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_7', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_0', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_1', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_2', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_3', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_4', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_5', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_6', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_11', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_12', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_13', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_14', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_15', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_16', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_17', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_22', 32, float, 1, 0, False, True),
        ('V_m_MapCamPositionDiff_JudgeLane', 32, float, 1, 0, False, True),
        ('V_rad_MapCamAngleDiff_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapCamCosSimilarity_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapCamXcorr_JudgeLane', 32, float, 1, 0, False, True),
        ('FS_EventTbl_0', 32, int, 1, 0, False, True),
        ('FS_EventTbl_1', 32, int, 1, 0, False, True),
        ('FS_EventTbl_2', 32, int, 1, 0, False, True),
        ('FS_EventTbl_3', 32, int, 1, 0, False, True),
        ('FS_EventTbl_4', 32, int, 1, 0, False, True),
        ('FS_EventTbl_5', 32, int, 1, 0, False, True),
        ('FS_EventTbl_6', 32, int, 1, 0, False, True),
        ('FS_EventTbl_7', 32, int, 1, 0, False, True),
        ('FS_EventTbl_8', 32, int, 1, 0, False, True),
        ('FS_EventTbl_9', 32, int, 1, 0, False, True),
        ('FS_EventTbl_10', 32, int, 1, 0, False, True),
        ('FS_EventTbl_11', 32, int, 1, 0, False, True),
        ('FS_EventTbl_12', 32, int, 1, 0, False, True),
        ('FS_EventTbl_13', 32, int, 1, 0, False, True),
        ('FS_EventTbl_14', 32, int, 1, 0, False, True),
        ('FS_EventTbl_15', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_0', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_1', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_2', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_3', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_4', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_5', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_6', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_7', 32, int, 1, 0, False, True),
        ('V_x_Debug_Large', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData123', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData124', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData125', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData126', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData127', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData128', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData129', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData130', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData131', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData132', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData133', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData134', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData135', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData136', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData137', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData138', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData139', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData140', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData141', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData142', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData143', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData144', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData145', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData146', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData147', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData148', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData149', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData150', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData151', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData152', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData153', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData154', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData155', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData156', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData157', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData158', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData159', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData160', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData161', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData162', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData163', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData164', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData165', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData166', 32, int, 1, 0, False, True),
        ('smDebugMapCamCorrected_ThPosi', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_ThNega', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_0', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_1', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_2', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_3', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_4', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_5', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_6', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_ThPosi', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_ThNega', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_0', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_1', 32, float, 1, 0, False, True),
        ('FS_EventTbl_16', 32, int, 1, 0, False, True),
        ('FS_EventTbl_17', 32, int, 1, 0, False, True),
        ('V_deg_Global_SteeringAngleRequest_ASD_SM_CAN', 32, int, 1, 0, True),
        ('smDebugMapCamRaw_diff_2', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_3', 32, float, 1, 0, False, True),
        ('F_x_ForcedSteeringLeft', 1, bytes, 1, 0, False, True),
        ('F_x_ForcedSteeringRight', 1, bytes, 1, 0, False, True),
        ('F_x_MapHppPosDif_JudgeLane', 1, bytes, 1, 0, False, True),
        ('smDebugProtrudeEstimatedRight', 1, bytes, 1, 0, False, True),
        ('smDebugProtrudeEstimatedLeft', 1, bytes, 1, 0, False, True),
        ('SMdebug_736byte_bit5', 1, bytes, 1, 0, False, True),
        ('SMdebug_736byte_bit6', 1, bytes, 1, 0, False, True),
        ('SMdebug_736byte_bit7', 1, bytes, 1, 0, False, True),
        ('V_x_MapValid_JudgeLane', 8, int, 1, 0, False, True),
        ('SMdebug_738byte', 8, int, 1, 0, False, True),
        ('SMdebug_739byte', 8, int, 1, 0, False, True),
        ('V_m_MapHmi_DistToDecLaneStart_0', 32, float, 1, 0, False, True),
        ('V_m_MapHmi_DistToDecLaneEnd_0', 32, float, 1, 0, False, True),
        ('V_m_MapHppPositionDiff_JudgeLane', 32, float, 1, 0, False, True),
        ('V_rad_MapHppAngleDiff_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapHppCosSimilarity_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapHppXcorr_JudgeLane', 32, float, 1, 0, False, True),
        ('ADAS_MonitoringData192', 32, int, 1, 0, False, True),
        ('EstLatMoveRight', 32, float, 1, 0, False, True),
        ('EstLatMoveLeft', 32, float, 1, 0, False, True),
        ('LatPosRight', 32, float, 1, 0, False, True),
        ('LatPosLeft', 32, float, 1, 0, False, True),
        ('EstLatMoveDlyRight', 32, float, 1, 0, False, True),
        ('EstLatMoveDlyLeft', 32, float, 1, 0, False, True),
        ('EstLatMoveModifyRight', 32, float, 1, 0, False, True),
        ('EstLatMoveModifyLeft', 32, float, 1, 0, False, True),
        ('V_m_MapHmi_DistToTollBoothStart_0', 32, float, 1, 0, False, True),
        ('V_m_MapHmi_DistToTollBoothEnd_0', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_4', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_5', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_6', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_ThPosi', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_ThNega', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_0', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_1', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPCrossSlopeSel0', 32, float, 1, 0, False, True),
        ('ycr_i_LKA', 32, float, 1, 0, False, True),
        ('V_m_MapHmi_HDMAP_ActiveDistance_0', 32, float, 1, 0, False, True),
        ('V_mps_SaturatedRequestedSpdReq', 32, float, 1, 0, False, True),
        ('V_mps_CurveControlSpeed', 32, float, 1, 0, False, True),
        ('V_m_DistToLocal', 32, float, 1, 0, False, True),
        ('vVSP_TAR_MIN', 32, float, 1, 0, False, True),
        ('V_m_PthPlnrRouteLaneWidthLeft', 32, float, 1, 0, False, True),
        ('V_m_PthPlnrRouteLaneWidthRight', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPNextCrossSlopeSelL', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPNextCrossSlopeSelR', 32, float, 1, 0, False, True),
        ('V_m_PthPlnrRouteLaneWidthSel0', 32, float, 1, 0, False, True),
        ('V_deg_LclztnLatitude_0', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_LclztnLongitude_0', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_LclztnLatitude_1', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_LclztnLongitude_1', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_HDMAP_latitude_0', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_HDMAP_longitude_0', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_x_AutoLC_CancelReason', 32, int, 1, 0, False, True),
        ('Map_pp_status', 32, int, 1, 0, False, True),
        ('V_x_Debug_Middle04Small01', 32, int, 1, 0, False, True),
        ('V_x_ALCInhiFlagArry', 32, int, 1, 0, False, True),
        ('V_x_Route_Additional_Info', 32, int, 1, 0, False, True),
        ('V_x_Debug_LKAReadyTempOFF_Reason', 32, int, 1, 0, False, True),
        ('LchPossible_ListCode', 16, int, 1, 0, False, True),
        ('V_x_Debug_Middle04', 16, int, 1, 0, False, True),
        ('V_m_dist_Nolane_RCar_0', 16, int, 1, 0, False, True),
        ('V_x_P2P_Disable_Reason', 16, int, 1, 0, False, True),
        ('LANE_CHANGE_POSSIBLE_RIGHT', 8, int, 1, 0, False, True),
        ('LANE_CHANGE_POSSIBLE_LEFT', 8, int, 1, 0, False, True),
        ('Type_of_SystemReq', 8, int, 1, 0, False, True),
        ('hmi_BranchType', 8, int, 1, 0, False, True),
        ('hmi_MergeType', 8, int, 1, 0, False, True),
        ('hmi_HD_NumOfLane', 8, int, 1, 0, False, True),
        ('hmi_HD_CurrentLanePos', 8, int, 1, 0, False, True),
        ('LINE_SEL_HOKAN', 8, int, 1, 0, False, True),
        ('SensorSel', 8, int, 1, 0, False, True),
        ('map_valid', 8, int, 1, 0, False, True),
        ('V_x_BranchType', 8, int, 1, 0, False, True),
        ('V_x_AutoLCDirection_HMI', 8, int, 1, 0, False, True),
        ('V_x_AutoLC_Reason', 8, int, 1, 0, False, True),
        ('Confidence', 8, int, 1, 0, False, True),
        ('Confidence_2', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle02Small01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle02Small02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle02Small03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle03Small01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle03Small02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle03Small03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle04Small02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle04Small03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle05', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle05Small01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle05Small02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle05Small03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle06', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle07', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle09', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle12', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle12Small01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle14', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle16', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle17', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle19', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle20', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle21', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle22', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle23', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_r1_20', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_r1_29', 8, int, 1, 0, False, True),
        ('V_x_P2P_continuity_reason', 8, int, 1, 0, False, True),
        ('V_x_HandsOnReq_Lateral', 8, int, 1, 0, False, True),
        ('V_x_TimeGapRange', 8, int, 1, 0, False, True),
        ('V_x_LaneSourceSelect', 8, int, 1, 0, False, True),
        ('V_x_TSR_OSP_SpeedSignalZone1', 8, int, 1, 0, False, True),
        ('V_x_HOD_ModeStatus_Vsi', 8, int, 1, 0, False, True),
        ('V_x_HOD_Error_Vsi', 8, int, 1, 0, False, True),
        ('V_x_TSR_SpdWriteStatus', 8, int, 1, 0, False, True),
        ('V_x_MnSnd1', 8, int, 1, 0, False, True),
        ('V_x_MnSnd2', 8, int, 1, 0, False, True),
        ('V_x_MnSnd3', 8, int, 1, 0, False, True),
        ('V_x_MnSnd4', 8, int, 1, 0, False, True),
        ('V_x_MnSnd5', 8, int, 1, 0, False, True),
        ('V_x_CurrentSpeedLimit_TSR', 8, int, 1, 0, False, True),
        ('V_x_NRD_Status', 8, int, 1, 0, False, True),
        ('V_x_ApprovalCancelReason', 8, int, 1, 0, False, True),
        ('Status_1001byte', 8, int, 1, 0, False, True),
        ('Status_1002byte', 8, int, 1, 0, False, True),
        ('V_x_EAP_SoundAlertRequest', 8, int, 1, 0, False, True),
        ('V_x_HDMAP_Route_SEL', 8, int, 1, 0, False, True),
        ('V_x_TSRRequestSpeed', 8, int, 1, 0, False, True),
        ('V_x_REQ_type_HDmap', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_0', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_r1_0', 8, int, 1, 0, False, True),
        ('vNAVI_ICC_MAP_MODE', 8, int, 1, 0, False, True),
        ('V_x_Nolane_Type_RCar_0', 8, int, 1, 0, False, True),
        ('V_x_P2P_ControlRegionType', 8, int, 1, 0, False, True),
        ('V_x_Num_LaneChangeReqForLeft', 8, int, 1, 0, False, True),
        ('V_x_Num_LaneChangeReqForRight', 8, int, 1, 0, False, True),
        ('LKA_Permit', 1, bytes, 1, 0, False, True),
        ('LCH_ON', 1, bytes, 1, 0, False, True),
        ('HDMAP_ready_valid2', 1, bytes, 1, 0, False, True),
        ('F_x_MemOn_valid1', 1, bytes, 1, 0, False, True),
        ('F_x_TrafficJamNextLane', 1, bytes, 1, 0, False, True),
        ('fSTEER_CTRL0', 1, bytes, 1, 0, False, True),
        ('fSTEER_CTRL2', 1, bytes, 1, 0, False, True),
        ('NAVI_ACC_ACT', 1, bytes, 1, 0, False, True),
        ('Longi_Permit', 1, bytes, 1, 0, False, True),
        ('RETURN_REQUEST_LEFT', 1, bytes, 1, 0, False, True),
        ('PASS_REQUEST_RIGHT', 1, bytes, 1, 0, False, True),
        ('hmi_MergeViewAreaControl', 1, bytes, 1, 0, False, True),
        ('flg_SIDEOBJ_L', 1, bytes, 1, 0, False, True),
        ('flg_SIDEOBJ_R', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAP_CntrlPointValid_0', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAP_CntrlPointValid_1', 1, bytes, 1, 0, False, True),
        ('F_x_NStateReroute', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAPRawValidShape', 1, bytes, 1, 0, False, True),
        ('F_x_TSR_OnHDMap', 1, bytes, 1, 0, False, True),
        ('F_x_MapHmi_Overhead_on_Route_0', 1, bytes, 1, 0, False, True),
        ('F_x_DriveHighwayNavi', 1, bytes, 1, 0, False, True),
        ('F_x_DriveHighwayTSRNavi', 1, bytes, 1, 0, False, True),
        ('F_x_MapCamPosDif_JudgeLane', 1, bytes, 1, 0, False, True),
        ('F_x_P2P_Control_Region', 1, bytes, 1, 0, False, True),
        ('V_x_Nolane_Type_RCar_1', 8, int, 1, 0, False, True),
        ('V_m_dist_Nolane_RCar_1', 16, int, 1, 0, False, True),
        ('V_m_DistToToll', 32, float, 1, 0, False, True),
        ('V_x_LC_possible_route_0', 16, int, 1, 0, False, True),
        ('V_x_LC_possible_route_1', 16, int, 1, 0, False, True),
        ('V_pm_PthplnrDiagPathCurrentCurvature_0', 32, float, 1, 0, False, True),
        ('V_1pm_CurvaturePredSelected', 32, float, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_20', 8, int, 1, 0, False, True),
        ('F_x_LinkPointIntersection', 1, bytes, 1, 0, False, True),
        ('F_x_LC_req_Driver_L', 1, bytes, 1, 0, False, True),
        ('F_x_LC_req_Driver_R', 1, bytes, 1, 0, False, True),
        ('F_x_LC_req_P2P_L', 1, bytes, 1, 0, False, True),
        ('F_x_LC_req_P2P_R', 1, bytes, 1, 0, False, True),
        ('fIVIRouteCurveSel', 1, bytes, 1, 0, False, True),
        ('F_x_MapHmi_Overhead_on_Route_1', 1, bytes, 1, 0, False, True),
        ('F_x_NoLaneIgnoreLeft', 1, bytes, 1, 0, False, True),
        ('V_x_OvertakeProhibit_0', 8, int, 1, 0, False, True),
        ('vCURV_NO', 8, int, 1, 0, False, True),
        ('V_mps_CaspExitTargetSpeed', 32, float, 1, 0, False, True),
        ('vACC_TAR_MIN', 32, float, 1, 0, False, True),
        ('vCURV_NO_0', 16, int, 1, 0, True),
        ('V_x_MapHmi_NumOfBranchLane_0', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_NumOfBranchLane_1', 8, int, 1, 0, False, True),
        ('V_pct_HDMAPCrossSlopeSel1', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPCrossSlopeSel2', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPCrossSlopeSel3', 32, float, 1, 0, False, True),
        ('V_m_ycr_pre_l', 32, float, 1, 0, False, True),
        ('V_x_LCStateTemporalCounter', 16, int, 1, 0, False, True),
        ('V_m_Dist_to_Branch_togo', 16, int, 1, 0, False, True),
        ('V_x_Debug_LKAReadyCondition', 16, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_27', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_r1_27', 8, int, 1, 0, False, True),
        ('V_m_DistToJCT', 32, float, 1, 0, False, True),
        ('V_pm_PthplnrDiagPathCurrentCurvature_1', 32, float, 1, 0, False, True),
        ('V_pm_PthplnrDiagPathCurrentCurvature_2', 32, float, 1, 0, False, True),
        ('V_pm_PthplnrDiagPathCurrentCurvature_3', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_0', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_1', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_2', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_3', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_4', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_5', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_6', 32, float, 1, 0, False, True),
        ('F_x_NoLaneIgnoreRight', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAP_CntrlPointValid_r1_0', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAP_CntrlPointValid_r1_1', 1, bytes, 1, 0, False, True),
        ('F_x_GotoExitLaneToLocal', 1, bytes, 1, 0, False, True),
        ('F_x_ConstructionArea', 1, bytes, 1, 0, False, True),
        ('F_x_HandsOnJdg_Confirm', 1, bytes, 1, 0, False, True),
        ('F_x_MT_MergeViewAreaControl2nd_SEL', 1, bytes, 1, 0, False, True),
        ('Status_1120byte_bit7', 1, bytes, 1, 0, False, True),
        ('V_x_MapHmi_TypeEndMerge_SEL', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_Reliability_SEL_0', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_Reliability_SEL_1', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_Reliability2nd_SEL_0', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_Reliability2nd_SEL_1', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_IncLaneType', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_DecLaneType', 8, int, 1, 0, False, True),
        ('V_m_MapHmi_Dist2NextReliability_0', 32, float, 1, 0, False, True),
        ('V_m_MapHmi_Dist2NextReliability_1', 32, float, 1, 0, False, True),
        ('V_m_MapHmi_DistToIncLane', 32, float, 1, 0, False, True),
        ('V_m_MapHmi_DistToDecLane', 32, float, 1, 0, False, True),
        ('vACC_COM_LMT', 32, float, 1, 0, False, True),
        ('V_m_CaspCurveRadiusArray_0', 16, int, 1, 0, True),
        ('Status_1150byte', 8, int, 1, 0, False, True),
        ('Status_1151byte', 8, int, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_2', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_3', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_4', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_5', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_6', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_ThPosi', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_ThNega', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_0', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_1', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_2', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_3', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_4', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_5', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_6', 32, float, 1, 0, False, True),
        ('ADAS_MonitoringData303', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData304', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData305', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData306', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData307', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData308', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData309', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData310', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData311', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData312', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData313', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData314', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData315', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData316', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData317', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData318', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData319', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData320', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData321', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData322', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData323', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData324', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData325', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData326', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData327', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData328', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData329', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData330', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData331', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData332', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData333', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData334', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData335', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData336', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData337', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData338', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData339', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData340', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData341', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData342', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData343', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData344', 32, int, 1, 0, False, True),
        ('VehStatus_Out_ver', 32, int, 1, 0, False, True),
        ('AURIXver', 32, int, 1, 0, False, True),
        ('RCARver', 32, int, 1, 0, False, True),
        ]
        
    FieldNameList_ver6 = [
        ('Header', 96, bytes, 1, 0),
        ('str_whl_com_lka', 32, float, 1, 0, False, True),
        ('V_m_LKATargetXdist', 32, float, 1, 0, False, True),
        ('V_m_DistToEndNaviPoint', 16, int, 1, 0, False, True),
        ('V_m_MapHmi_HDMAP_ActiveDistance_0', 16, int, 1, 0, False, True),
        ('FS_FailsafeTbl_8', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_9', 32, int, 1, 0, False, True),
        ('YCR_L', 32, float, 1, 0, False, True),
        ('RHO_L', 32, float, 1, 0, False, True),
        ('PHI_L', 32, float, 1, 0, False, True),
        ('RefDistance', 32, float, 1, 0, False, True),
        ('RefRelSpeed', 32, float, 1, 0, False, True),
        ('FBSpeedCmd', 32, float, 1, 0, False, True),
        ('V_req_mps_RequestedSpeedLim', 32, float, 1, 0, False, True),
        ('V_req_mps2_AccComLim', 32, float, 1, 0, False, True),
        ('V_degps_OFST_YAW_RATE_AD2_for_SENS', 32, float, 1, 0, False, True),
        ('hmi_DistToMergeStart', 16, int, 1, 0, False, True),
        ('hmi_DistToMergeEnd', 16, int, 1, 0, False, True),
        ('hmi_DistToBranchStart', 16, int, 1, 0, False, True),
        ('hmi_DistToBranchEnd', 16, int, 1, 0, False, True),
        ('hmi_DistToTollgateStart', 16, int, 1, 0, False, True),
        ('hmi_DistToTollgateEnd', 16, int, 1, 0, False, True),
        ('ADAS_MonitoringData18', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData19', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData20', 32, int, 1, 0, False, True),
        ('Heading_LKA_SEL_LANE', 32, float, 1, 0, False, True),
        ('Position_LKA_SEL_LANE', 32, float, 1, 0, False, True),
        ('Curvature_LKA_SEL_LANE', 32, float, 1, 0, False, True),
        ('Curvature_derivative_LKA_SEL_LANE', 32, float, 1, 0, False, True),
        ('Lane_Width', 32, float, 1, 0, False, True),
        ('Position_SEL_LANE_Offset', 32, float, 1, 0, False, True),
        ('TargetDistance', 32, float, 1, 0, False, True),
        ('TargetSpeed', 32, float, 1, 0, False, True),
        ('TargetRelSpeed', 32, float, 1, 0, False, True),
        ('TargetAccel', 32, float, 1, 0, False, True),
        ('TargetTTC', 32, float, 1, 0, False, True),
        ('DIST_X_SIDE_L', 32, float, 1, 0, False, True),
        ('DIST_Y_SIDE_L', 32, float, 1, 0, False, True),
        ('VEL_X_SIDE_L', 32, float, 1, 0, False, True),
        ('VEL_Y_SIDE_L', 32, float, 1, 0, False, True),
        ('DIST_X_SIDE_R', 32, float, 1, 0, False, True),
        ('DIST_Y_SIDE_R', 32, float, 1, 0, False, True),
        ('VEL_X_SIDE_R', 32, float, 1, 0, False, True),
        ('VEL_Y_SIDE_R', 32, float, 1, 0, False, True),
        ('V_kph_CurrentSpeedLimitHD', 8, int, 1, 0, False, True),
        ('V_kph_NextSpeedLimitHD', 8, int, 1, 0, False, True),
        ('V_m_DistToNextSpeedLimitHD', 16, int, 1, 0, False, True),
        ('ADAS_MonitoringData41', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData42', 32, int, 1, 0, False, True),
        ('V_rad_LclztnYaw_0', 32, float, 1, 0, False, True),
        ('V_rad_LclztnYaw_1', 32, float, 1, 0, False, True),
        ('VSP_COM_NAVI', 32, float, 1, 0, False, True),
        ('FS_EventTbl_18', 32, int, 1, 0, False, True),
        ('V_mps2_AccSub', 32, float, 1, 0, False, True),
        ('V_m_YDistanceSelected', 32, float, 1, 0, False, True),
        ('V_s_SetTimeLKATargetDist', 32, float, 1, 0, False, True),
        ('V_rad_SelectedHeadingAngle', 32, float, 1, 0, False, True),
        ('V_1pm_CurvatureSelected', 32, float, 1, 0, False, True),
        ('V_x_HDMap_LKAInfo_C0', 32, float, 1, 0, False, True),
        ('V_x_HDMap_LKAInfo_C1', 32, float, 1, 0, False, True),
        ('V_x_HDMap_LKAInfo_C2', 32, float, 1, 0, False, True),
        ('V_x_HDMap_LKAInfo_C3', 32, float, 1, 0, False, True),
        ('V_x_MapHmi_DecLaneType_2km_0', 8, int, 1, 0, False, True),
        ('ADCtrlStat', 8, int, 1, 0, False, True),
        ('ALCState', 8, int, 1, 0, False, True),
        ('HandsOnLevel', 8, int, 1, 0, False, True),
        ('V_req_rad_SteerFrontFF', 32, float, 1, 0, False, True),
        ('LAT_CONTROL_SEL', 8, int, 1, 0, False, True),
        ('V_x_AutoLC_CancelStatus', 8, int, 1, 0, False, True),
        ('HandsOnType', 8, int, 1, 0, False, True),
        ('LKA_Ctrl_Status', 8, int, 1, 0, False, True),
        ('V_m_YDistanceLaneChange', 32, float, 1, 0, False, True),
        ('V_rad_SWAOffsetLowSpeed', 32, float, 1, 0, False, True),
        ('V_m_YDistanceCamLane', 32, float, 1, 0, False, True),
        ('SteerReqType', 8, int, 1, 0, False, True),
        ('NoticeType', 8, int, 1, 0, False, True),
        ('TD_Type', 8, int, 1, 0, False, True),
        ('V_x_InternalACCStatus', 8, int, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_0', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_1', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_2', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_3', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_4', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_5', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_6', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsX_7', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_0', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_1', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_2', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_3', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_4', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_5', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_6', 32, float, 1, 0, False, True),
        ('V_m_SelectedControlPointsY_7', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_0', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_1', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_2', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_3', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_4', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_5', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_6', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_11', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_12', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_13', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_14', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_15', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_16', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_17', 32, float, 1, 0, False, True),
        ('V_m_MapShapeInfo_22', 32, float, 1, 0, False, True),
        ('V_m_MapCamPositionDiff_JudgeLane', 32, float, 1, 0, False, True),
        ('V_rad_MapCamAngleDiff_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapCamCosSimilarity_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapCamXcorr_JudgeLane', 32, float, 1, 0, False, True),
        ('FS_EventTbl_0', 32, int, 1, 0, False, True),
        ('FS_EventTbl_1', 32, int, 1, 0, False, True),
        ('FS_EventTbl_2', 32, int, 1, 0, False, True),
        ('FS_EventTbl_3', 32, int, 1, 0, False, True),
        ('FS_EventTbl_4', 32, int, 1, 0, False, True),
        ('FS_EventTbl_5', 32, int, 1, 0, False, True),
        ('FS_EventTbl_6', 32, int, 1, 0, False, True),
        ('FS_EventTbl_7', 32, int, 1, 0, False, True),
        ('FS_EventTbl_8', 32, int, 1, 0, False, True),
        ('FS_EventTbl_9', 32, int, 1, 0, False, True),
        ('FS_EventTbl_10', 32, int, 1, 0, False, True),
        ('FS_EventTbl_11', 32, int, 1, 0, False, True),
        ('FS_EventTbl_12', 32, int, 1, 0, False, True),
        ('FS_EventTbl_13', 32, int, 1, 0, False, True),
        ('FS_EventTbl_14', 32, int, 1, 0, False, True),
        ('FS_EventTbl_15', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_0', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_1', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_2', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_3', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_4', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_5', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_6', 32, int, 1, 0, False, True),
        ('FS_FailsafeTbl_7', 32, int, 1, 0, False, True),
        ('V_x_Debug_Large', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData123', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData124', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData125', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData126', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData127', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData128', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData129', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData130', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData131', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData132', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData133', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData134', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData135', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData136', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData137', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData138', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData139', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData140', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData141', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData142', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData143', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData144', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData145', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData146', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData147', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData148', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData149', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData150', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData151', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData152', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData153', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData154', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData155', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData156', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData157', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData158', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData159', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData160', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData161', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData162', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData163', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData164', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData165', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData166', 32, int, 1, 0, False, True),
        ('smDebugMapCamCorrected_ThPosi', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_ThNega', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_0', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_1', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_2', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_3', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_4', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_5', 32, float, 1, 0, False, True),
        ('smDebugMapCamCorrected_diff_6', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_ThPosi', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_ThNega', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_0', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_1', 32, float, 1, 0, False, True),
        ('FS_EventTbl_16', 32, int, 1, 0, False, True),
        ('FS_EventTbl_17', 32, int, 1, 0, False, True),
        ('V_deg_Global_SteeringAngleRequest_ASD_SM_CAN', 32, int, 1, 0, True),
        ('smDebugMapCamRaw_diff_2', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_3', 32, float, 1, 0, False, True),
        ('F_x_ForcedSteeringLeft', 1, bytes, 1, 0, False, True),
        ('F_x_ForcedSteeringRight', 1, bytes, 1, 0, False, True),
        ('F_x_MapHppPosDif_JudgeLane', 1, bytes, 1, 0, False, True),
        ('smDebugProtrudeEstimatedRight', 1, bytes, 1, 0, False, True),
        ('smDebugProtrudeEstimatedLeft', 1, bytes, 1, 0, False, True),
        ('SMdebug_736byte_bit5', 1, bytes, 1, 0, False, True),
        ('SMdebug_736byte_bit6', 1, bytes, 1, 0, False, True),
        ('SMdebug_736byte_bit7', 1, bytes, 1, 0, False, True),
        ('V_x_MapValid_JudgeLane', 8, int, 1, 0, False, True),
        ('SMdebug_738byte', 8, int, 1, 0, False, True),
        ('SMdebug_739byte', 8, int, 1, 0, False, True),
        ('V_m_MapHmi_DistToDecLaneStart_0', 16, int, 1, 0, False, True),
        ('V_m_MapHmi_DistToDecLaneEnd_0', 16, int, 1, 0, False, True),
        ('ADAS_MonitoringData187', 32, int, 1, 0, False, True),
        ('V_m_MapHppPositionDiff_JudgeLane', 32, float, 1, 0, False, True),
        ('V_rad_MapHppAngleDiff_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapHppCosSimilarity_JudgeLane', 32, float, 1, 0, False, True),
        ('V_x_MapHppXcorr_JudgeLane', 32, float, 1, 0, False, True),
        ('ADAS_MonitoringData192', 32, int, 1, 0, False, True),
        ('EstLatMoveRight', 32, float, 1, 0, False, True),
        ('EstLatMoveLeft', 32, float, 1, 0, False, True),
        ('LatPosRight', 32, float, 1, 0, False, True),
        ('LatPosLeft', 32, float, 1, 0, False, True),
        ('EstLatMoveDlyRight', 32, float, 1, 0, False, True),
        ('EstLatMoveDlyLeft', 32, float, 1, 0, False, True),
        ('EstLatMoveModifyRight', 32, float, 1, 0, False, True),
        ('EstLatMoveModifyLeft', 32, float, 1, 0, False, True),
        ('V_m_MapHmi_DistToTollBoothStart_0', 16, int, 1, 0, False, True),
        ('V_m_MapHmi_DistToTollBoothEnd_0', 16, int, 1, 0, False, True),
        ('ADAS_MonitoringData202', 32, int, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_4', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_5', 32, float, 1, 0, False, True),
        ('smDebugMapCamRaw_diff_6', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_ThPosi', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_ThNega', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_0', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_1', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPCrossSlopeSel0', 32, float, 1, 0, False, True),
        ('ycr_i_LKA', 32, float, 1, 0, False, True),
        ('ADAS_MonitoringData212', 32, int, 1, 0, False, True),
        ('V_mps_SaturatedRequestedSpdReq', 32, float, 1, 0, False, True),
        ('V_mps_CurveControlSpeed', 32, float, 1, 0, False, True),
        ('V_m_DistToLocal', 32, float, 1, 0, False, True),
        ('vVSP_TAR_MIN', 32, float, 1, 0, False, True),
        ('V_m_PthPlnrRouteLaneWidthLeft', 32, float, 1, 0, False, True),
        ('V_m_PthPlnrRouteLaneWidthRight', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPNextCrossSlopeSelL', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPNextCrossSlopeSelR', 32, float, 1, 0, False, True),
        ('V_m_PthPlnrRouteLaneWidthSel0', 32, float, 1, 0, False, True),
        ('V_deg_LclztnLatitude_0', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_LclztnLongitude_0', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_LclztnLatitude_1', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_LclztnLongitude_1', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_HDMAP_latitude_0', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_deg_HDMAP_longitude_0', 32, int, 0.0000001, -214.7483648, False, True),
        ('V_x_AutoLC_CancelReason', 32, int, 1, 0, False, True),
        ('Map_pp_status', 32, int, 1, 0, False, True),
        ('V_x_Debug_Middle04Small01', 32, int, 1, 0, False, True),
        ('V_x_ALCInhiFlagArry', 32, int, 1, 0, False, True),
        ('V_x_Route_Additional_Info', 32, int, 1, 0, False, True),
        ('V_x_Debug_LKAReadyTempOFF_Reason', 32, int, 1, 0, False, True),
        ('LchPossible_ListCode', 16, int, 1, 0, False, True),
        ('V_x_Debug_Middle04', 16, int, 1, 0, False, True),
        ('V_m_dist_Nolane_RCar_0', 16, int, 1, 0, False, True),
        ('V_x_P2P_Disable_Reason', 16, int, 1, 0, False, True),
        ('LANE_CHANGE_POSSIBLE_RIGHT', 8, int, 1, 0, False, True),
        ('LANE_CHANGE_POSSIBLE_LEFT', 8, int, 1, 0, False, True),
        ('Type_of_SystemReq', 8, int, 1, 0, False, True),
        ('hmi_BranchType', 8, int, 1, 0, False, True),
        ('hmi_MergeType', 8, int, 1, 0, False, True),
        ('hmi_HD_NumOfLane', 8, int, 1, 0, False, True),
        ('hmi_HD_CurrentLanePos', 8, int, 1, 0, False, True),
        ('LINE_SEL_HOKAN', 8, int, 1, 0, False, True),
        ('SensorSel', 8, int, 1, 0, False, True),
        ('map_valid', 8, int, 1, 0, False, True),
        ('V_x_BranchType', 8, int, 1, 0, False, True),
        ('V_x_AutoLCDirection_HMI', 8, int, 1, 0, False, True),
        ('V_x_AutoLC_Reason', 8, int, 1, 0, False, True),
        ('Confidence', 8, int, 1, 0, False, True),
        ('Confidence_2', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle02Small01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle02Small02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle02Small03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle03Small01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle03Small02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle03Small03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle04Small02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle04Small03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle05', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle05Small01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle05Small02', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle05Small03', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle06', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle07', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle09', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle12', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle12Small01', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle14', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle16', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle17', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle19', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle20', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle21', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle22', 8, int, 1, 0, False, True),
        ('V_x_Debug_Middle23', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_r1_20', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_r1_29', 8, int, 1, 0, False, True),
        ('V_x_P2P_continuity_reason', 8, int, 1, 0, False, True),
        ('V_x_HandsOnReq_Lateral', 8, int, 1, 0, False, True),
        ('V_x_TimeGapRange', 8, int, 1, 0, False, True),
        ('V_x_LaneSourceSelect', 8, int, 1, 0, False, True),
        ('V_x_TSR_OSP_SpeedSignalZone1', 8, int, 1, 0, False, True),
        ('V_x_HOD_ModeStatus_Vsi', 8, int, 1, 0, False, True),
        ('V_x_HOD_Error_Vsi', 8, int, 1, 0, False, True),
        ('V_x_TSR_SpdWriteStatus', 8, int, 1, 0, False, True),
        ('V_x_MnSnd1', 8, int, 1, 0, False, True),
        ('V_x_MnSnd2', 8, int, 1, 0, False, True),
        ('V_x_MnSnd3', 8, int, 1, 0, False, True),
        ('V_x_MnSnd4', 8, int, 1, 0, False, True),
        ('V_x_MnSnd5', 8, int, 1, 0, False, True),
        ('V_x_CurrentSpeedLimit_TSR', 8, int, 1, 0, False, True),
        ('V_x_NRD_Status', 8, int, 1, 0, False, True),
        ('V_x_ApprovalCancelReason', 8, int, 1, 0, False, True),
        ('Status_1001byte', 8, int, 1, 0, False, True),
        ('Status_1002byte', 8, int, 1, 0, False, True),
        ('V_x_EAP_SoundAlertRequest', 8, int, 1, 0, False, True),
        ('V_x_HDMAP_Route_SEL', 8, int, 1, 0, False, True),
        ('V_x_TSRRequestSpeed', 8, int, 1, 0, False, True),
        ('V_x_REQ_type_HDmap', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_0', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_r1_0', 8, int, 1, 0, False, True),
        ('vNAVI_ICC_MAP_MODE', 8, int, 1, 0, False, True),
        ('V_x_Nolane_Type_RCar_0', 8, int, 1, 0, False, True),
        ('V_x_P2P_ControlRegionType', 8, int, 1, 0, False, True),
        ('V_x_Num_LaneChangeReqForLeft', 8, int, 1, 0, False, True),
        ('V_x_Num_LaneChangeReqForRight', 8, int, 1, 0, False, True),
        ('LKA_Permit', 1, bytes, 1, 0, False, True),
        ('LCH_ON', 1, bytes, 1, 0, False, True),
        ('HDMAP_ready_valid2', 1, bytes, 1, 0, False, True),
        ('F_x_MemOn_valid1', 1, bytes, 1, 0, False, True),
        ('F_x_TrafficJamNextLane', 1, bytes, 1, 0, False, True),
        ('fSTEER_CTRL0', 1, bytes, 1, 0, False, True),
        ('fSTEER_CTRL2', 1, bytes, 1, 0, False, True),
        ('NAVI_ACC_ACT', 1, bytes, 1, 0, False, True),
        ('Longi_Permit', 1, bytes, 1, 0, False, True),
        ('RETURN_REQUEST_LEFT', 1, bytes, 1, 0, False, True),
        ('PASS_REQUEST_RIGHT', 1, bytes, 1, 0, False, True),
        ('hmi_MergeViewAreaControl', 1, bytes, 1, 0, False, True),
        ('flg_SIDEOBJ_L', 1, bytes, 1, 0, False, True),
        ('flg_SIDEOBJ_R', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAP_CntrlPointValid_0', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAP_CntrlPointValid_1', 1, bytes, 1, 0, False, True),
        ('F_x_NStateReroute', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAPRawValidShape', 1, bytes, 1, 0, False, True),
        ('F_x_TSR_OnHDMap', 1, bytes, 1, 0, False, True),
        ('F_x_MapHmi_Overhead_on_Route_0', 1, bytes, 1, 0, False, True),
        ('F_x_DriveHighwayNavi', 1, bytes, 1, 0, False, True),
        ('F_x_DriveHighwayTSRNavi', 1, bytes, 1, 0, False, True),
        ('F_x_MapCamPosDif_JudgeLane', 1, bytes, 1, 0, False, True),
        ('F_x_P2P_Control_Region', 1, bytes, 1, 0, False, True),
        ('V_x_Nolane_Type_RCar_1', 8, int, 1, 0, False, True),
        ('V_m_dist_Nolane_RCar_1', 16, int, 1, 0, False, True),
        ('V_m_DistToToll', 32, float, 1, 0, False, True),
        ('V_x_LC_possible_route_0', 16, int, 1, 0, False, True),
        ('V_x_LC_possible_route_1', 16, int, 1, 0, False, True),
        ('V_pm_PthplnrDiagPathCurrentCurvature_0', 32, float, 1, 0, False, True),
        ('V_1pm_CurvaturePredSelected', 32, float, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_20', 8, int, 1, 0, False, True),
        ('F_x_LinkPointIntersection', 1, bytes, 1, 0, False, True),
        ('F_x_LC_req_Driver_L', 1, bytes, 1, 0, False, True),
        ('F_x_LC_req_Driver_R', 1, bytes, 1, 0, False, True),
        ('F_x_LC_req_P2P_L', 1, bytes, 1, 0, False, True),
        ('F_x_LC_req_P2P_R', 1, bytes, 1, 0, False, True),
        ('fIVIRouteCurveSel', 1, bytes, 1, 0, False, True),
        ('F_x_MapHmi_Overhead_on_Route_1', 1, bytes, 1, 0, False, True),
        ('F_x_NoLaneIgnoreLeft', 1, bytes, 1, 0, False, True),
        ('V_x_OvertakeProhibit_0', 8, int, 1, 0, False, True),
        ('vCURV_NO', 8, int, 1, 0, False, True),
        ('V_mps_CaspExitTargetSpeed', 32, float, 1, 0, False, True),
        ('vACC_TAR_MIN', 32, float, 1, 0, False, True),
        ('vCURV_NO_0', 16, int, 1, 0, True),
        ('V_x_MapHmi_NumOfBranchLane_0', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_NumOfBranchLane_1', 8, int, 1, 0, False, True),
        ('V_pct_HDMAPCrossSlopeSel1', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPCrossSlopeSel2', 32, float, 1, 0, False, True),
        ('V_pct_HDMAPCrossSlopeSel3', 32, float, 1, 0, False, True),
        ('V_m_ycr_pre_l', 32, float, 1, 0, False, True),
        ('V_x_LCStateTemporalCounter', 16, int, 1, 0, False, True),
        ('V_m_Dist_to_Branch_togo', 16, int, 1, 0, False, True),
        ('V_x_Debug_LKAReadyCondition', 16, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_27', 8, int, 1, 0, False, True),
        ('V_x_PthPlnr_CurveInfo_r1_27', 8, int, 1, 0, False, True),
        ('V_m_DistToJCT', 32, float, 1, 0, False, True),
        ('V_pm_PthplnrDiagPathCurrentCurvature_1', 32, float, 1, 0, False, True),
        ('V_pm_PthplnrDiagPathCurrentCurvature_2', 32, float, 1, 0, False, True),
        ('V_pm_PthplnrDiagPathCurrentCurvature_3', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_0', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_1', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_2', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_3', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_4', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_5', 32, float, 1, 0, False, True),
        ('V_cm_PthPlnr_RouteLaneWidthSel_6', 32, float, 1, 0, False, True),
        ('F_x_NoLaneIgnoreRight', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAP_CntrlPointValid_r1_0', 1, bytes, 1, 0, False, True),
        ('F_x_HDMAP_CntrlPointValid_r1_1', 1, bytes, 1, 0, False, True),
        ('F_x_GotoExitLaneToLocal', 1, bytes, 1, 0, False, True),
        ('F_x_ConstructionArea', 1, bytes, 1, 0, False, True),
        ('F_x_HandsOnJdg_Confirm', 1, bytes, 1, 0, False, True),
        ('F_x_MT_MergeViewAreaControl2nd_SEL', 1, bytes, 1, 0, False, True),
        ('F_x_DriveHighwayPredACCNavi', 1, bytes, 1, 0, False, True),
        ('V_x_MapHmi_TypeEndMerge_SEL', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_Reliability_SEL_0', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_Reliability_SEL_1', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_Reliability2nd_SEL_0', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_Reliability2nd_SEL_1', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_IncLaneType', 8, int, 1, 0, False, True),
        ('V_x_MapHmi_DecLaneType', 8, int, 1, 0, False, True),
        ('V_m_MapHmi_Dist2NextReliability_0', 16, int, 1, 0, False, True),
        ('V_m_MapHmi_Dist2NextReliability_1', 16, int, 1, 0, False, True),
        ('V_m_MapHmi_DistToIncLane', 16, int, 1, 0, False, True),
        ('V_m_MapHmi_DistToDecLane', 16, int, 1, 0, False, True),
        ('ADAS_MonitoringData285', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData286', 32, int, 1, 0, False, True),
        ('vACC_COM_LMT', 32, float, 1, 0, False, True),
        ('V_m_CaspCurveRadiusArray_0', 16, int, 1, 0, True),
        ('F_x_locate_on_passing_lane', 1, bytes, 1, 0, False, True),
        ('Status_1150byte_bit1', 1, bytes, 1, 0, False, True),
        ('Status_1150byte_bit2', 1, bytes, 1, 0, False, True),
        ('Status_1150byte_bit3', 1, bytes, 1, 0, False, True),
        ('Status_1150byte_bit4', 1, bytes, 1, 0, False, True),
        ('Status_1150byte_bit5', 1, bytes, 1, 0, False, True),
        ('Status_1150byte_bit6', 1, bytes, 1, 0, False, True),
        ('Status_1150byte_bit7', 1, bytes, 1, 0, False, True),
        ('Status_1151byte', 8, int, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_2', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_3', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_4', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_5', 32, float, 1, 0, False, True),
        ('smDebugMapHppCorrected_diff_6', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_ThPosi', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_ThNega', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_0', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_1', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_2', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_3', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_4', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_5', 32, float, 1, 0, False, True),
        ('smDebugMapHppRaw_diff_6', 32, float, 1, 0, False, True),
        ('ADAS_MonitoringData303', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData304', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData305', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData306', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData307', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData308', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData309', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData310', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData311', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData312', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData313', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData314', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData315', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData316', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData317', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData318', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData319', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData320', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData321', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData322', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData323', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData324', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData325', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData326', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData327', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData328', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData329', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData330', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData331', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData332', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData333', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData334', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData335', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData336', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData337', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData338', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData339', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData340', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData341', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData342', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData343', 32, int, 1, 0, False, True),
        ('ADAS_MonitoringData344', 32, int, 1, 0, False, True),
        ('VehStatus_Out_ver', 32, int, 1, 0, False, True),
        ('AURIXver', 32, int, 1, 0, False, True),
        ('RCARver', 32, int, 1, 0, False, True),
        ]

    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data, useCommonHeader = False)
        self.version = int.from_bytes(self.data.dataBuf[12+1376:12+1380], 'big', signed=False) + 1 # VehStatus_Out_ver + 1
        
    def parse(self, oldMessage = None):
        # ver4からは暗号化されているため、まず複合化
        if self.version >= 4:
            dataBufArray = bytearray(self.data.dataBuf)
            NUM_OF_KEY = 4
            iKeyTbl = [0x45C0A6B9, 0x5FA63BCF, 0x17637681, 0xC3303A82]
            for i in range(344):
                index = 12 + i*4
                temp = int.from_bytes(self.data.dataBuf[index:index+4], 'big', signed=False)
                if temp == 0:
                    continue
                keyIdx = int((i * 121) / 7)
                if temp == iKeyTbl[keyIdx & (NUM_OF_KEY - 1)]:
                    continue
                temp = temp ^ iKeyTbl[keyIdx & (NUM_OF_KEY - 1)]
                dataBufArray[index+0] = (temp >> 24) & 0xFF
                dataBufArray[index+1] = (temp >> 16) & 0xFF
                dataBufArray[index+2] = (temp >> 8) & 0xFF
                dataBufArray[index+3] = (temp) & 0xFF
            self.data.dataBuf = bytes(dataBufArray)
        # 解析開始
        super().parse(oldMessage)
        # データサイズと解析した数が一致するかチェック
        self.assertMessageSize()
                
    @classmethod
    def GetFieldNameList(cls, self = None):
        if self == None:
            return cls.FieldNameList_ver6
        
        if self.version == 6:
            return cls.FieldNameList_ver6
        elif self.version == 5:
            return cls.FieldNameList_ver5
        elif self.version == 4 or self.version == 3:
            return cls.FieldNameList_ver3_ver4
        elif self.version == 2:
            return cls.FieldNameList_ver2
#         elif self.version == 0:
#             return cls.FieldNameList_ver1
        else:
            return cls.FieldNameList_ver6
        
     
#-----------------------------------------------#
#----   (CAN) CAN_IVI_A5_SatelliteGPSNumber ----#
#-----------------------------------------------#
class CAN_IVI_A5_SatelliteGPSNumber(Template_Default_Message_WithDraw):
    FieldNameList = [
        ('', 24, int, 1, 0),
        ('VehicleGPSreliability', 7, int, 1, 0),
        ('', 17, int, 1, 0),
        ('SatelliteGPSNumber', 7, int, 1, 0),
        ('', 9, int, 1, 0),
    ]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        
    @classmethod
    def GetFieldNameList(cls, self = None):
        return cls.FieldNameList

    
#-----------------------------------------------#
#----   (CAN) CAN_IVI_A5_SatelliteGPSNumber ----#
#-----------------------------------------------#
class CAN_IVI_A105_GPSPosition(Template_Default_Message_WithDraw):
    FieldNameList = [
        ('GPS_LongitudePosition', 29, int, 0.000001, -180.0),
        ('', 3, int, 1, 0),
        ('GPS_LatitudePosition', 28, int, 0.000001, -90.0),
        ('', 4, int, 1, 0),
    ]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        
    @classmethod
    def GetFieldNameList(cls, self = None):
        return cls.FieldNameList
    
    def getLonLat(self):
        lat = self.GPS_LatitudePosition
        lon = self.GPS_LongitudePosition
        return [lon, lat]
    
    def getLonLatZ(self, withBearing = False):
        lat = self.GPS_LatitudePosition
        lon = self.GPS_LongitudePosition
        return [lon, lat, 0.0]
    
    def createLayer(self, name, iface_obj, realTimeMode):
        newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=Longitude:double&field=Latitude:double&index=yes',name,'memory')
        newLayer = self.SetLayerStyle(self.LayerType.DefaultLine, newLayer)
        return [newLayer]
    
    def drawQGIS(self, layerList, realTimeMode):
        layer = None
        for layerListItem in layerList:
            if layerListItem[1] == self.LayerType.DefaultLine.value:
                layer = layerListItem[0]

        old = self.oldMessage
        if old == None:
            return
        
        if layer != None:
            [lon, lat] = self.getLonLat()
            [oldLon, oldLat] = old.getLonLat()
            
            if checkInvalidLonLat(lon, lat, oldLon, oldLat) == True:
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)]))
                feature.setAttributes([QDateTime(self.commonHeader.logTime), lon, lat])
                layer.dataProvider().addFeatures( [feature] )

    
#-----------------------------------------------#
#----   (CAN) CAN_VDC_A117SC_Sensor         ----#
#-----------------------------------------------#
class CAN_VDC_A117SC_Sensor(Template_Default_Message):
    FieldNameList = [
        ('', 80, bytes, 1, 0), #VDC_A10
        ('', 96, bytes, 1, 0), #VDC_A12
        ('', 48, bytes, 1, 0), #VDC_A5 Head
        ('LongitudinalAccelCorrected', 12, int, 0.001, -2),
        ('', 36, bytes, 1, 0), #VDC_A5 remain
        ('', 80, bytes, 1, 0), #VDC_A6 Head
        ('YawRateRaw', 11, int, 0.1, -100),
        ('', 5, bytes, 1, 0), #VDC_A6 remain
        ('', 144, bytes, 1, 0), #remain
    ]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)

    @classmethod
    def GetFieldNameList(cls, self = None):
        return cls.FieldNameList 
    
    
#-----------------------------------------------#
#----   (CAN) CAN_DMC_A01C_FD               ----#
#-----------------------------------------------#
class CAN_DMC_A01C_FD(Template_Default_Message):
    FieldNameList = [
        ('', 24, bytes, 1, 0), #Head
        ('DLC_DMC_A102', 8, bytes, 1, 0),
        ('CRC_DMC_A102', 8, bytes, 1, 0),
        ('Clock_DMC_A102', 4, bytes, 1, 0),
        ('EyeDetection_Left', 2, int, 1, 0),
        ('EyeDetection_Right', 2, int, 1, 0),
        ('HeadDetection_Pitch', 8, int, 1, -90),
        ('HeadDirection_Rol', 8, int, 1, -90),
        ('HeadDirection_Yaw', 8, int, 1, -90),
        ('LaneChange_Confirmation', 2, bytes, 1, 0),
        ('HornPad_Detected', 1, bytes, 1, 0),
        ('Dust_Detected', 1, bytes, 1, 0),
        ('NumberOfPeople_Detected', 1, bytes, 1, 0),
        ('Obstacle_Detected', 1, bytes, 1, 0),
        ('Saturation_Detected', 1, bytes, 1, 0),
        ('', 1, bytes, 1, 0), #reserve
        ('Failure_Detected', 8, bytes, 1, 0),
        ('AsleepCondition_Detected', 8, bytes, 1, 0),
        ('', 24, bytes, 1, 0), #Head
        ('DLC_DMC_A105', 8, bytes, 1, 0),
        ('CRC_DMC_A105', 8, bytes, 1, 0),
        ('Clock_DMC_A105', 4, bytes, 1, 0),
        ('', 4, bytes, 1, 0), #reserve
        ('HeadDetection', 8, bytes, 1, 0),
        ('', 40, bytes, 1, 0), #remain
    ]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)

    @classmethod
    def GetFieldNameList(cls, self = None):
        return cls.FieldNameList 
        
        
#-----------------------------------------------#
#----   (CAN) ADAS_GlobalTimeStamp          ----#
#-----------------------------------------------#
class CAN_ADAS_GlobalTimeStamp(Template_Default_Message):
    FieldNameList = [
        ('Type', 8, int, 1, 0),
        ('CRC', 8, int, 1, 0),
        ('TimeDomain', 4, int, 1, 0),
        ('SequenceCounter', 4, int, 1, 0),
        ('', 5, int, 1, 0),
        ('SGW', 1, int, 1, 0),
        ('OverflowOfSeconds', 2, int, 1, 0),
        ('SyncTime', 32, int, 1, 0),
        ('Unity', 0, int, 1, 0),
    ]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        
        valList = []
        
        if self.Type == 0x20: valList.append('(0x20) MUX value for SYNC')
        elif self.Type == 0x28: valList.append('(0x28) MUX value for FUP layout')
        else: valList.append('(0x{}) Unknown'.format(hex(self.Type)))
        
        valList.append(hex(self.CRC))
        valList.append(self.TimeDomain)
        valList.append(self.SequenceCounter)
        
        if self.SGW: valList.append('(0b1) SyncToSubDomain')
        else: valList.append('(0b0) SyncToGTM')
        
        valList.append(self.OverflowOfSeconds)
        valList.append(self.SyncTime)
        
        if self.Type == 0x20: valList.append('[s]')
        elif self.Type == 0x28: valList.append('[ns]')
        else: valList.append('[-]')
        
        sheet.write_row(row, col, valList)
        
        return  [row+1, 0, []]

    @classmethod
    def GetFieldNameList(cls, self = None):
        return cls.FieldNameList 
        
        
#-----------------------------------------------#
#----   Navi_Status_ADAS                    ----#
#-----------------------------------------------#
class Navi_Status_ADAS(Template_Default_Message_WithDraw):
    FieldNameList = [
        ('DistanceBeforeNextAction', 40, bytes, 1, 0),
        ('UnitDistanceBeforeNextAction', 4, int, 1, 0),
        ('TrailerLightCheck_Request2', 2, int, 1, 0),
        ('NAVI_UseHOVLanes', 1, int, 1, 0),
        ('NAVI_HOVLanesOnRoadFlag', 1, int, 1, 0),
        ('NavigationIconFailureMode', 3, int, 1, 0),
        ('MMI_MultimediaState', 3, int, 1, 0),
        ('LivingLightReq', 2, int, 1, 0),
        ('NAVI_OperationError', 1, int, 1, 0),
        ('NAVI_BootStatus', 1, int, 1, 0),
        ('RR_FOG_RequestbyVoice', 2, int, 1, 0),
        ('PhoneIncomingStatus', 1, int, 1, 0),
        ('', 3, int, 1, 0)
    ]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
    
    @classmethod
    def GetFieldNameList(cls, self = None):
        return cls.FieldNameList
    
    
#-----------------------------------------------#
#----   CAN MESSAGE                         ----#
#-----------------------------------------------#
class CAN_Message(Template_Default_Message):
    FieldNameList = [
        ('data0', 8, int, 1, 0),
        ('data1', 8, int, 1, 0),
        ('data2', 8, int, 1, 0),
        ('data3', 8, int, 1, 0),
        ('data4', 8, int, 1, 0),
        ('data5', 8, int, 1, 0),
        ('data6', 8, int, 1, 0),
        ('data7', 8, int, 1, 0)
    ]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    @classmethod
    def GetFieldNameList(cls, self = None):
        return cls.FieldNameList
        
#-----------------------------------------------#
#----   CAN FD MESSAGE                      ----#
#-----------------------------------------------#
class CANFD_Message(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    def parse(self, oldMessage = None):
        self.canDataArray = self.data.dataBuf[self.data.seek():]

    def printHeader(self, sheet, row, col, _level = 1):
        [_, col, _] = self.commonHeader.printHeader(sheet, row, col)
        
        sheet.write_row(row, col, ['Data'], sheet.cellFormats('header'))
        #col += 1
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        sheet.write_row(row, col, [hex(x) for x in self.canDataArray])
        
        return  [row+1, 0, []]    
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
        
#-----------------------------------------------#
#----   CAN_CARTO_R1                        ----#
#-----------------------------------------------#
class CAN_CARTO_R1(Message):
    OldMessageTable = {}
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        self.ADASISinfo = ADASISinfoManager.getADASISinfo_forFrCamera()
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.msgType = readFunc(int,3)
        if self.msgType == 1: #Position
            self.Offset = readFunc(int,13)
            self.CyclicCounter = readFunc(int,2)
            self.PathIndex = readFunc(int,6)
            self.PositionIndex = readFunc(int,2)
            self.PositionProbablility = readFunc(int,5) 
            self.PositionAge = readFunc(int,9)
            readFunc(int,1) #reserved
            self.PositionConfidence = readFunc(int,3)
            self.PositionCurLane = readFunc(int,3)
            self.Speed = readFunc(int,9)
            self.RelativeHeading = readFunc(int,8)
            self.longitude = 180
            self.latitude = 180
            self.latestAvailableLonLat = [180, 180]
            
            self.ADASISinfo.setCurrentPosition(self.PathIndex, self.Offset)
            self.ADASISinfo_getLonLat = self.ADASISinfo.getLonLat(self.PathIndex, self.Offset)
            self.ADASISinfo_adjustOffset = self.ADASISinfo.adjustOffset(self.PathIndex, self.Offset)
            
        elif self.msgType == 2: #Segment
            self.AD2flag = 0
            self.SpeedUnits = 0
            self.Offset = readFunc(int,13)
            self.CyclicCounter = readFunc(int,2)
            self.PathIndex = readFunc(int,6)
            self.Tunnel = readFunc(int,2)
            self.Bridge = readFunc(int,2)
            self.BuildUpArea = readFunc(int,2)
            self.Retransmission = readFunc(int,1)
            self.Update = readFunc(int,1)
            self.RelativeProbability = readFunc(int,5)
            self.FunctionalRoadClass = readFunc(int,3)
            self.PartOfCalculatedRoute = readFunc(int,2)
            self.ExpresswayFlag = 0
            self.ComplexIntersection = readFunc(int,2)
            self.FormOfWay = readFunc(int,4)
            self.EffectiveSpeedLimit = readFunc(int,5)
            self.EffectiveSpeedLimitType = readFunc(int,3)
            readFunc(int,1) #reserve
            self.DividedRoad = readFunc(int,2)
            self.NumberOfLanesOppdirection = readFunc(int,2)
            self.NumberOfLanesInDrivingDirection = readFunc(int,3)
            
            self.ADASISinfo_getLonLat = self.ADASISinfo.getLonLat(self.PathIndex, self.Offset) 
            self.ADASISinfo_getLonLat_StubLine = self.ADASISinfo.getLonLat_StubLine(self.PathIndex, 0, self.Offset)
            self.ADASISinfo_adjustOffset = self.ADASISinfo.adjustOffset(self.PathIndex, self.Offset)

        elif self.msgType == 3: #Stub
            self.LastStubAtOffset = 0
            self.ReroutingFlag = 0
            self.Offset = readFunc(int,13)
            self.CyclicCounter = readFunc(int,2)
            self.PathIndex = readFunc(int,6)
            self.SubPathIndex = readFunc(int,6)
            self.Retransmission = readFunc(int,1)
            self.Update = readFunc(int,1)
            self.RelativeProbability = readFunc(int,5)
            self.FunctionalRoadClass = readFunc(int,3)
            self.PartOfCalculatedRoute = readFunc(int,2)
            self.ExpresswayFlag = 0
            self.ComplexIntersection = readFunc(int,2)
            self.FormOfWay = readFunc(int,4)
            self.TurnAngle = readFunc(int,8)
            self.LastStubAtOffset = readFunc(int,1)
            self.RightOfWay = readFunc(int,2)
            self.NumberOfLanesOppdirection = readFunc(int,2)
            self.NumberOfLanesInDrivingDirection = readFunc(int,3)
            
            if self.PathIndex == 0:
                self.ADASISinfo.reset()
            elif self.PathIndex >= 8:
                self.ADASISinfo.setStub(self.PathIndex, self.Offset, self.SubPathIndex, self.TurnAngle)
                self.ADASISinfo_getLonLat_StubLine = self.ADASISinfo.getLonLat_StubLine(self.PathIndex, self.SubPathIndex, self.Offset)
            self.ADASISinfo_adjustOffset = self.ADASISinfo.adjustOffset(self.PathIndex, self.Offset)
            
        elif self.msgType == 4: #PS
            return
        
        elif self.msgType == 5: #PL
            self.Offset = readFunc(int,13)
            self.CyclicCounter = readFunc(int,2)
            self.PathIndex = readFunc(int,6)
            self.ProfileType = readFunc(int,5)
            self.ControlPoint = readFunc(int,1)
            self.Retransmission = readFunc(int,1)
            self.Update = readFunc(int,1)
            self.Value = readFunc(int,32)
            
            if (self.ProfileType == 1 or self.ProfileType == 2) and self.Offset < 8191 and self.Retransmission == 1:
                self.ADASISinfo.setReceivedPLcount(self.ProfileType, self.PathIndex, self.Offset)
                            
            if self.ProfileType == 1:
                self.ADASISinfo.addLongitudeInfo(self.PathIndex, self.Offset, (self.Value * 0.0000001) - 180.0)
            elif self.ProfileType == 2:
                self.ADASISinfo.addLatitudeInfo(self.PathIndex, self.Offset, (self.Value * 0.0000001) - 90.0)
            elif self.ProfileType == 25 or self.ProfileType == 26:
                #RoadBearingPart = (self.Value & 0xF0000000) >> 24
                latlon = (self.Value & 0x0FFFFFF0) >> 4
                (refLon, refLat) = self.ADASISinfo.getLonLat(self.PathIndex, self.Offset)
                if self.ProfileType == 25:
                    if math.fabs(refLon - latlon) < 1:
                        self.ADASISinfo.addLongitudeInfo(self.PathIndex, self.Offset, (latlon * 360.0 / (0xFFFFFF-2)) - 180.0)
                elif self.ProfileType == 26:
                    if math.fabs(refLat - latlon) < 1:
                        self.ADASISinfo.addLatitudeInfo(self.PathIndex, self.Offset, (latlon * 360.0 / (0xFFFFFF-2)) - 90.0)
                        
            self.ADASISinfo_getLonLat = self.ADASISinfo.getLonLat(self.PathIndex, self.Offset)
            self.ADASISinfo_adjustOffset = self.ADASISinfo.adjustOffset(self.PathIndex, self.Offset)
            
        elif self.msgType == 6: #MetaData
            self.MapProvider = readFunc(int,3)
            self.CountryCode = readFunc(int,10)
            self.CyclicCounter = readFunc(int,2)
            self.MajorProtocolVersion = readFunc(int,2)
            self.MinorProtocolSubVersion = readFunc(int,3)
            self.HardwareVersion = readFunc(int,9)
            self.DrivingSide = readFunc(int,1)
            self.RegionCode = readFunc(int,15)
            self.MapVersionYearQuarter = readFunc(int,2)
            self.MapVersionYear = readFunc(int,6)
            readFunc(int,3) #Reserve
            self.SpeedUnits = readFunc(int,1)
            self.MinorProtocolVersion = readFunc(int,4)
            
        else:
            return
            
        self.assertMessageSize()

    def printHeader(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printHeader(sheet, row, col+1)
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, 40)
        return  [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):        
        if self.msgType == 1: #Position
            sheet.write(row, col, '=PrintHead("CARTO Position")')
            [row, col, _] = self.commonHeader.printValue(sheet, row, col+1)
            sheet.write_row(row, col, [
                (self.Offset),
                (self.CyclicCounter),
                (self.PathIndex),
                (self.PositionIndex),
                (self.PositionProbablility),
                (self.PositionAge),
                (self.PositionConfidence),
                (self.PositionCurLane),
                (self.Speed),
                (self.RelativeHeading)])
        elif self.msgType == 2: #Segment
            sheet.write(row, col, '=PrintHead("CARTO Segment")')
            [row, col, _] = self.commonHeader.printValue(sheet, row, col+1)
            sheet.write_row(row, col, [
                (self.Offset),
                (self.CyclicCounter),
                (self.PathIndex),
                (self.Tunnel),
                (self.Bridge),
                (self.BuildUpArea),
                (self.Retransmission),
                (self.Update),
                (self.RelativeProbability),
                (self.FunctionalRoadClass),
                (self.PartOfCalculatedRoute),
                (self.ComplexIntersection),
                (self.FormOfWay),
                (self.EffectiveSpeedLimit),
                (self.EffectiveSpeedLimitType),
                (self.DividedRoad),
                (self.NumberOfLanesOppdirection),
                (self.NumberOfLanesInDrivingDirection)])
        elif self.msgType == 3: #Stub
            sheet.write(row, col, '=PrintHead("CARTO Stub")')
            [row, col, _] = self.commonHeader.printValue(sheet, row, col+1)
            sheet.write_row(row, col, [
                (self.Offset),
                (self.CyclicCounter),
                (self.PathIndex),
                (self.SubPathIndex),
                (self.Retransmission),
                (self.Update),
                (self.RelativeProbability),
                (self.FunctionalRoadClass),
                (self.PartOfCalculatedRoute),
                (self.ComplexIntersection),
                (self.FormOfWay),
                (self.TurnAngle),
                (self.LastStubAtOffset),
                (self.RightOfWay),
                (self.NumberOfLanesOppdirection),
                (self.NumberOfLanesInDrivingDirection)])
        elif self.msgType == 4: #PS
            sheet.write(row, col, '=PrintHead("CARTO Profile Short")')
            [row, col, _] = self.commonHeader.printValue(sheet, row, col+1)
        elif self.msgType == 5: #PL
            sheet.write(row, col, '=PrintHead("CARTO Profile Long")')
            [row, col, _] = self.commonHeader.printValue(sheet, row, col+1)
            sheet.write_row(row, col, [
                (self.Offset),
                (self.CyclicCounter),
                (self.PathIndex),
                (self.ProfileType),
                (self.ControlPoint),
                (self.Retransmission),
                (self.Update),
                hex(self.Value)])
        elif self.msgType == 6: #MetaData
            sheet.write(row, col, '=PrintHead("CARTO MetaData")')
            [row, col, _] = self.commonHeader.printValue(sheet, row, col+1)
            sheet.write_row(row, col, [
                (self.MapProvider),
                (self.CyclicCounter),
                (self.CountryCode),
                (self.MajorProtocolVersion),
                (self.MinorProtocolSubVersion),
                (self.HardwareVersion),
                (self.DrivingSide),
                (self.RegionCode),
                (self.MapVersionYearQuarter),
                (self.MapVersionYear),
                (self.SpeedUnits),
                (self.MinorProtocolVersion)])
        else:
            sheet.write(row, col, '=PrintHead("CARTO Unknown({})")'.format(self.msgType))
            [row, col, _] = self.commonHeader.printValue(sheet, row, col+1)
        
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if getADASISanalyze() == False:
            return None
        if (realTimeMode == DrawMode.QGIS_RealTimeDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw):
            return None
        
        layerList = []
        layerList += ADASISv2POSITION.createLayer(ADASISv2POSITION, "(CAN) FrCamera ADASISv2 POSITION", iface_obj, realTimeMode)
        layerList += ADASISv2SEGMENT.createLayer(ADASISv2SEGMENT, "(CAN) FrCamera ADASISv2 SEGMENT", iface_obj, realTimeMode)
        layerList += ADASISv2STUB.createLayer(ADASISv2STUB, "(CAN) FrCamera ADASISv2 STUB", iface_obj, realTimeMode)
        layerList += ADASISv2PROFILELONG.createLayer(ADASISv2PROFILELONG, "(CAN) FrCamera ADASISv2 PROFILELONG", iface_obj, realTimeMode)

        return layerList
    
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        if getADASISanalyze() == False:
            return
        if (realTimeMode == DrawMode.QGIS_RealTimeDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw):
            return
        
        if self.msgType in CAN_CARTO_R1.OldMessageTable:
            self.oldMessage = CAN_CARTO_R1.OldMessageTable[self.msgType]
        else:
            self.oldMessage = None
            
        if self.msgType == 1: #Position
            if self.oldMessage != None:
                if self.oldMessage.Offset > self.Offset:
                    distance = self.Offset + 8191 - self.oldMessage.Offset
                else:
                    distance = self.Offset - self.oldMessage.Offset
                if distance > 150:
                    self.ADASISinfo.reset()
            
            curPosAdjusted = False
            if curPosAdjusted == False and self.relatedIVIPositionMessage != None: #FrCamera向けのPLのMPP緯度・経度は、頻度が少ないため、描画にはほぼ活用できない。IVIの自車位置緯度経度情報か、AD1e/AD2向けのADASIS Positionメッセージを使いようにする。
                [lon, lat] = self.relatedIVIPositionMessage.getLonLat()
                if checkInvalidLonLat(lon, lat) == True:
                    self.ADASISinfo.addLongitudeInfo(self.PathIndex, self.Offset, lon)
                    self.ADASISinfo.addLatitudeInfo(self.PathIndex, self.Offset, lat)
                    curPosAdjusted = True
            if curPosAdjusted == False and self.relatedADASISPositionMessage != None:
                [lon, lat] = self.relatedADASISPositionMessage.getLonLat()
                if checkInvalidLonLat(lon, lat) == True:
                    self.ADASISinfo.addLongitudeInfo(self.PathIndex, self.Offset, lon)
                    self.ADASISinfo.addLatitudeInfo(self.PathIndex, self.Offset, lat)
                    curPosAdjusted = True
                    
            ADASISv2POSITION.drawQGIS(self, layerList, realTimeMode)
        elif self.msgType == 2: #Segment
            if self.Offset != 0:
                ADASISv2SEGMENT.drawQGIS(self, layerList, realTimeMode)
        elif self.msgType == 3: #Stub
            ADASISv2STUB.drawQGIS(self, layerList, realTimeMode)
        elif self.msgType == 5: #PL
            ADASISv2PROFILELONG.drawQGIS(self, layerList, realTimeMode)
            
        CAN_CARTO_R1.OldMessageTable[self.msgType] = self
        
    def drawStubinfo(self, targetLayer, old, *args):
        ADASISv2STUB.drawStubinfo(self, targetLayer, old, *args)
        
        
#-----------------------------------------------#
#----   Road_Data_4_ADAS                    ----#
#-----------------------------------------------#
class Road_Data_4_ADAS(Message):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        self.NAVI_DistanceToBranch = readFunc(int,8)
        self.NAVI_CurveDirection = readFunc(int,5)
        self.NAVI_BranchDirection = readFunc(int,2)
        self.NAVI_BranchMultipleInfo = readFunc(int,1)
        self.NAVI_DistanceToLinkFailure = readFunc(int,5)
        self.NAVI_MatchingReset = readFunc(int,1)
        self.NAVI_Matching_Status = readFunc(int,1)
        self.NaviGPS_PositioningStatus = readFunc(int,1)
        self.NAVI_LinkFailurePoint = readFunc(int,5)
        self.NAVI_CurvatureError = readFunc(int,1)
        self.NAVI_TurningStatus = readFunc(int,1)
        self.NAVI_LinkFailure = readFunc(int,1)
        self.NAVI_DistanceToIntersection = readFunc(int,6)
        self.ProbeClear = readFunc(int,1)
        self.ProbeUpload = readFunc(int,1)
        self.NAVI_DirectionDifference = readFunc(int,4)
        self.Current_Roadtype = readFunc(int,3)
        self.InGuidingRoute = readFunc(int,1)
        self.DistanceToTollgate = readFunc(int,6)
        self.RoadData_UpdateCounter4 = readFunc(int,2)
        self.Current_Linktype = readFunc(int,3)
        self.RouteGuiding_flag = readFunc(int,1)
        readFunc(int,4) # reserved
        self.assertMessageSize()

    def printHeader(self, sheet, row, col, _level = 1):
        [_, col, _] = self.commonHeader.printHeader(sheet, row, col)
        
        sheet.write_row(row, col, [
            'NAVI_DistanceToBranch',
            'NAVI_CurveDirection',
            'NAVI_BranchDirection',
            'NAVI_BranchMultipleInfo',
            'NAVI_DistanceToLinkFailure',
            'NAVI_MatchingReset',
            'NAVI_Matching_Status',
            'NaviGPS_PositioningStatus',
            'NAVI_LinkFailurePoint',
            'NAVI_CurvatureError',
            'NAVI_TurningStatus',
            'NAVI_LinkFailure',
            'NAVI_DistanceToIntersection',
            'ProbeClear',
            'ProbeUpload',
            'NAVI_DirectionDifference',
            'Current_Roadtype',
            'InGuidingRoute',
            'DistanceToTollgate',
            'RoadData_UpdateCounter4',
            'Current_Linktype',
            'RouteGuiding_flag'], sheet.cellFormats('header'))
        col += 22
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        
        sheet.write_row(row, col, [
            (self.NAVI_DistanceToBranch),
            (self.NAVI_CurveDirection),
            (self.NAVI_BranchDirection),
            (self.NAVI_BranchMultipleInfo),
            (self.NAVI_DistanceToLinkFailure),
            (self.NAVI_MatchingReset),
            (self.NAVI_Matching_Status),
            (self.NaviGPS_PositioningStatus),
            (self.NAVI_LinkFailurePoint),
            (self.NAVI_CurvatureError),
            (self.NAVI_TurningStatus),
            (self.NAVI_LinkFailure),
            (self.NAVI_DistanceToIntersection),
            (self.ProbeClear),
            (self.ProbeUpload),
            (self.NAVI_DirectionDifference),
            (self.Current_Roadtype),
            (self.InGuidingRoute),
            (self.DistanceToTollgate),
            (self.RoadData_UpdateCounter4),
            (self.Current_Linktype),
            (self.RouteGuiding_flag)])
        
        return  [row+1, 0, []]
    
    def drawChart(self, book, sheet, totalRows): 
        self.commonHeader.drawChart(book, sheet, totalRows)
        
    class LayerType(Enum):
        Road_Link_Type = 40
    
    @classmethod
    def SetLayerStyle(cls, layerType, layer):
        if layerType == cls.LayerType.Road_Link_Type:
            symbolDic = {
                '':(QtGui.QColor.fromRgb(0,0,0),'All', 0.4),
                
                '"Roadtype" = 0':(QtGui.QColor.fromRgb(124,55,70),'[R0] Interstate Highway', 0.4),
                '"Roadtype" = 1':(QtGui.QColor.fromRgb(124,110,70),'[R1] Highway with AD2 (Domestic Highway)', 0.4),
                '"Roadtype" = 2':(QtGui.QColor.fromRgb(124,200,70),'[R2] State Highway with AD2 (Toll Road)', 0.4),
                '"Roadtype" = 3':(QtGui.QColor.fromRgb(124,55,140),'[R3] Highway without AD2 (National Road)', 0.4),
                '"Roadtype" = 4':(QtGui.QColor.fromRgb(124,110,140),'[R4] State Highway without AD2 (Prefectual Road)', 0.4),
                '"Roadtype" = 5':(QtGui.QColor.fromRgb(124,200,140),'[R5] Main Local Road', 0.4),
                '"Roadtype" = 6':(QtGui.QColor.fromRgb(124,55,200),'[R6] General Road', 0.4),
                '"Roadtype" = 7':(QtGui.QColor.fromRgb(124,110,200),'[R7] Other Road', 0.4),
                
                '"Linktype" = 0':(QtGui.QColor.fromRgb(204,55,70),'[L0] Non-Divided', 0.4),
                '"Linktype" = 1':(QtGui.QColor.fromRgb(204,110,70),'[L1] Divided', 0.4),
                '"Linktype" = 2':(QtGui.QColor.fromRgb(204,200,70),'[L2] Non-Divided Ramp (Junction)', 0.4),
                '"Linktype" = 3':(QtGui.QColor.fromRgb(204,55,140),'[L3] Divided Ramp (Ramp)', 0.4),
                '"Linktype" = 4':(QtGui.QColor.fromRgb(204,110,140),'[L4] Parallel Road', 0.4),
                '"Linktype" = 5':(QtGui.QColor.fromRgb(204,200,140),'[L5] PA/SA', 0.4),
                '"Linktype" = 6':(QtGui.QColor.fromRgb(204,55,200),'[L6] Rotary', 0.4),
                '"Linktype" = 7':(QtGui.QColor.fromRgb(204,110,200),'[L7] Other Link', 0.4)}
            layer = myQgsRendererRuleLayer(layer, symbolDic)
            return [layer, layerType.value]
        
        else:
            return None
    
    def createLayer(self, name, iface_obj, realTimeMode = DrawMode.FullDraw):
        if (realTimeMode == DrawMode.QGIS_RealTimeDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw):
            return None
        
        newLayer = iface_obj.addVectorLayer('LineString?crs=epsg:4612&field=Time:DateTime&field=PositioningStatus:int&field=CurvatureError:int&field=ProbeClear:int&field=ProbeUpload:int&field=Roadtype:int&field=Linktype:int&field=RouteGuiding_flag:int&index=yes',name,'memory')
        newLayer = self.SetLayerStyle(self.LayerType.Road_Link_Type, newLayer)
        return [newLayer]
    
    def drawQGIS(self, layerList, realTimeMode = DrawMode.FullDraw):
        if (realTimeMode == DrawMode.QGIS_RealTimeDraw or realTimeMode == DrawMode.OpenGL_RealTimeDraw):
            return
        
        layer = None
        for layerListItem in layerList:
            if layerListItem[1] == Road_Data_4_ADAS.LayerType.Road_Link_Type.value:
                layer = layerListItem[0]
            
        if layer == None:
            return
        old = self.oldMessage
        if old == None:
            return
        
        [lon, lat] = self.getRelatedPosition([self.relatedIVIPositionMessage, self.relatedADASISPositionMessage, self.relatedCarPositionMessage])
        [oldLon, oldLat] = old.getRelatedPosition([old.relatedIVIPositionMessage, old.relatedADASISPositionMessage, old.relatedCarPositionMessage])
        if checkInvalidLonLat(lon, lat, oldLon, oldLat) == True:
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolyline([QgsPoint(oldLon, oldLat), QgsPoint(lon, lat)]))
            feature.setAttributes([QDateTime(self.commonHeader.logTime), 
                                   (self.NaviGPS_PositioningStatus),
                                   (self.NAVI_CurvatureError),
                                   (self.ProbeClear),
                                   (self.ProbeUpload),
                                   (self.Current_Roadtype),
                                   (self.Current_Linktype),
                                   (self.RouteGuiding_flag)])
            layer.dataProvider().addFeatures( [feature] )


#-----------------------------------------------#
#----   Road_Data_4_ADAS_ETH                ----#
#-----------------------------------------------#
class Road_Data_4_ADAS_ETH(Road_Data_4_ADAS):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        
        
#-----------------------------------------------#
#----   Road_Data_4_ADAS_CAN                ----#
#-----------------------------------------------#
class Road_Data_4_ADAS_CAN(Road_Data_4_ADAS):
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)


#-----------------------------------------------#
#----         (CAN) FRCAMERA_A2             ----#
#-----------------------------------------------#
class CAN_FRCAMERA_A2(Template_Default_Message):
    FieldNameList = [
        ('', 3, int, 1, 0),
        ('SpeedLimitType', 4, int, 1, 0),
        ('OverSpeedWarningSound', 1, int, 1, 0),
        ('OSPConvertedSpeedDisplayRequest', 1, int, 1, 0),
        ('RainSymbolDisplayRequest', 1, int, 1, 0),
        ('LDW_StopAlertRequest', 1, int, 1, 0),
        ('', 2, int, 1, 0),
        ('TSR_OSP_SubsignZone2', 3, int, 1, 0),
        ('TSR_OSP_SpeedSignalZone1', 8, int, 1, 0),
        ('TSR_OSP_SpeedSignalZone2', 8, int, 1, 0),
        ('TSR_OSP_TrafficSignZone3', 5, int, 1, 0),
        ('TSR_OSP_SubsignZone1', 3, int, 1, 0),
        ('OSPOverSpeedDisplayRequest', 1, int, 1, 0),
        ('TSR_OSP_SubsignZone3', 3, int, 1, 0),
        ('OSPDisplayRequest', 1, int, 1, 0),
        ('TSR_OSP_ActivationStatus', 2, int, 1, 0),
        ('CamFrontDefrostRequest', 1, int, 1, 0),
        ('', 6, int, 1, 0),
        ('TSR_OSP_FailureDisplay', 2, int, 1, 0),
        ('TSR_OSP_TypeSignalZone1', 1, int, 1, 0),
        ('TSR_OSP_TypeSignalZone2', 1, int, 1, 0),
        ('', 6, int, 1, 0)
    ]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)        
    
    @classmethod
    def GetFieldNameList(cls, self = None):
        return cls.FieldNameList
        
        
#-----------------------------------------------#
#----   (CAN) VDC_A116_WheelPulse           ----#
#-----------------------------------------------#
class VDC_A116_WheelPulse(Template_Default_Message):
    FieldNameList = [
        ('', 104, bytes, 1, 0),
        ('WheelSpeedRL', 16, int, 1.0/24.0, 0),
        ('WheelSpeedRR', 16, int, 1.0/24.0, 0),
        ('', 48, bytes, 1, 0),
        ('WheelTopFL', 8, int, 1.0/2.0, 0),
        ('WheelTopFR', 8, int, 1.0/2.0, 0),
        ('WheelTopRL', 8, int, 1.0/2.0, 0),
        ('WheelTopRR', 8, int, 1.0/2.0, 0),
        ('WheelDirectionRL', 2, int, 1, 0),
        ('WheelDirectionRR', 2, int, 1, 0),
        ('', 12, bytes, 1, 0),
        ('WheelDirectionFL', 2, int, 1, 0),
        ('WheelDirectionFR', 2, int, 1, 0),
        ('', 44, bytes, 1, 0),
        ('WheelSpeedFR', 16, int, 1.0/24.0, 0),
        ('WheelSpeedFL', 16, int, 1.0/24.0, 0),
        ('VehicleSpeed', 16, int, 1.0/100.0, 0),
        ('', 184, bytes, 1, 0),
    ]
    
    def __init__(self, index, time, definitionID, data):
        super().__init__(index, time, definitionID, data)
        
    @classmethod
    def GetFieldNameList(cls, self = None):
        return cls.FieldNameList
    
    
#-----------------------------------------------#
#----   (ADAS-FrCamera) DataForEyeQ         ----#
#-----------------------------------------------#
class DataForEyeQ(Message):
    def __init__(self, index, time, definitionID, data):
        #これはMAPECU-FrCamera間のメッセージであるため、E2E Header(12byte)を除去し、疑似Common Headerをつける
        data = struct.pack('>I', len(data)-12+20) + b'\x00\x00\x00\x00\x00\x00\x00\x00' + struct.pack('>I', definitionID) + b'\x00\x00\x00\x00' + data[12:]
        super().__init__(index, time, definitionID, data)
    
    def parse(self, oldMessage = None):
        readFunc = self.data.readValue
        
        readFunc(int,44*8) #以下の信号は無視
#         uint8 ADAS_TSR_OSP_SubsignAdditional_Zone1;
#         uint8 ADAS_TSR_OSP_SubsignAdditional_Zone2;
#         uint8 ADAS_TSR_OSP_SubsignAdditional_Zone3;
#         uint8 ADAS_SpeedLimitType;
#         uint8 ADAS_OverSpeedWarningSound;
#         uint8 ADAS_OSPConvertedSpeedDisplayRequest;
#         uint8 ADAS_RainSymbolDisplayRequest;
#         uint8 ADAS_TSR_OSP_SubsignZone2;
#         uint8 ADAS_TSR_OSP_SpeedSignalZone1;
#         uint8 ADAS_TSR_OSP_SpeedSignalZone2;
#         uint8 ADAS_TSR_OSP_TrafficSignZone3;
#         uint8 ADAS_TSR_OSP_SubsignZone1;
#         uint8 ADAS_OSPOverSpeedDisplayRequest;
#         uint8 ADAS_TSR_OSP_SubsignZone3;
#         uint8 ADAS_OSPDisplayRequest;
#         uint8 ADAS_TSR_OSP_ActivationStatus;
#         uint8 ADAS_TSR_OSP_FailureDisplay;
#         uint8 ADAS_TSR_OSP_TypeSignalZone1;
#         uint8 ADAS_TSR_OSP_TypeSignalZone2;
#         uint8 ADAS_OSPSpeedLimit_Display;
#         uint8 ADAS_OSPSpeedLimitZone2_Display;
#         uint8 ADAS_TSR_ConfidenceLevel;
#         uint8 CommonHeader[20];
#         uint16 CommonHeader_Reserved;
        
        #DataforEYEQ
        self.Distance_X = readFunc(int,16) * 0.1 + 0
        self.IMU_Acc_Z = readFunc(int,16,True) * 0.0009765625 + 0
        self.IMU_Acc_X_Valid = readFunc(int,16) * 1 + 0
        self.Vehicle_Yaw = readFunc(int,16,True) * 0.0038109756097561 + 0
        self.Vehicle_Pitch = readFunc(int,16,True) * 0.0038109756097561 + 0
        self.Vehicle_Roll = readFunc(int,16,True) * 0.0038109756097561 + 0
        self.VehicleGyroValid = readFunc(int,16) * 1 + 0
        self.WheelTicks_FrontLeft_Value = readFunc(int,16) * 0.0416666666666667 + 0
        self.WheelTicks_FrontRight_Value = readFunc(int,16) * 0.0416666666666667 + 0
        self.WheelTicks_RearLeft_Value = readFunc(int,16) * 0.0416666666666667 + 0
        self.WheelTicks_RearRight_Value = readFunc(int,16) * 0.0416666666666667 + 0
        self.WheelDriveDirection_FrontLeft = readFunc(int,5) * 1 + 0
        self.ESP_Engagment_Flag = readFunc(int,1) * 1 + 0
        self.Motor_RPM = readFunc(int,16) * 0.125 + 0
        self.Four_Wheel_Drive_Engagement = readFunc(int,5) * 1 + 0
        self.Accelerator_Pedal_State = readFunc(int,8) * 0.392156862745098 + 0
        self.Tire_Pressure = readFunc(int,8) * 0.25 + 0
        self.Brake_Pressure = readFunc(int,4) * 5 + 0
        self.Wheel_Radius_Status = readFunc(int,10) * 0.001 + 0
        self.Transmission_Output_Torque = readFunc(int,12,True) * 2.5 + 0
        self.Brake_Pressure_Valid = readFunc(int,2) * 1 + 0
        readFunc(int,1) #reserve
        readFunc(int,136) #reserve

        #GNSSforEYEQ
        self.EYEQ_GPS_Data_Status = readFunc(int,3) * 1 + 0
        self.EYEQ_GPS_Num_Satellites = readFunc(int,8) * 1 + 0
        self.EYEQ_GPS_UTC_hour = readFunc(int,8) * 1 + 0
        self.EYEQ_GPS_UTC_min = readFunc(int,8) * 1 + 0
        self.EYEQ_GPS_UTC_sec = readFunc(int,8) * 1 + 0
        self.EYEQ_GPS_Speed_Over_Ground = readFunc(int,32,True) * 1 + 0
        self.EYEQ_GPS_Longitude = readFunc(int,32,True) * 0.0000001 + 0
        self.EYEQ_GPS_Lattitude = readFunc(int,32,True) * 0.0000001 + 0
        self.EYEQ_GPS_hMSL = readFunc(int,32,True) * 1 + 0
        self.EYEQ_GPS_HDOP = readFunc(int,16) * 0.01 + 0
        self.EYEQ_GPS_Course = readFunc(int,32,True) * 0.00001 + 0
        self.EYEQ_GPS_horizontal_ACC = readFunc(int,32) * 1 + 0
        self.EYEQ_GPS_sensor_timestamp = readFunc(int,48) * 1 + 0
        self.EYEQ_GPS_timestamp = readFunc(int,48) * 1 + 0
        self.EYEQ_GPS_Alt_model = readFunc(bool,1)
        readFunc(int,12) #reserve
        self.EYEQ_GPS_EPOCH_Timestamp = readFunc(int,64) * 1 + 0
        readFunc(int,96) #reserve
        self.assertMessageSize()
            
    def printHeader(self, sheet, row, col, _level = 1):
        [_, col, _] = self.commonHeader.printHeader(sheet, row, col)
        
        titleStr = [
            'Distance X',
            'IMU_Acc_Z',
            'IMU_Acc_X_Valid',
            'Vehicle_Yaw',
            'Vehicle_Pitch',
            'Vehicle_Roll',
            'VehicleGyroValid',
            'WheelTicks_FrontLeft_Value',
            'WheelTicks_FrontRight_Value',
            'WheelTicks_RearLeft_Value',
            'WheelTicks_RearRight_Value',
            'WheelDriveDirection_FrontLeft',
            'ESP_Engagment_Flag',
            'Motor_RPM',
            'Four_Wheel_Drive_Engagement',
            'Accelerator_Pedal_State',
            'Tire_Pressure',
            'Brake_Pressure',
            'Wheel_Radius_Status',
            'Transmission_Output_Torque',
            'Brake_Pressure_Valid',
            'EYEQ_GPS_Data_Status',
            'EYEQ_GPS_Num_Satellites',
            'EYEQ_GPS_UTC_hour',
            'EYEQ_GPS_UTC_min',
            'EYEQ_GPS_UTC_sec',
            'EYEQ_GPS_Speed_Over_Ground',
            'EYEQ_GPS_Longitude',
            'EYEQ_GPS_Lattitude',
            'EYEQ_GPS_hMSL',
            'EYEQ_GPS_HDOP',
            'EYEQ_GPS_Course',
            'EYEQ_GPS_horizontal_ACC',
            'EYEQ_GPS_sensor_timestamp',
            'EYEQ_GPS_timestamp',
            'EYEQ_GPS_Alt_model',
            'EYEQ_GPS_EPOCH_Timestamp']
        
        sheet.write_row(row, col, titleStr, sheet.cellFormats('header'))
        col += len(titleStr)
        
        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 20)
        sheet.autofilter(0, 0, 0, col-1)
        return [row+1, 0, []]
    
    def printValue(self, sheet, row, col, _level = 1):
        [row, col, _] = self.commonHeader.printValue(sheet, row, col)
        
        sheet.write_row(row, col, [
            (self.Distance_X),
            (self.IMU_Acc_Z),
            (self.IMU_Acc_X_Valid),
            (self.Vehicle_Yaw),
            (self.Vehicle_Pitch),
            (self.Vehicle_Roll),
            (self.VehicleGyroValid),
            (self.WheelTicks_FrontLeft_Value),
            (self.WheelTicks_FrontRight_Value),
            (self.WheelTicks_RearLeft_Value),
            (self.WheelTicks_RearRight_Value),
            (self.WheelDriveDirection_FrontLeft),
            (self.ESP_Engagment_Flag),
            (self.Motor_RPM),
            (self.Four_Wheel_Drive_Engagement),
            (self.Accelerator_Pedal_State),
            (self.Tire_Pressure),
            (self.Brake_Pressure),
            (self.Wheel_Radius_Status),
            (self.Transmission_Output_Torque),
            (self.Brake_Pressure_Valid),
            (self.EYEQ_GPS_Data_Status),
            (self.EYEQ_GPS_Num_Satellites),
            (self.EYEQ_GPS_UTC_hour),
            (self.EYEQ_GPS_UTC_min),
            (self.EYEQ_GPS_UTC_sec),
            (self.EYEQ_GPS_Speed_Over_Ground),
            (self.EYEQ_GPS_Longitude),
            (self.EYEQ_GPS_Lattitude),
            (self.EYEQ_GPS_hMSL),
            (self.EYEQ_GPS_HDOP),
            (self.EYEQ_GPS_Course),
            (self.EYEQ_GPS_horizontal_ACC),
            (self.EYEQ_GPS_sensor_timestamp),
            (self.EYEQ_GPS_timestamp),
            ('MSL(Geiod)' if self.EYEQ_GPS_Alt_model else 'Ellipsoid'),
            (self.EYEQ_GPS_EPOCH_Timestamp)])
        
        return  [row+1, 0, []]  
    
        
